"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/core/ContactShadows.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/ContactShadows.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContactShadows: () => (/* binding */ ContactShadows)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/shaders/HorizontalBlurShader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/shaders/VerticalBlurShader.js\");\n\n\n\n\n\nconst ContactShadows = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ scale = 10, frames = Infinity, opacity = 1, width = 1, height = 1, blur = 1, near = 0, far = 10, resolution = 512, smooth = true, color = \"#000000\", depthWrite = false, renderOrder, ...props }, fref)=>{\n    const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const scene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.gl);\n    const shadowCamera = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    width = width * (Array.isArray(scale) ? scale[0] : scale || 1);\n    height = height * (Array.isArray(scale) ? scale[1] : scale || 1);\n    const [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur] = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>{\n        const renderTarget = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTarget(resolution, resolution);\n        const renderTargetBlur = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTarget(resolution, resolution);\n        renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;\n        const planeGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(width, height).rotateX(Math.PI / 2);\n        const blurPlane = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(planeGeometry);\n        const depthMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.MeshDepthMaterial();\n        depthMaterial.depthTest = depthMaterial.depthWrite = false;\n        depthMaterial.onBeforeCompile = (shader)=>{\n            shader.uniforms = {\n                ...shader.uniforms,\n                ucolor: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_3__.Color(color)\n                }\n            };\n            shader.fragmentShader = shader.fragmentShader.replace(`void main() {`, //\n            `uniform vec3 ucolor;\n           void main() {\n          `);\n            shader.fragmentShader = shader.fragmentShader.replace(\"vec4( vec3( 1.0 - fragCoordZ ), opacity );\", // Colorize the shadow, multiply by the falloff so that the center can remain darker\n            \"vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );\");\n        };\n        const horizontalBlurMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.ShaderMaterial(three_stdlib__WEBPACK_IMPORTED_MODULE_4__.HorizontalBlurShader);\n        const verticalBlurMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.ShaderMaterial(three_stdlib__WEBPACK_IMPORTED_MODULE_5__.VerticalBlurShader);\n        verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;\n        return [\n            renderTarget,\n            planeGeometry,\n            depthMaterial,\n            blurPlane,\n            horizontalBlurMaterial,\n            verticalBlurMaterial,\n            renderTargetBlur\n        ];\n    }, [\n        resolution,\n        width,\n        height,\n        scale,\n        color\n    ]);\n    const blurShadows = (blur)=>{\n        blurPlane.visible = true;\n        blurPlane.material = horizontalBlurMaterial;\n        horizontalBlurMaterial.uniforms.tDiffuse.value = renderTarget.texture;\n        horizontalBlurMaterial.uniforms.h.value = blur * 1 / 256;\n        gl.setRenderTarget(renderTargetBlur);\n        gl.render(blurPlane, shadowCamera.current);\n        blurPlane.material = verticalBlurMaterial;\n        verticalBlurMaterial.uniforms.tDiffuse.value = renderTargetBlur.texture;\n        verticalBlurMaterial.uniforms.v.value = blur * 1 / 256;\n        gl.setRenderTarget(renderTarget);\n        gl.render(blurPlane, shadowCamera.current);\n        blurPlane.visible = false;\n    };\n    let count = 0;\n    let initialBackground;\n    let initialOverrideMaterial;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(()=>{\n        if (shadowCamera.current && (frames === Infinity || count < frames)) {\n            count++;\n            initialBackground = scene.background;\n            initialOverrideMaterial = scene.overrideMaterial;\n            ref.current.visible = false;\n            scene.background = null;\n            scene.overrideMaterial = depthMaterial;\n            gl.setRenderTarget(renderTarget);\n            gl.render(scene, shadowCamera.current);\n            blurShadows(blur);\n            if (smooth) blurShadows(blur * 0.4);\n            gl.setRenderTarget(null);\n            ref.current.visible = true;\n            scene.overrideMaterial = initialOverrideMaterial;\n            scene.background = initialBackground;\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(fref, ()=>ref.current, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        \"rotation-x\": Math.PI / 2\n    }, props, {\n        ref: ref\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", {\n        renderOrder: renderOrder,\n        geometry: planeGeometry,\n        scale: [\n            1,\n            -1,\n            1\n        ],\n        rotation: [\n            -Math.PI / 2,\n            0,\n            0\n        ]\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshBasicMaterial\", {\n        transparent: true,\n        map: renderTarget.texture,\n        opacity: opacity,\n        depthWrite: depthWrite\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"orthographicCamera\", {\n        ref: shadowCamera,\n        args: [\n            -width / 2,\n            width / 2,\n            height / 2,\n            -height / 2,\n            near,\n            far\n        ]\n    }));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Db250YWN0U2hhZG93cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUNBO0FBQ3lCO0FBQ2dCO0FBRXhFLE1BQU1PLGlCQUFpQixhQUFhLGlCQUFFTiw2Q0FBZ0IsQ0FBQyxDQUFDLEVBQ3REUSxRQUFRLEVBQUUsRUFDVkMsU0FBU0MsUUFBUSxFQUNqQkMsVUFBVSxDQUFDLEVBQ1hDLFFBQVEsQ0FBQyxFQUNUQyxTQUFTLENBQUMsRUFDVkMsT0FBTyxDQUFDLEVBQ1JDLE9BQU8sQ0FBQyxFQUNSQyxNQUFNLEVBQUUsRUFDUkMsYUFBYSxHQUFHLEVBQ2hCQyxTQUFTLElBQUksRUFDYkMsUUFBUSxTQUFTLEVBQ2pCQyxhQUFhLEtBQUssRUFDbEJDLFdBQVcsRUFDWCxHQUFHQyxPQUNKLEVBQUVDO0lBQ0QsTUFBTUMsTUFBTXhCLHlDQUFZLENBQUM7SUFDekIsTUFBTTBCLFFBQVF4QixxREFBUUEsQ0FBQ3lCLENBQUFBLFFBQVNBLE1BQU1ELEtBQUs7SUFDM0MsTUFBTUUsS0FBSzFCLHFEQUFRQSxDQUFDeUIsQ0FBQUEsUUFBU0EsTUFBTUMsRUFBRTtJQUNyQyxNQUFNQyxlQUFlN0IseUNBQVksQ0FBQztJQUNsQ1ksUUFBUUEsUUFBU2tCLENBQUFBLE1BQU1DLE9BQU8sQ0FBQ3ZCLFNBQVNBLEtBQUssQ0FBQyxFQUFFLEdBQUdBLFNBQVM7SUFDNURLLFNBQVNBLFNBQVVpQixDQUFBQSxNQUFNQyxPQUFPLENBQUN2QixTQUFTQSxLQUFLLENBQUMsRUFBRSxHQUFHQSxTQUFTO0lBQzlELE1BQU0sQ0FBQ3dCLGNBQWNDLGVBQWVDLGVBQWVDLFdBQVdDLHdCQUF3QkMsc0JBQXNCQyxpQkFBaUIsR0FBR3RDLDBDQUFhLENBQUM7UUFDNUksTUFBTWdDLGVBQWUsSUFBSS9CLG9EQUF1QixDQUFDZ0IsWUFBWUE7UUFDN0QsTUFBTXFCLG1CQUFtQixJQUFJckMsb0RBQXVC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dEJsQyxNQUFNOEMsZ0JBQWdCLEdBQUdGO1lBQ3pCNUMsTUFBTTZDLFVBQVUsR0FBR0Y7UUFDckI7SUFDRjtJQUNBckUsc0RBQXlCLENBQUN1QixNQUFNLElBQU1DLElBQUkwQyxPQUFPLEVBQUUsRUFBRTtJQUNyRCxPQUFPLFdBQVcsR0FBRWxFLGdEQUFtQixDQUFDLFNBQVNELDhFQUFRQSxDQUFDO1FBQ3hELGNBQWM4QyxLQUFLQyxFQUFFLEdBQUc7SUFDMUIsR0FBR3hCLE9BQU87UUFDUkUsS0FBS0E7SUFDUCxJQUFJLFdBQVcsR0FBRXhCLGdEQUFtQixDQUFDLFFBQVE7UUFDM0NxQixhQUFhQTtRQUNic0QsVUFBVTFDO1FBQ1Z6QixPQUFPO1lBQUM7WUFBRyxDQUFDO1lBQUc7U0FBRTtRQUNqQm9FLFVBQVU7WUFBQyxDQUFDL0IsS0FBS0MsRUFBRSxHQUFHO1lBQUc7WUFBRztTQUFFO0lBQ2hDLEdBQUcsV0FBVyxHQUFFOUMsZ0RBQW1CLENBQUMscUJBQXFCO1FBQ3ZENkUsYUFBYTtRQUNiQyxLQUFLOUMsYUFBYVMsT0FBTztRQUN6QjlCLFNBQVNBO1FBQ1RTLFlBQVlBO0lBQ2QsS0FBSyxXQUFXLEdBQUVwQixnREFBbUIsQ0FBQyxzQkFBc0I7UUFDMUR3QixLQUFLSztRQUNMa0QsTUFBTTtZQUFDLENBQUNuRSxRQUFRO1lBQUdBLFFBQVE7WUFBR0MsU0FBUztZQUFHLENBQUNBLFNBQVM7WUFBR0U7WUFBTUM7U0FBSTtJQUNuRTtBQUNGO0FBRTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm9ja2V0c2ltLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvQ29udGFjdFNoYWRvd3MuanM/Mzc1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyB1c2VUaHJlZSwgdXNlRnJhbWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgSG9yaXpvbnRhbEJsdXJTaGFkZXIsIFZlcnRpY2FsQmx1clNoYWRlciB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5cbmNvbnN0IENvbnRhY3RTaGFkb3dzID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBzY2FsZSA9IDEwLFxuICBmcmFtZXMgPSBJbmZpbml0eSxcbiAgb3BhY2l0eSA9IDEsXG4gIHdpZHRoID0gMSxcbiAgaGVpZ2h0ID0gMSxcbiAgYmx1ciA9IDEsXG4gIG5lYXIgPSAwLFxuICBmYXIgPSAxMCxcbiAgcmVzb2x1dGlvbiA9IDUxMixcbiAgc21vb3RoID0gdHJ1ZSxcbiAgY29sb3IgPSAnIzAwMDAwMCcsXG4gIGRlcHRoV3JpdGUgPSBmYWxzZSxcbiAgcmVuZGVyT3JkZXIsXG4gIC4uLnByb3BzXG59LCBmcmVmKSA9PiB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2NlbmUgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5zY2VuZSk7XG4gIGNvbnN0IGdsID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuZ2wpO1xuICBjb25zdCBzaGFkb3dDYW1lcmEgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHdpZHRoID0gd2lkdGggKiAoQXJyYXkuaXNBcnJheShzY2FsZSkgPyBzY2FsZVswXSA6IHNjYWxlIHx8IDEpO1xuICBoZWlnaHQgPSBoZWlnaHQgKiAoQXJyYXkuaXNBcnJheShzY2FsZSkgPyBzY2FsZVsxXSA6IHNjYWxlIHx8IDEpO1xuICBjb25zdCBbcmVuZGVyVGFyZ2V0LCBwbGFuZUdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBibHVyUGxhbmUsIGhvcml6b250YWxCbHVyTWF0ZXJpYWwsIHZlcnRpY2FsQmx1ck1hdGVyaWFsLCByZW5kZXJUYXJnZXRCbHVyXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldChyZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRCbHVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KHJlc29sdXRpb24sIHJlc29sdXRpb24pO1xuICAgIHJlbmRlclRhcmdldEJsdXIudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICBjb25zdCBwbGFuZUdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkod2lkdGgsIGhlaWdodCkucm90YXRlWChNYXRoLlBJIC8gMik7XG4gICAgY29uc3QgYmx1clBsYW5lID0gbmV3IFRIUkVFLk1lc2gocGxhbmVHZW9tZXRyeSk7XG4gICAgY29uc3QgZGVwdGhNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCgpO1xuICAgIGRlcHRoTWF0ZXJpYWwuZGVwdGhUZXN0ID0gZGVwdGhNYXRlcmlhbC5kZXB0aFdyaXRlID0gZmFsc2U7XG4gICAgZGVwdGhNYXRlcmlhbC5vbkJlZm9yZUNvbXBpbGUgPSBzaGFkZXIgPT4ge1xuICAgICAgc2hhZGVyLnVuaWZvcm1zID0ge1xuICAgICAgICAuLi5zaGFkZXIudW5pZm9ybXMsXG4gICAgICAgIHVjb2xvcjoge1xuICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoY29sb3IpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXIuZnJhZ21lbnRTaGFkZXIucmVwbGFjZShgdm9pZCBtYWluKCkge2AsXG4gICAgICAvL1xuICAgICAgYHVuaWZvcm0gdmVjMyB1Y29sb3I7XG4gICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICBgKTtcbiAgICAgIHNoYWRlci5mcmFnbWVudFNoYWRlciA9IHNoYWRlci5mcmFnbWVudFNoYWRlci5yZXBsYWNlKCd2ZWM0KCB2ZWMzKCAxLjAgLSBmcmFnQ29vcmRaICksIG9wYWNpdHkgKTsnLFxuICAgICAgLy8gQ29sb3JpemUgdGhlIHNoYWRvdywgbXVsdGlwbHkgYnkgdGhlIGZhbGxvZmYgc28gdGhhdCB0aGUgY2VudGVyIGNhbiByZW1haW4gZGFya2VyXG4gICAgICAndmVjNCggdWNvbG9yICogZnJhZ0Nvb3JkWiAqIDIuMCwgKCAxLjAgLSBmcmFnQ29vcmRaICkgKiAxLjAgKTsnKTtcbiAgICB9O1xuICAgIGNvbnN0IGhvcml6b250YWxCbHVyTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoSG9yaXpvbnRhbEJsdXJTaGFkZXIpO1xuICAgIGNvbnN0IHZlcnRpY2FsQmx1ck1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKFZlcnRpY2FsQmx1clNoYWRlcik7XG4gICAgdmVydGljYWxCbHVyTWF0ZXJpYWwuZGVwdGhUZXN0ID0gaG9yaXpvbnRhbEJsdXJNYXRlcmlhbC5kZXB0aFRlc3QgPSBmYWxzZTtcbiAgICByZXR1cm4gW3JlbmRlclRhcmdldCwgcGxhbmVHZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgYmx1clBsYW5lLCBob3Jpem9udGFsQmx1ck1hdGVyaWFsLCB2ZXJ0aWNhbEJsdXJNYXRlcmlhbCwgcmVuZGVyVGFyZ2V0Qmx1cl07XG4gIH0sIFtyZXNvbHV0aW9uLCB3aWR0aCwgaGVpZ2h0LCBzY2FsZSwgY29sb3JdKTtcbiAgY29uc3QgYmx1clNoYWRvd3MgPSBibHVyID0+IHtcbiAgICBibHVyUGxhbmUudmlzaWJsZSA9IHRydWU7XG4gICAgYmx1clBsYW5lLm1hdGVyaWFsID0gaG9yaXpvbnRhbEJsdXJNYXRlcmlhbDtcbiAgICBob3Jpem9udGFsQmx1ck1hdGVyaWFsLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gICAgaG9yaXpvbnRhbEJsdXJNYXRlcmlhbC51bmlmb3Jtcy5oLnZhbHVlID0gYmx1ciAqIDEgLyAyNTY7XG4gICAgZ2wuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldEJsdXIpO1xuICAgIGdsLnJlbmRlcihibHVyUGxhbmUsIHNoYWRvd0NhbWVyYS5jdXJyZW50KTtcbiAgICBibHVyUGxhbmUubWF0ZXJpYWwgPSB2ZXJ0aWNhbEJsdXJNYXRlcmlhbDtcbiAgICB2ZXJ0aWNhbEJsdXJNYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlbmRlclRhcmdldEJsdXIudGV4dHVyZTtcbiAgICB2ZXJ0aWNhbEJsdXJNYXRlcmlhbC51bmlmb3Jtcy52LnZhbHVlID0gYmx1ciAqIDEgLyAyNTY7XG4gICAgZ2wuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgZ2wucmVuZGVyKGJsdXJQbGFuZSwgc2hhZG93Q2FtZXJhLmN1cnJlbnQpO1xuICAgIGJsdXJQbGFuZS52aXNpYmxlID0gZmFsc2U7XG4gIH07XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBpbml0aWFsQmFja2dyb3VuZDtcbiAgbGV0IGluaXRpYWxPdmVycmlkZU1hdGVyaWFsO1xuICB1c2VGcmFtZSgoKSA9PiB7XG4gICAgaWYgKHNoYWRvd0NhbWVyYS5jdXJyZW50ICYmIChmcmFtZXMgPT09IEluZmluaXR5IHx8IGNvdW50IDwgZnJhbWVzKSkge1xuICAgICAgY291bnQrKztcbiAgICAgIGluaXRpYWxCYWNrZ3JvdW5kID0gc2NlbmUuYmFja2dyb3VuZDtcbiAgICAgIGluaXRpYWxPdmVycmlkZU1hdGVyaWFsID0gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbDtcbiAgICAgIHJlZi5jdXJyZW50LnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHNjZW5lLmJhY2tncm91bmQgPSBudWxsO1xuICAgICAgc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IGRlcHRoTWF0ZXJpYWw7XG4gICAgICBnbC5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbiAgICAgIGdsLnJlbmRlcihzY2VuZSwgc2hhZG93Q2FtZXJhLmN1cnJlbnQpO1xuICAgICAgYmx1clNoYWRvd3MoYmx1cik7XG4gICAgICBpZiAoc21vb3RoKSBibHVyU2hhZG93cyhibHVyICogMC40KTtcbiAgICAgIGdsLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICAgIHJlZi5jdXJyZW50LnZpc2libGUgPSB0cnVlO1xuICAgICAgc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IGluaXRpYWxPdmVycmlkZU1hdGVyaWFsO1xuICAgICAgc2NlbmUuYmFja2dyb3VuZCA9IGluaXRpYWxCYWNrZ3JvdW5kO1xuICAgIH1cbiAgfSk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUoZnJlZiwgKCkgPT4gcmVmLmN1cnJlbnQsIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIiwgX2V4dGVuZHMoe1xuICAgIFwicm90YXRpb24teFwiOiBNYXRoLlBJIC8gMlxuICB9LCBwcm9wcywge1xuICAgIHJlZjogcmVmXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1lc2hcIiwge1xuICAgIHJlbmRlck9yZGVyOiByZW5kZXJPcmRlcixcbiAgICBnZW9tZXRyeTogcGxhbmVHZW9tZXRyeSxcbiAgICBzY2FsZTogWzEsIC0xLCAxXSxcbiAgICByb3RhdGlvbjogWy1NYXRoLlBJIC8gMiwgMCwgMF1cbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLCB7XG4gICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgbWFwOiByZW5kZXJUYXJnZXQudGV4dHVyZSxcbiAgICBvcGFjaXR5OiBvcGFjaXR5LFxuICAgIGRlcHRoV3JpdGU6IGRlcHRoV3JpdGVcbiAgfSkpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm9ydGhvZ3JhcGhpY0NhbWVyYVwiLCB7XG4gICAgcmVmOiBzaGFkb3dDYW1lcmEsXG4gICAgYXJnczogWy13aWR0aCAvIDIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgLWhlaWdodCAvIDIsIG5lYXIsIGZhcl1cbiAgfSkpO1xufSk7XG5cbmV4cG9ydCB7IENvbnRhY3RTaGFkb3dzIH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJSZWFjdCIsIlRIUkVFIiwidXNlVGhyZWUiLCJ1c2VGcmFtZSIsIkhvcml6b250YWxCbHVyU2hhZGVyIiwiVmVydGljYWxCbHVyU2hhZGVyIiwiQ29udGFjdFNoYWRvd3MiLCJmb3J3YXJkUmVmIiwic2NhbGUiLCJmcmFtZXMiLCJJbmZpbml0eSIsIm9wYWNpdHkiLCJ3aWR0aCIsImhlaWdodCIsImJsdXIiLCJuZWFyIiwiZmFyIiwicmVzb2x1dGlvbiIsInNtb290aCIsImNvbG9yIiwiZGVwdGhXcml0ZSIsInJlbmRlck9yZGVyIiwicHJvcHMiLCJmcmVmIiwicmVmIiwidXNlUmVmIiwic2NlbmUiLCJzdGF0ZSIsImdsIiwic2hhZG93Q2FtZXJhIiwiQXJyYXkiLCJpc0FycmF5IiwicmVuZGVyVGFyZ2V0IiwicGxhbmVHZW9tZXRyeSIsImRlcHRoTWF0ZXJpYWwiLCJibHVyUGxhbmUiLCJob3Jpem9udGFsQmx1ck1hdGVyaWFsIiwidmVydGljYWxCbHVyTWF0ZXJpYWwiLCJyZW5kZXJUYXJnZXRCbHVyIiwidXNlTWVtbyIsIldlYkdMUmVuZGVyVGFyZ2V0IiwidGV4dHVyZSIsImdlbmVyYXRlTWlwbWFwcyIsIlBsYW5lR2VvbWV0cnkiLCJyb3RhdGVYIiwiTWF0aCIsIlBJIiwiTWVzaCIsIk1lc2hEZXB0aE1hdGVyaWFsIiwiZGVwdGhUZXN0Iiwib25CZWZvcmVDb21waWxlIiwic2hhZGVyIiwidW5pZm9ybXMiLCJ1Y29sb3IiLCJ2YWx1ZSIsIkNvbG9yIiwiZnJhZ21lbnRTaGFkZXIiLCJyZXBsYWNlIiwiU2hhZGVyTWF0ZXJpYWwiLCJibHVyU2hhZG93cyIsInZpc2libGUiLCJtYXRlcmlhbCIsInREaWZmdXNlIiwiaCIsInNldFJlbmRlclRhcmdldCIsInJlbmRlciIsImN1cnJlbnQiLCJ2IiwiY291bnQiLCJpbml0aWFsQmFja2dyb3VuZCIsImluaXRpYWxPdmVycmlkZU1hdGVyaWFsIiwiYmFja2dyb3VuZCIsIm92ZXJyaWRlTWF0ZXJpYWwiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiY3JlYXRlRWxlbWVudCIsImdlb21ldHJ5Iiwicm90YXRpb24iLCJ0cmFuc3BhcmVudCIsIm1hcCIsImFyZ3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/ContactShadows.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Environment.js":
/*!************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Environment.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   EnvironmentCube: () => (/* binding */ EnvironmentCube),\n/* harmony export */   EnvironmentMap: () => (/* binding */ EnvironmentMap),\n/* harmony export */   EnvironmentPortal: () => (/* binding */ EnvironmentPortal)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/objects/GroundProjectedEnv.js\");\n/* harmony import */ var _useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useEnvironment.js */ \"(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\");\n\n\n\n\n\n\nconst isRef = (obj)=>obj.current && obj.current.isScene;\nconst resolveScene = (scene)=>isRef(scene) ? scene.current : scene;\nfunction setEnvProps(background, scene, defaultScene, texture, sceneProps = {}) {\n    var _target$backgroundRot, _target$backgroundRot2, _target$environmentRo, _target$environmentRo2;\n    // defaults\n    sceneProps = {\n        backgroundBlurriness: 0,\n        backgroundIntensity: 1,\n        backgroundRotation: [\n            0,\n            0,\n            0\n        ],\n        environmentIntensity: 1,\n        environmentRotation: [\n            0,\n            0,\n            0\n        ],\n        ...sceneProps\n    };\n    const target = resolveScene(scene || defaultScene);\n    const oldbg = target.background;\n    const oldenv = target.environment;\n    const oldSceneProps = {\n        // @ts-ignore\n        backgroundBlurriness: target.backgroundBlurriness,\n        // @ts-ignore\n        backgroundIntensity: target.backgroundIntensity,\n        // @ts-ignore\n        backgroundRotation: (_target$backgroundRot = (_target$backgroundRot2 = target.backgroundRotation) == null || _target$backgroundRot2.clone == null ? void 0 : _target$backgroundRot2.clone()) !== null && _target$backgroundRot !== void 0 ? _target$backgroundRot : [\n            0,\n            0,\n            0\n        ],\n        // @ts-ignore\n        environmentIntensity: target.environmentIntensity,\n        // @ts-ignore\n        environmentRotation: (_target$environmentRo = (_target$environmentRo2 = target.environmentRotation) == null || _target$environmentRo2.clone == null ? void 0 : _target$environmentRo2.clone()) !== null && _target$environmentRo !== void 0 ? _target$environmentRo : [\n            0,\n            0,\n            0\n        ]\n    };\n    if (background !== \"only\") target.environment = texture;\n    if (background) target.background = texture;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.j)(target, sceneProps);\n    return ()=>{\n        if (background !== \"only\") target.environment = oldenv;\n        if (background) target.background = oldbg;\n        (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.j)(target, oldSceneProps);\n    };\n}\nfunction EnvironmentMap({ scene, background = false, map, ...config }) {\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (map) return setEnvProps(background, scene, defaultScene, map, config);\n    });\n    return null;\n}\nfunction EnvironmentCube({ background = false, scene, blur, backgroundBlurriness, backgroundIntensity, backgroundRotation, environmentIntensity, environmentRotation, ...rest }) {\n    const texture = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(rest);\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        return setEnvProps(background, scene, defaultScene, texture, {\n            backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,\n            backgroundIntensity,\n            backgroundRotation,\n            environmentIntensity,\n            environmentRotation\n        });\n    });\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        return ()=>{\n            texture.dispose();\n        };\n    }, [\n        texture\n    ]);\n    return null;\n}\nfunction EnvironmentPortal({ children, near = 0.1, far = 1000, resolution = 256, frames = 1, map, background = false, blur, backgroundBlurriness, backgroundIntensity, backgroundRotation, environmentIntensity, environmentRotation, scene, files, path, preset = undefined, extensions }) {\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.gl);\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    const camera = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const [virtualScene] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Scene());\n    const fbo = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>{\n        const fbo = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLCubeRenderTarget(resolution);\n        fbo.texture.type = three__WEBPACK_IMPORTED_MODULE_4__.HalfFloatType;\n        return fbo;\n    }, [\n        resolution\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        return ()=>{\n            fbo.dispose();\n        };\n    }, [\n        fbo\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (frames === 1) {\n            const autoClear = gl.autoClear;\n            gl.autoClear = true;\n            camera.current.update(gl, virtualScene);\n            gl.autoClear = autoClear;\n        }\n        return setEnvProps(background, scene, defaultScene, fbo.texture, {\n            backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,\n            backgroundIntensity,\n            backgroundRotation,\n            environmentIntensity,\n            environmentRotation\n        });\n    }, [\n        children,\n        virtualScene,\n        fbo.texture,\n        scene,\n        defaultScene,\n        background,\n        frames,\n        gl\n    ]);\n    let count = 1;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(()=>{\n        if (frames === Infinity || count < frames) {\n            const autoClear = gl.autoClear;\n            gl.autoClear = true;\n            camera.current.update(gl, virtualScene);\n            gl.autoClear = autoClear;\n            count++;\n        }\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.g)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"cubeCamera\", {\n        ref: camera,\n        args: [\n            near,\n            far,\n            fbo\n        ]\n    }), files || preset ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, {\n        background: true,\n        files: files,\n        preset: preset,\n        path: path,\n        extensions: extensions\n    }) : map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, {\n        background: true,\n        map: map,\n        extensions: extensions\n    }) : null), virtualScene));\n}\nfunction EnvironmentGround(props) {\n    var _props$ground, _props$ground2, _scale, _props$ground3;\n    const textureDefault = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(props);\n    const texture = props.map || textureDefault;\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.e)({\n            GroundProjectedEnvImpl: three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GroundProjectedEnv\n        }), []);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        return ()=>{\n            textureDefault.dispose();\n        };\n    }, [\n        textureDefault\n    ]);\n    const args = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>[\n            texture\n        ], [\n        texture\n    ]);\n    const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n    const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n    const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n        map: texture\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"groundProjectedEnvImpl\", {\n        args: args,\n        scale: scale,\n        height: height,\n        radius: radius\n    }));\n}\nfunction Environment(props) {\n    return props.ground ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentPortal, props) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, props);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9FbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUMyRDtBQUN0QjtBQUNsQjtBQUNHO0FBRXJELE1BQU1ZLFFBQVFDLENBQUFBLE1BQU9BLElBQUlDLE9BQU8sSUFBSUQsSUFBSUMsT0FBTyxDQUFDQyxPQUFPO0FBQ3ZELE1BQU1DLGVBQWVDLENBQUFBLFFBQVNMLE1BQU1LLFNBQVNBLE1BQU1ILE9BQU8sR0FBR0c7QUFDN0QsU0FBU0MsWUFBWUMsVUFBVSxFQUFFRixLQUFLLEVBQUVHLFlBQVksRUFBRUMsT0FBTyxFQUFFQyxhQUFhLENBQUMsQ0FBQztJQUM1RSxJQUFJQyx1QkFBdUJDLHdCQUF3QkMsdUJBQXVCQztJQUMxRSxXQUFXO0lBQ1hKLGFBQWE7UUFDWEssc0JBQXNCO1FBQ3RCQyxxQkFBcUI7UUFDckJDLG9CQUFvQjtZQUFDO1lBQUc7WUFBRztTQUFFO1FBQzdCQyxzQkFBc0I7UUFDdEJDLHFCQUFxQjtZQUFDO1lBQUc7WUFBRztTQUFFO1FBQzlCLEdBQUdULFVBQVU7SUFDZjtJQUNBLE1BQU1VLFNBQVNoQixhQUFhQyxTQUFTRztJQUNyQyxNQUFNYSxRQUFRRCxPQUFPYixVQUFVO0lBQy9CLE1BQU1lLFNBQVNGLE9BQU9HLFdBQVc7SUFDakMsTUFBTUMsZ0JBQWdCO1FBQ3BCLGFBQWE7UUFDYlQsc0JBQXNCSyxPQUFPTCxvQkFBb0I7UUFDakQsYUFBYTtRQUNiQyxxQkFBcUJJLE9BQU9KLG1CQUFtQjtRQUMvQyxhQUFhO1FBQ2JDLG9CQUFvQixDQUFDTix3QkFBd0IsQ0FBQ0MseUJBQXlCUSxPQUFPSCxrQkFBa0IsS0FBSyxRQUFRTCx1QkFBdUJhLEtBQUssSUFBSSxPQUFPLEtBQUssSUFBSWIsdUJBQXVCYSxLQUFLLEVBQUMsTUFBTyxRQUFRZCwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0I7WUFBQztZQUFHO1lBQUc7U0FB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bEI7SUFDUCxLQUFLLFdBQVcsR0FBRXBCLGdEQUFtQixDQUFDLDBCQUEwQjtRQUM5RHlFLE1BQU1BO1FBQ05ZLE9BQU9BO1FBQ1BILFFBQVFBO1FBQ1JFLFFBQVFBO0lBQ1Y7QUFDRjtBQUNBLFNBQVNFLFlBQVlYLEtBQUs7SUFDeEIsT0FBT0EsTUFBTVEsTUFBTSxHQUFHLFdBQVcsR0FBRW5GLGdEQUFtQixDQUFDMEUsbUJBQW1CQyxTQUFTQSxNQUFNckMsR0FBRyxHQUFHLFdBQVcsR0FBRXRDLGdEQUFtQixDQUFDcUMsZ0JBQWdCc0MsU0FBU0EsTUFBTTNCLFFBQVEsR0FBRyxXQUFXLEdBQUVoRCxnREFBbUIsQ0FBQytDLG1CQUFtQjRCLFNBQVMsV0FBVyxHQUFFM0UsZ0RBQW1CLENBQUMwQyxpQkFBaUJpQztBQUMzUjtBQUUyRSIsInNvdXJjZXMiOlsid2VicGFjazovL3JvY2tldHNpbS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL0Vudmlyb25tZW50LmpzPzYwNDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlVGhyZWUsIHVzZUZyYW1lLCBjcmVhdGVQb3J0YWwsIGFwcGx5UHJvcHMsIGV4dGVuZCB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBTY2VuZSwgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0LCBIYWxmRmxvYXRUeXBlIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgR3JvdW5kUHJvamVjdGVkRW52IH0gZnJvbSAndGhyZWUtc3RkbGliJztcbmltcG9ydCB7IHVzZUVudmlyb25tZW50IH0gZnJvbSAnLi91c2VFbnZpcm9ubWVudC5qcyc7XG5cbmNvbnN0IGlzUmVmID0gb2JqID0+IG9iai5jdXJyZW50ICYmIG9iai5jdXJyZW50LmlzU2NlbmU7XG5jb25zdCByZXNvbHZlU2NlbmUgPSBzY2VuZSA9PiBpc1JlZihzY2VuZSkgPyBzY2VuZS5jdXJyZW50IDogc2NlbmU7XG5mdW5jdGlvbiBzZXRFbnZQcm9wcyhiYWNrZ3JvdW5kLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCB0ZXh0dXJlLCBzY2VuZVByb3BzID0ge30pIHtcbiAgdmFyIF90YXJnZXQkYmFja2dyb3VuZFJvdCwgX3RhcmdldCRiYWNrZ3JvdW5kUm90MiwgX3RhcmdldCRlbnZpcm9ubWVudFJvLCBfdGFyZ2V0JGVudmlyb25tZW50Um8yO1xuICAvLyBkZWZhdWx0c1xuICBzY2VuZVByb3BzID0ge1xuICAgIGJhY2tncm91bmRCbHVycmluZXNzOiAwLFxuICAgIGJhY2tncm91bmRJbnRlbnNpdHk6IDEsXG4gICAgYmFja2dyb3VuZFJvdGF0aW9uOiBbMCwgMCwgMF0sXG4gICAgZW52aXJvbm1lbnRJbnRlbnNpdHk6IDEsXG4gICAgZW52aXJvbm1lbnRSb3RhdGlvbjogWzAsIDAsIDBdLFxuICAgIC4uLnNjZW5lUHJvcHNcbiAgfTtcbiAgY29uc3QgdGFyZ2V0ID0gcmVzb2x2ZVNjZW5lKHNjZW5lIHx8IGRlZmF1bHRTY2VuZSk7XG4gIGNvbnN0IG9sZGJnID0gdGFyZ2V0LmJhY2tncm91bmQ7XG4gIGNvbnN0IG9sZGVudiA9IHRhcmdldC5lbnZpcm9ubWVudDtcbiAgY29uc3Qgb2xkU2NlbmVQcm9wcyA9IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYmFja2dyb3VuZEJsdXJyaW5lc3M6IHRhcmdldC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYmFja2dyb3VuZEludGVuc2l0eTogdGFyZ2V0LmJhY2tncm91bmRJbnRlbnNpdHksXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGJhY2tncm91bmRSb3RhdGlvbjogKF90YXJnZXQkYmFja2dyb3VuZFJvdCA9IChfdGFyZ2V0JGJhY2tncm91bmRSb3QyID0gdGFyZ2V0LmJhY2tncm91bmRSb3RhdGlvbikgPT0gbnVsbCB8fCBfdGFyZ2V0JGJhY2tncm91bmRSb3QyLmNsb25lID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0JGJhY2tncm91bmRSb3QyLmNsb25lKCkpICE9PSBudWxsICYmIF90YXJnZXQkYmFja2dyb3VuZFJvdCAhPT0gdm9pZCAwID8gX3RhcmdldCRiYWNrZ3JvdW5kUm90IDogWzAsIDAsIDBdLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBlbnZpcm9ubWVudEludGVuc2l0eTogdGFyZ2V0LmVudmlyb25tZW50SW50ZW5zaXR5LFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBlbnZpcm9ubWVudFJvdGF0aW9uOiAoX3RhcmdldCRlbnZpcm9ubWVudFJvID0gKF90YXJnZXQkZW52aXJvbm1lbnRSbzIgPSB0YXJnZXQuZW52aXJvbm1lbnRSb3RhdGlvbikgPT0gbnVsbCB8fCBfdGFyZ2V0JGVudmlyb25tZW50Um8yLmNsb25lID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0JGVudmlyb25tZW50Um8yLmNsb25lKCkpICE9PSBudWxsICYmIF90YXJnZXQkZW52aXJvbm1lbnRSbyAhPT0gdm9pZCAwID8gX3RhcmdldCRlbnZpcm9ubWVudFJvIDogWzAsIDAsIDBdXG4gIH07XG4gIGlmIChiYWNrZ3JvdW5kICE9PSAnb25seScpIHRhcmdldC5lbnZpcm9ubWVudCA9IHRleHR1cmU7XG4gIGlmIChiYWNrZ3JvdW5kKSB0YXJnZXQuYmFja2dyb3VuZCA9IHRleHR1cmU7XG4gIGFwcGx5UHJvcHModGFyZ2V0LCBzY2VuZVByb3BzKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoYmFja2dyb3VuZCAhPT0gJ29ubHknKSB0YXJnZXQuZW52aXJvbm1lbnQgPSBvbGRlbnY7XG4gICAgaWYgKGJhY2tncm91bmQpIHRhcmdldC5iYWNrZ3JvdW5kID0gb2xkYmc7XG4gICAgYXBwbHlQcm9wcyh0YXJnZXQsIG9sZFNjZW5lUHJvcHMpO1xuICB9O1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnRNYXAoe1xuICBzY2VuZSxcbiAgYmFja2dyb3VuZCA9IGZhbHNlLFxuICBtYXAsXG4gIC4uLmNvbmZpZ1xufSkge1xuICBjb25zdCBkZWZhdWx0U2NlbmUgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5zY2VuZSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1hcCkgcmV0dXJuIHNldEVudlByb3BzKGJhY2tncm91bmQsIHNjZW5lLCBkZWZhdWx0U2NlbmUsIG1hcCwgY29uZmlnKTtcbiAgfSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnRDdWJlKHtcbiAgYmFja2dyb3VuZCA9IGZhbHNlLFxuICBzY2VuZSxcbiAgYmx1cixcbiAgYmFja2dyb3VuZEJsdXJyaW5lc3MsXG4gIGJhY2tncm91bmRJbnRlbnNpdHksXG4gIGJhY2tncm91bmRSb3RhdGlvbixcbiAgZW52aXJvbm1lbnRJbnRlbnNpdHksXG4gIGVudmlyb25tZW50Um90YXRpb24sXG4gIC4uLnJlc3Rcbn0pIHtcbiAgY29uc3QgdGV4dHVyZSA9IHVzZUVudmlyb25tZW50KHJlc3QpO1xuICBjb25zdCBkZWZhdWx0U2NlbmUgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5zY2VuZSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHNldEVudlByb3BzKGJhY2tncm91bmQsIHNjZW5lLCBkZWZhdWx0U2NlbmUsIHRleHR1cmUsIHtcbiAgICAgIGJhY2tncm91bmRCbHVycmluZXNzOiBibHVyICE9PSBudWxsICYmIGJsdXIgIT09IHZvaWQgMCA/IGJsdXIgOiBiYWNrZ3JvdW5kQmx1cnJpbmVzcyxcbiAgICAgIGJhY2tncm91bmRJbnRlbnNpdHksXG4gICAgICBiYWNrZ3JvdW5kUm90YXRpb24sXG4gICAgICBlbnZpcm9ubWVudEludGVuc2l0eSxcbiAgICAgIGVudmlyb25tZW50Um90YXRpb25cbiAgICB9KTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRleHR1cmUuZGlzcG9zZSgpO1xuICAgIH07XG4gIH0sIFt0ZXh0dXJlXSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnRQb3J0YWwoe1xuICBjaGlsZHJlbixcbiAgbmVhciA9IDAuMSxcbiAgZmFyID0gMTAwMCxcbiAgcmVzb2x1dGlvbiA9IDI1NixcbiAgZnJhbWVzID0gMSxcbiAgbWFwLFxuICBiYWNrZ3JvdW5kID0gZmFsc2UsXG4gIGJsdXIsXG4gIGJhY2tncm91bmRCbHVycmluZXNzLFxuICBiYWNrZ3JvdW5kSW50ZW5zaXR5LFxuICBiYWNrZ3JvdW5kUm90YXRpb24sXG4gIGVudmlyb25tZW50SW50ZW5zaXR5LFxuICBlbnZpcm9ubWVudFJvdGF0aW9uLFxuICBzY2VuZSxcbiAgZmlsZXMsXG4gIHBhdGgsXG4gIHByZXNldCA9IHVuZGVmaW5lZCxcbiAgZXh0ZW5zaW9uc1xufSkge1xuICBjb25zdCBnbCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmdsKTtcbiAgY29uc3QgZGVmYXVsdFNjZW5lID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2NlbmUpO1xuICBjb25zdCBjYW1lcmEgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IFt2aXJ0dWFsU2NlbmVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFNjZW5lKCkpO1xuICBjb25zdCBmYm8gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBmYm8gPSBuZXcgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KHJlc29sdXRpb24pO1xuICAgIGZiby50ZXh0dXJlLnR5cGUgPSBIYWxmRmxvYXRUeXBlO1xuICAgIHJldHVybiBmYm87XG4gIH0sIFtyZXNvbHV0aW9uXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZiby5kaXNwb3NlKCk7XG4gICAgfTtcbiAgfSwgW2Zib10pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChmcmFtZXMgPT09IDEpIHtcbiAgICAgIGNvbnN0IGF1dG9DbGVhciA9IGdsLmF1dG9DbGVhcjtcbiAgICAgIGdsLmF1dG9DbGVhciA9IHRydWU7XG4gICAgICBjYW1lcmEuY3VycmVudC51cGRhdGUoZ2wsIHZpcnR1YWxTY2VuZSk7XG4gICAgICBnbC5hdXRvQ2xlYXIgPSBhdXRvQ2xlYXI7XG4gICAgfVxuICAgIHJldHVybiBzZXRFbnZQcm9wcyhiYWNrZ3JvdW5kLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCBmYm8udGV4dHVyZSwge1xuICAgICAgYmFja2dyb3VuZEJsdXJyaW5lc3M6IGJsdXIgIT09IG51bGwgJiYgYmx1ciAhPT0gdm9pZCAwID8gYmx1ciA6IGJhY2tncm91bmRCbHVycmluZXNzLFxuICAgICAgYmFja2dyb3VuZEludGVuc2l0eSxcbiAgICAgIGJhY2tncm91bmRSb3RhdGlvbixcbiAgICAgIGVudmlyb25tZW50SW50ZW5zaXR5LFxuICAgICAgZW52aXJvbm1lbnRSb3RhdGlvblxuICAgIH0pO1xuICB9LCBbY2hpbGRyZW4sIHZpcnR1YWxTY2VuZSwgZmJvLnRleHR1cmUsIHNjZW5lLCBkZWZhdWx0U2NlbmUsIGJhY2tncm91bmQsIGZyYW1lcywgZ2xdKTtcbiAgbGV0IGNvdW50ID0gMTtcbiAgdXNlRnJhbWUoKCkgPT4ge1xuICAgIGlmIChmcmFtZXMgPT09IEluZmluaXR5IHx8IGNvdW50IDwgZnJhbWVzKSB7XG4gICAgICBjb25zdCBhdXRvQ2xlYXIgPSBnbC5hdXRvQ2xlYXI7XG4gICAgICBnbC5hdXRvQ2xlYXIgPSB0cnVlO1xuICAgICAgY2FtZXJhLmN1cnJlbnQudXBkYXRlKGdsLCB2aXJ0dWFsU2NlbmUpO1xuICAgICAgZ2wuYXV0b0NsZWFyID0gYXV0b0NsZWFyO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNyZWF0ZVBvcnRhbCgvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY3ViZUNhbWVyYVwiLCB7XG4gICAgcmVmOiBjYW1lcmEsXG4gICAgYXJnczogW25lYXIsIGZhciwgZmJvXVxuICB9KSwgZmlsZXMgfHwgcHJlc2V0ID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRDdWJlLCB7XG4gICAgYmFja2dyb3VuZDogdHJ1ZSxcbiAgICBmaWxlczogZmlsZXMsXG4gICAgcHJlc2V0OiBwcmVzZXQsXG4gICAgcGF0aDogcGF0aCxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zXG4gIH0pIDogbWFwID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRNYXAsIHtcbiAgICBiYWNrZ3JvdW5kOiB0cnVlLFxuICAgIG1hcDogbWFwLFxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnNcbiAgfSkgOiBudWxsKSwgdmlydHVhbFNjZW5lKSk7XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudEdyb3VuZChwcm9wcykge1xuICB2YXIgX3Byb3BzJGdyb3VuZCwgX3Byb3BzJGdyb3VuZDIsIF9zY2FsZSwgX3Byb3BzJGdyb3VuZDM7XG4gIGNvbnN0IHRleHR1cmVEZWZhdWx0ID0gdXNlRW52aXJvbm1lbnQocHJvcHMpO1xuICBjb25zdCB0ZXh0dXJlID0gcHJvcHMubWFwIHx8IHRleHR1cmVEZWZhdWx0O1xuICBSZWFjdC51c2VNZW1vKCgpID0+IGV4dGVuZCh7XG4gICAgR3JvdW5kUHJvamVjdGVkRW52SW1wbDogR3JvdW5kUHJvamVjdGVkRW52XG4gIH0pLCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRleHR1cmVEZWZhdWx0LmRpc3Bvc2UoKTtcbiAgICB9O1xuICB9LCBbdGV4dHVyZURlZmF1bHRdKTtcbiAgY29uc3QgYXJncyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gW3RleHR1cmVdLCBbdGV4dHVyZV0pO1xuICBjb25zdCBoZWlnaHQgPSAoX3Byb3BzJGdyb3VuZCA9IHByb3BzLmdyb3VuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRncm91bmQuaGVpZ2h0O1xuICBjb25zdCByYWRpdXMgPSAoX3Byb3BzJGdyb3VuZDIgPSBwcm9wcy5ncm91bmQpID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkZ3JvdW5kMi5yYWRpdXM7XG4gIGNvbnN0IHNjYWxlID0gKF9zY2FsZSA9IChfcHJvcHMkZ3JvdW5kMyA9IHByb3BzLmdyb3VuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRncm91bmQzLnNjYWxlKSAhPT0gbnVsbCAmJiBfc2NhbGUgIT09IHZvaWQgMCA/IF9zY2FsZSA6IDEwMDA7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRNYXAsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIG1hcDogdGV4dHVyZVxuICB9KSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdW5kUHJvamVjdGVkRW52SW1wbFwiLCB7XG4gICAgYXJnczogYXJncyxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgcmFkaXVzOiByYWRpdXNcbiAgfSkpO1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnQocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLmdyb3VuZCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50R3JvdW5kLCBwcm9wcykgOiBwcm9wcy5tYXAgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudE1hcCwgcHJvcHMpIDogcHJvcHMuY2hpbGRyZW4gPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudFBvcnRhbCwgcHJvcHMpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRDdWJlLCBwcm9wcyk7XG59XG5cbmV4cG9ydCB7IEVudmlyb25tZW50LCBFbnZpcm9ubWVudEN1YmUsIEVudmlyb25tZW50TWFwLCBFbnZpcm9ubWVudFBvcnRhbCB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiUmVhY3QiLCJ1c2VUaHJlZSIsInVzZUZyYW1lIiwiY3JlYXRlUG9ydGFsIiwiYXBwbHlQcm9wcyIsImV4dGVuZCIsIlNjZW5lIiwiV2ViR0xDdWJlUmVuZGVyVGFyZ2V0IiwiSGFsZkZsb2F0VHlwZSIsIkdyb3VuZFByb2plY3RlZEVudiIsInVzZUVudmlyb25tZW50IiwiaXNSZWYiLCJvYmoiLCJjdXJyZW50IiwiaXNTY2VuZSIsInJlc29sdmVTY2VuZSIsInNjZW5lIiwic2V0RW52UHJvcHMiLCJiYWNrZ3JvdW5kIiwiZGVmYXVsdFNjZW5lIiwidGV4dHVyZSIsInNjZW5lUHJvcHMiLCJfdGFyZ2V0JGJhY2tncm91bmRSb3QiLCJfdGFyZ2V0JGJhY2tncm91bmRSb3QyIiwiX3RhcmdldCRlbnZpcm9ubWVudFJvIiwiX3RhcmdldCRlbnZpcm9ubWVudFJvMiIsImJhY2tncm91bmRCbHVycmluZXNzIiwiYmFja2dyb3VuZEludGVuc2l0eSIsImJhY2tncm91bmRSb3RhdGlvbiIsImVudmlyb25tZW50SW50ZW5zaXR5IiwiZW52aXJvbm1lbnRSb3RhdGlvbiIsInRhcmdldCIsIm9sZGJnIiwib2xkZW52IiwiZW52aXJvbm1lbnQiLCJvbGRTY2VuZVByb3BzIiwiY2xvbmUiLCJFbnZpcm9ubWVudE1hcCIsIm1hcCIsImNvbmZpZyIsInN0YXRlIiwidXNlTGF5b3V0RWZmZWN0IiwiRW52aXJvbm1lbnRDdWJlIiwiYmx1ciIsInJlc3QiLCJ1c2VFZmZlY3QiLCJkaXNwb3NlIiwiRW52aXJvbm1lbnRQb3J0YWwiLCJjaGlsZHJlbiIsIm5lYXIiLCJmYXIiLCJyZXNvbHV0aW9uIiwiZnJhbWVzIiwiZmlsZXMiLCJwYXRoIiwicHJlc2V0IiwidW5kZWZpbmVkIiwiZXh0ZW5zaW9ucyIsImdsIiwiY2FtZXJhIiwidXNlUmVmIiwidmlydHVhbFNjZW5lIiwidXNlU3RhdGUiLCJmYm8iLCJ1c2VNZW1vIiwidHlwZSIsImF1dG9DbGVhciIsInVwZGF0ZSIsImNvdW50IiwiSW5maW5pdHkiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJyZWYiLCJhcmdzIiwiRW52aXJvbm1lbnRHcm91bmQiLCJwcm9wcyIsIl9wcm9wcyRncm91bmQiLCJfcHJvcHMkZ3JvdW5kMiIsIl9zY2FsZSIsIl9wcm9wcyRncm91bmQzIiwidGV4dHVyZURlZmF1bHQiLCJHcm91bmRQcm9qZWN0ZWRFbnZJbXBsIiwiaGVpZ2h0IiwiZ3JvdW5kIiwicmFkaXVzIiwic2NhbGUiLCJFbnZpcm9ubWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Environment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Fbo.js":
/*!****************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Fbo.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fbo: () => (/* binding */ Fbo),\n/* harmony export */   useFBO: () => (/* binding */ useFBO)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n\n\n\n// TODO: consume this from three >r154 when SemVer allows\n// 👇 uncomment when TS version supports function overloads\n// export function useFBO(settings?: FBOSettings)\nfunction useFBO(/** Width in pixels, or settings (will render fullscreen by default) */ width, /** Height in pixels */ height, /**Settings */ settings) {\n    const size = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.A)((state)=>state.size);\n    const viewport = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.A)((state)=>state.viewport);\n    const _width = typeof width === \"number\" ? width : size.width * viewport.dpr;\n    const _height = typeof height === \"number\" ? height : size.height * viewport.dpr;\n    const _settings = (typeof width === \"number\" ? settings : width) || {};\n    const { samples = 0, depth, ...targetSettings } = _settings;\n    const target = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        const target = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderTarget(_width, _height, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_2__.LinearFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_2__.LinearFilter,\n            type: three__WEBPACK_IMPORTED_MODULE_2__.HalfFloatType,\n            ...targetSettings\n        });\n        if (depth) {\n            target.depthTexture = new three__WEBPACK_IMPORTED_MODULE_2__.DepthTexture(_width, _height, three__WEBPACK_IMPORTED_MODULE_2__.FloatType);\n        }\n        target.samples = samples;\n        return target;\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n        target.setSize(_width, _height);\n        if (samples) target.samples = samples;\n    }, [\n        samples,\n        target,\n        _width,\n        _height\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>target.dispose();\n    }, []);\n    return target;\n}\nconst Fbo = ({ children, width, height, ...settings })=>{\n    const target = useFBO(width, height, settings);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children == null ? void 0 : children(target));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9GYm8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStCO0FBQ0E7QUFDZTtBQUU5Qyx5REFBeUQ7QUFFekQsMkRBQTJEO0FBQzNELGlEQUFpRDtBQUNqRCxTQUFTRyxPQUFPLHFFQUFxRSxHQUNyRkMsS0FBSyxFQUFFLHFCQUFxQixHQUM1QkMsTUFBTSxFQUFFLFlBQVksR0FDcEJDLFFBQVE7SUFDTixNQUFNQyxPQUFPTCxxREFBUUEsQ0FBQ00sQ0FBQUEsUUFBU0EsTUFBTUQsSUFBSTtJQUN6QyxNQUFNRSxXQUFXUCxxREFBUUEsQ0FBQ00sQ0FBQUEsUUFBU0EsTUFBTUMsUUFBUTtJQUNqRCxNQUFNQyxTQUFTLE9BQU9OLFVBQVUsV0FBV0EsUUFBUUcsS0FBS0gsS0FBSyxHQUFHSyxTQUFTRSxHQUFHO0lBQzVFLE1BQU1DLFVBQVUsT0FBT1AsV0FBVyxXQUFXQSxTQUFTRSxLQUFLRixNQUFNLEdBQUdJLFNBQVNFLEdBQUc7SUFDaEYsTUFBTUUsWUFBWSxDQUFDLE9BQU9ULFVBQVUsV0FBV0UsV0FBV0YsS0FBSSxLQUFNLENBQUM7SUFDckUsTUFBTSxFQUNKVSxVQUFVLENBQUMsRUFDWEMsS0FBSyxFQUNMLEdBQUdDLGdCQUNKLEdBQUdIO0lBQ0osTUFBTUksU0FBU2pCLDBDQUFhLENBQUM7UUFDM0IsTUFBTWlCLFNBQVMsSUFBSWhCLG9EQUF1QixDQUFDUyxRQUFRRSxTQUFTO1lBQzFEUSxXQUFXbkIsK0NBQWtCO1lBQzdCcUIsV0FBV3JCLCtDQUFrQjtZQUM3QnNCLE1BQU10QixnREFBbUI7WUFDekIsR0FBR2UsY0FBYztRQUNuQjtRQUNBLElBQUlELE9BQU87WUFDVEUsT0FBT1EsWUFBWSxHQUFHLElBQUl4QiwrQ0FBa0IsQ0FBQ1MsUUFBUUUsU0FBU1gsNENBQWU7UUFDL0U7UUFDQWdCLE9BQU9ILE9BQU8sR0FBR0E7UUFDakIsT0FBT0c7SUFDVCxHQUFHLEVBQUU7SUFDTGpCLGtEQUFxQixDQUFDO1FBQ3BCaUIsT0FBT1ksT0FBTyxDQUFDbkIsUUFBUUU7UUFDdkIsSUFBSUUsU0FBU0csT0FBT0gsT0FBTyxHQUFHQTtJQUNoQyxHQUFHO1FBQUNBO1FBQVNHO1FBQVFQO1FBQVFFO0tBQVE7SUFDckNaLDRDQUFlLENBQUM7UUFDZCxPQUFPLElBQU1pQixPQUFPYyxPQUFPO0lBQzdCLEdBQUcsRUFBRTtJQUNMLE9BQU9kO0FBQ1Q7QUFDQSxNQUFNZSxNQUFNLENBQUMsRUFDWEMsUUFBUSxFQUNSN0IsS0FBSyxFQUNMQyxNQUFNLEVBQ04sR0FBR0MsVUFDSjtJQUNDLE1BQU1XLFNBQVNkLE9BQU9DLE9BQU9DLFFBQVFDO0lBQ3JDLE9BQU8sV0FBVyxHQUFFTixnREFBbUIsQ0FBQ0EsMkNBQWMsRUFBRSxNQUFNaUMsWUFBWSxPQUFPLEtBQUssSUFBSUEsU0FBU2hCO0FBQ3JHO0FBRXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm9ja2V0c2ltLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvRmJvLmpzPzVlYjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgdXNlVGhyZWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuXG4vLyBUT0RPOiBjb25zdW1lIHRoaXMgZnJvbSB0aHJlZSA+cjE1NCB3aGVuIFNlbVZlciBhbGxvd3NcblxuLy8g8J+RhyB1bmNvbW1lbnQgd2hlbiBUUyB2ZXJzaW9uIHN1cHBvcnRzIGZ1bmN0aW9uIG92ZXJsb2Fkc1xuLy8gZXhwb3J0IGZ1bmN0aW9uIHVzZUZCTyhzZXR0aW5ncz86IEZCT1NldHRpbmdzKVxuZnVuY3Rpb24gdXNlRkJPKC8qKiBXaWR0aCBpbiBwaXhlbHMsIG9yIHNldHRpbmdzICh3aWxsIHJlbmRlciBmdWxsc2NyZWVuIGJ5IGRlZmF1bHQpICovXG53aWR0aCwgLyoqIEhlaWdodCBpbiBwaXhlbHMgKi9cbmhlaWdodCwgLyoqU2V0dGluZ3MgKi9cbnNldHRpbmdzKSB7XG4gIGNvbnN0IHNpemUgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5zaXplKTtcbiAgY29uc3Qgdmlld3BvcnQgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS52aWV3cG9ydCk7XG4gIGNvbnN0IF93aWR0aCA9IHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgPyB3aWR0aCA6IHNpemUud2lkdGggKiB2aWV3cG9ydC5kcHI7XG4gIGNvbnN0IF9oZWlnaHQgPSB0eXBlb2YgaGVpZ2h0ID09PSAnbnVtYmVyJyA/IGhlaWdodCA6IHNpemUuaGVpZ2h0ICogdmlld3BvcnQuZHByO1xuICBjb25zdCBfc2V0dGluZ3MgPSAodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyA/IHNldHRpbmdzIDogd2lkdGgpIHx8IHt9O1xuICBjb25zdCB7XG4gICAgc2FtcGxlcyA9IDAsXG4gICAgZGVwdGgsXG4gICAgLi4udGFyZ2V0U2V0dGluZ3NcbiAgfSA9IF9zZXR0aW5ncztcbiAgY29uc3QgdGFyZ2V0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KF93aWR0aCwgX2hlaWdodCwge1xuICAgICAgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsXG4gICAgICBtYWdGaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlcixcbiAgICAgIHR5cGU6IFRIUkVFLkhhbGZGbG9hdFR5cGUsXG4gICAgICAuLi50YXJnZXRTZXR0aW5nc1xuICAgIH0pO1xuICAgIGlmIChkZXB0aCkge1xuICAgICAgdGFyZ2V0LmRlcHRoVGV4dHVyZSA9IG5ldyBUSFJFRS5EZXB0aFRleHR1cmUoX3dpZHRoLCBfaGVpZ2h0LCBUSFJFRS5GbG9hdFR5cGUpO1xuICAgIH1cbiAgICB0YXJnZXQuc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSwgW10pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHRhcmdldC5zZXRTaXplKF93aWR0aCwgX2hlaWdodCk7XG4gICAgaWYgKHNhbXBsZXMpIHRhcmdldC5zYW1wbGVzID0gc2FtcGxlcztcbiAgfSwgW3NhbXBsZXMsIHRhcmdldCwgX3dpZHRoLCBfaGVpZ2h0XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHRhcmdldC5kaXNwb3NlKCk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbmNvbnN0IEZibyA9ICh7XG4gIGNoaWxkcmVuLFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICAuLi5zZXR0aW5nc1xufSkgPT4ge1xuICBjb25zdCB0YXJnZXQgPSB1c2VGQk8od2lkdGgsIGhlaWdodCwgc2V0dGluZ3MpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZHJlbih0YXJnZXQpKTtcbn07XG5cbmV4cG9ydCB7IEZibywgdXNlRkJPIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJUSFJFRSIsInVzZVRocmVlIiwidXNlRkJPIiwid2lkdGgiLCJoZWlnaHQiLCJzZXR0aW5ncyIsInNpemUiLCJzdGF0ZSIsInZpZXdwb3J0IiwiX3dpZHRoIiwiZHByIiwiX2hlaWdodCIsIl9zZXR0aW5ncyIsInNhbXBsZXMiLCJkZXB0aCIsInRhcmdldFNldHRpbmdzIiwidGFyZ2V0IiwidXNlTWVtbyIsIldlYkdMUmVuZGVyVGFyZ2V0IiwibWluRmlsdGVyIiwiTGluZWFyRmlsdGVyIiwibWFnRmlsdGVyIiwidHlwZSIsIkhhbGZGbG9hdFR5cGUiLCJkZXB0aFRleHR1cmUiLCJEZXB0aFRleHR1cmUiLCJGbG9hdFR5cGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJzZXRTaXplIiwidXNlRWZmZWN0IiwiZGlzcG9zZSIsIkZibyIsImNoaWxkcmVuIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Fbo.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Grid.js":
/*!*****************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Grid.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Grid: () => (/* binding */ Grid)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n/* harmony import */ var _shaderMaterial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shaderMaterial.js */ \"(ssr)/./node_modules/@react-three/drei/core/shaderMaterial.js\");\n/* harmony import */ var _helpers_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/constants.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/constants.js\");\n\n\n\n\n\n\nconst GridMaterial = /* @__PURE__ */ (0,_shaderMaterial_js__WEBPACK_IMPORTED_MODULE_2__.shaderMaterial)({\n    cellSize: 0.5,\n    sectionSize: 1,\n    fadeDistance: 100,\n    fadeStrength: 1,\n    fadeFrom: 1,\n    cellThickness: 0.5,\n    sectionThickness: 1,\n    cellColor: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_3__.Color(),\n    sectionColor: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_3__.Color(),\n    infiniteGrid: false,\n    followCamera: false,\n    worldCamProjPosition: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(),\n    worldPlanePosition: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3()\n}, /* glsl */ `\n    varying vec3 localPosition;\n    varying vec4 worldPosition;\n\n    uniform vec3 worldCamProjPosition;\n    uniform vec3 worldPlanePosition;\n    uniform float fadeDistance;\n    uniform bool infiniteGrid;\n    uniform bool followCamera;\n\n    void main() {\n      localPosition = position.xzy;\n      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;\n      \n      worldPosition = modelMatrix * vec4(localPosition, 1.0);\n      if (followCamera) {\n        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);\n        localPosition = (inverse(modelMatrix) * worldPosition).xyz;\n      }\n\n      gl_Position = projectionMatrix * viewMatrix * worldPosition;\n    }\n  `, /* glsl */ `\n    varying vec3 localPosition;\n    varying vec4 worldPosition;\n\n    uniform vec3 worldCamProjPosition;\n    uniform float cellSize;\n    uniform float sectionSize;\n    uniform vec3 cellColor;\n    uniform vec3 sectionColor;\n    uniform float fadeDistance;\n    uniform float fadeStrength;\n    uniform float fadeFrom;\n    uniform float cellThickness;\n    uniform float sectionThickness;\n\n    float getGrid(float size, float thickness) {\n      vec2 r = localPosition.xz / size;\n      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n      float line = min(grid.x, grid.y) + 1.0 - thickness;\n      return 1.0 - min(line, 1.0);\n    }\n\n    void main() {\n      float g1 = getGrid(cellSize, cellThickness);\n      float g2 = getGrid(sectionSize, sectionThickness);\n\n      vec3 from = worldCamProjPosition*vec3(fadeFrom);\n      float dist = distance(from, worldPosition.xyz);\n      float d = 1.0 - min(dist / fadeDistance, 1.0);\n      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));\n\n      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));\n      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\n      if (gl_FragColor.a <= 0.0) discard;\n\n      #include <tonemapping_fragment>\n      #include <${_helpers_constants_js__WEBPACK_IMPORTED_MODULE_4__.version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n    }\n  `);\nconst Grid = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ args, cellColor = \"#000000\", sectionColor = \"#2080ff\", cellSize = 0.5, sectionSize = 1, followCamera = false, infiniteGrid = false, fadeDistance = 100, fadeStrength = 1, fadeFrom = 1, cellThickness = 0.5, sectionThickness = 1, side = three__WEBPACK_IMPORTED_MODULE_3__.BackSide, ...props }, fRef)=>{\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.e)({\n        GridMaterial\n    });\n    const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(fRef, ()=>ref.current, []);\n    const plane = new three__WEBPACK_IMPORTED_MODULE_3__.Plane();\n    const upVector = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 1, 0);\n    const zeroVector = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.C)((state)=>{\n        plane.setFromNormalAndCoplanarPoint(upVector, zeroVector).applyMatrix4(ref.current.matrixWorld);\n        const gridMaterial = ref.current.material;\n        const worldCamProjPosition = gridMaterial.uniforms.worldCamProjPosition;\n        const worldPlanePosition = gridMaterial.uniforms.worldPlanePosition;\n        plane.projectPoint(state.camera.position, worldCamProjPosition.value);\n        worldPlanePosition.value.set(0, 0, 0).applyMatrix4(ref.current.matrixWorld);\n    });\n    const uniforms1 = {\n        cellSize,\n        sectionSize,\n        cellColor,\n        sectionColor,\n        cellThickness,\n        sectionThickness\n    };\n    const uniforms2 = {\n        fadeDistance,\n        fadeStrength,\n        fadeFrom,\n        infiniteGrid,\n        followCamera\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: ref,\n        frustumCulled: false\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"gridMaterial\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        transparent: true,\n        \"extensions-derivatives\": true,\n        side: side\n    }, uniforms1, uniforms2)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"planeGeometry\", {\n        args: args\n    }));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9HcmlkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzNCO0FBQ0E7QUFDdUI7QUFDRDtBQUNIO0FBRWxELE1BQU1PLGVBQWUsYUFBYSxHQUFFRixrRUFBY0EsQ0FBQztJQUNqREcsVUFBVTtJQUNWQyxhQUFhO0lBQ2JDLGNBQWM7SUFDZEMsY0FBYztJQUNkQyxVQUFVO0lBQ1ZDLGVBQWU7SUFDZkMsa0JBQWtCO0lBQ2xCQyxXQUFXLGFBQWEsR0FBRSxJQUFJYix3Q0FBVztJQUN6Q2UsY0FBYyxhQUFhLEdBQUUsSUFBSWYsd0NBQVc7SUFDNUNnQixjQUFjO0lBQ2RDLGNBQWM7SUFDZEMsc0JBQXNCLGFBQWEsR0FBRSxJQUFJbEIsMENBQWE7SUFDdERvQixvQkFBb0IsYUFBYSxHQUFFLElBQUlwQiwwQ0FBYTtBQUN0RCxHQUFHLFFBQVEsR0FBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBc0JaLENBQUMsRUFBRSxRQUFRLEdBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQW9DQSxFQUFFSSwwREFBT0EsSUFBSSxNQUFNLHdCQUF3QixxQkFBcUI7O0VBRTlFLENBQUM7QUFDSCxNQUFNaUIsT0FBTyxhQUFhLGlCQUFFdEIsNkNBQWdCLENBQUMsQ0FBQyxFQUM1Q3dCLElBQUksRUFDSlYsWUFBWSxTQUFTLEVBQ3JCRSxlQUFlLFNBQVMsRUFDeEJULFdBQVcsR0FBRyxFQUNkQyxjQUFjLENBQUMsRUFDZlUsZUFBZSxLQUFLLEVBQ3BCRCxlQUFlLEtBQUssRUFDcEJSLGVBQWUsR0FBRyxFQUNsQkMsZUFBZSxDQUFDLEVBQ2hCQyxXQUFXLENBQUMsRUFDWkMsZ0JBQWdCLEdBQUcsRUFDbkJDLG1CQUFtQixDQUFDLEVBQ3BCWSxPQUFPeEIsMkNBQWMsRUFDckIsR0FBRzBCLE9BQ0osRUFBRUM7SUFDRDFCLHFEQUFNQSxDQUFDO1FBQ0xJO0lBQ0Y7SUFDQSxNQUFNdUIsTUFBTTdCLHlDQUFZLENBQUM7SUFDekJBLHNEQUF5QixDQUFDNEIsTUFBTSxJQUFNQyxJQUFJRyxPQUFPLEVBQUUsRUFBRTtJQUNyRCxNQUFNQyxRQUFRLElBQUloQyx3Q0FBVztJQUM3QixNQUFNa0MsV0FBVyxJQUFJbEMsMENBQWEsQ0FBQyxHQUFHLEdBQUc7SUFDekMsTUFBTW1DLGFBQWEsSUFBSW5DLDBDQUFhLENBQUMsR0FBRyxHQUFHO0lBQzNDRSxxREFBUUEsQ0FBQ2tDLENBQUFBO1FBQ1BKLE1BQU1LLDZCQUE2QixDQUFDSCxVQUFVQyxZQUFZRyxZQUFZLENBQUNWLElBQUlHLE9BQU8sQ0FBQ1EsV0FBVztRQUM5RixNQUFNQyxlQUFlWixJQUFJRyxPQUFPLENBQUNVLFFBQVE7UUFDekMsTUFBTXZCLHVCQUF1QnNCLGFBQWFFLFFBQVEsQ0FBQ3hCLG9CQUFvQjtRQUN2RSxNQUFNRSxxQkFBcUJvQixhQUFhRSxRQUFRLENBQUN0QixrQkFBa0I7UUFDbkVZLE1BQU1XLFlBQVksQ0FBQ1AsTUFBTVEsTUFBTSxDQUFDQyxRQUFRLEVBQUUzQixxQkFBcUI0QixLQUFLO1FBQ3BFMUIsbUJBQW1CMEIsS0FBSyxDQUFDQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUdULFlBQVksQ0FBQ1YsSUFBSUcsT0FBTyxDQUFDUSxXQUFXO0lBQzVFO0lBQ0EsTUFBTVMsWUFBWTtRQUNoQjFDO1FBQ0FDO1FBQ0FNO1FBQ0FFO1FBQ0FKO1FBQ0FDO0lBQ0Y7SUFDQSxNQUFNcUMsWUFBWTtRQUNoQnpDO1FBQ0FDO1FBQ0FDO1FBQ0FNO1FBQ0FDO0lBQ0Y7SUFDQSxPQUFPLFdBQVcsR0FBRWxCLGdEQUFtQixDQUFDLFFBQVFELDhFQUFRQSxDQUFDO1FBQ3ZEOEIsS0FBS0E7UUFDTHVCLGVBQWU7SUFDakIsR0FBR3pCLFFBQVEsV0FBVyxHQUFFM0IsZ0RBQW1CLENBQUMsZ0JBQWdCRCw4RUFBUUEsQ0FBQztRQUNuRXNELGFBQWE7UUFDYiwwQkFBMEI7UUFDMUI1QixNQUFNQTtJQUNSLEdBQUd3QixXQUFXQyxhQUFhLFdBQVcsR0FBRWxELGdEQUFtQixDQUFDLGlCQUFpQjtRQUMzRXdCLE1BQU1BO0lBQ1I7QUFDRjtBQUVnQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JvY2tldHNpbS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL0dyaWQuanM/MmVmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBleHRlbmQsIHVzZUZyYW1lIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCB7IHNoYWRlck1hdGVyaWFsIH0gZnJvbSAnLi9zaGFkZXJNYXRlcmlhbC5qcyc7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vaGVscGVycy9jb25zdGFudHMuanMnO1xuXG5jb25zdCBHcmlkTWF0ZXJpYWwgPSAvKiBAX19QVVJFX18gKi9zaGFkZXJNYXRlcmlhbCh7XG4gIGNlbGxTaXplOiAwLjUsXG4gIHNlY3Rpb25TaXplOiAxLFxuICBmYWRlRGlzdGFuY2U6IDEwMCxcbiAgZmFkZVN0cmVuZ3RoOiAxLFxuICBmYWRlRnJvbTogMSxcbiAgY2VsbFRoaWNrbmVzczogMC41LFxuICBzZWN0aW9uVGhpY2tuZXNzOiAxLFxuICBjZWxsQ29sb3I6IC8qIEBfX1BVUkVfXyAqL25ldyBUSFJFRS5Db2xvcigpLFxuICBzZWN0aW9uQ29sb3I6IC8qIEBfX1BVUkVfXyAqL25ldyBUSFJFRS5Db2xvcigpLFxuICBpbmZpbml0ZUdyaWQ6IGZhbHNlLFxuICBmb2xsb3dDYW1lcmE6IGZhbHNlLFxuICB3b3JsZENhbVByb2pQb3NpdGlvbjogLyogQF9fUFVSRV9fICovbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgd29ybGRQbGFuZVBvc2l0aW9uOiAvKiBAX19QVVJFX18gKi9uZXcgVEhSRUUuVmVjdG9yMygpXG59LCAvKiBnbHNsICovYFxuICAgIHZhcnlpbmcgdmVjMyBsb2NhbFBvc2l0aW9uO1xuICAgIHZhcnlpbmcgdmVjNCB3b3JsZFBvc2l0aW9uO1xuXG4gICAgdW5pZm9ybSB2ZWMzIHdvcmxkQ2FtUHJvalBvc2l0aW9uO1xuICAgIHVuaWZvcm0gdmVjMyB3b3JsZFBsYW5lUG9zaXRpb247XG4gICAgdW5pZm9ybSBmbG9hdCBmYWRlRGlzdGFuY2U7XG4gICAgdW5pZm9ybSBib29sIGluZmluaXRlR3JpZDtcbiAgICB1bmlmb3JtIGJvb2wgZm9sbG93Q2FtZXJhO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgbG9jYWxQb3NpdGlvbiA9IHBvc2l0aW9uLnh6eTtcbiAgICAgIGlmIChpbmZpbml0ZUdyaWQpIGxvY2FsUG9zaXRpb24gKj0gMS4wICsgZmFkZURpc3RhbmNlO1xuICAgICAgXG4gICAgICB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KGxvY2FsUG9zaXRpb24sIDEuMCk7XG4gICAgICBpZiAoZm9sbG93Q2FtZXJhKSB7XG4gICAgICAgIHdvcmxkUG9zaXRpb24ueHl6ICs9ICh3b3JsZENhbVByb2pQb3NpdGlvbiAtIHdvcmxkUGxhbmVQb3NpdGlvbik7XG4gICAgICAgIGxvY2FsUG9zaXRpb24gPSAoaW52ZXJzZShtb2RlbE1hdHJpeCkgKiB3b3JsZFBvc2l0aW9uKS54eXo7XG4gICAgICB9XG5cbiAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1xuICAgIH1cbiAgYCwgLyogZ2xzbCAqL2BcbiAgICB2YXJ5aW5nIHZlYzMgbG9jYWxQb3NpdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzQgd29ybGRQb3NpdGlvbjtcblxuICAgIHVuaWZvcm0gdmVjMyB3b3JsZENhbVByb2pQb3NpdGlvbjtcbiAgICB1bmlmb3JtIGZsb2F0IGNlbGxTaXplO1xuICAgIHVuaWZvcm0gZmxvYXQgc2VjdGlvblNpemU7XG4gICAgdW5pZm9ybSB2ZWMzIGNlbGxDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzMgc2VjdGlvbkNvbG9yO1xuICAgIHVuaWZvcm0gZmxvYXQgZmFkZURpc3RhbmNlO1xuICAgIHVuaWZvcm0gZmxvYXQgZmFkZVN0cmVuZ3RoO1xuICAgIHVuaWZvcm0gZmxvYXQgZmFkZUZyb207XG4gICAgdW5pZm9ybSBmbG9hdCBjZWxsVGhpY2tuZXNzO1xuICAgIHVuaWZvcm0gZmxvYXQgc2VjdGlvblRoaWNrbmVzcztcblxuICAgIGZsb2F0IGdldEdyaWQoZmxvYXQgc2l6ZSwgZmxvYXQgdGhpY2tuZXNzKSB7XG4gICAgICB2ZWMyIHIgPSBsb2NhbFBvc2l0aW9uLnh6IC8gc2l6ZTtcbiAgICAgIHZlYzIgZ3JpZCA9IGFicyhmcmFjdChyIC0gMC41KSAtIDAuNSkgLyBmd2lkdGgocik7XG4gICAgICBmbG9hdCBsaW5lID0gbWluKGdyaWQueCwgZ3JpZC55KSArIDEuMCAtIHRoaWNrbmVzcztcbiAgICAgIHJldHVybiAxLjAgLSBtaW4obGluZSwgMS4wKTtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICBmbG9hdCBnMSA9IGdldEdyaWQoY2VsbFNpemUsIGNlbGxUaGlja25lc3MpO1xuICAgICAgZmxvYXQgZzIgPSBnZXRHcmlkKHNlY3Rpb25TaXplLCBzZWN0aW9uVGhpY2tuZXNzKTtcblxuICAgICAgdmVjMyBmcm9tID0gd29ybGRDYW1Qcm9qUG9zaXRpb24qdmVjMyhmYWRlRnJvbSk7XG4gICAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UoZnJvbSwgd29ybGRQb3NpdGlvbi54eXopO1xuICAgICAgZmxvYXQgZCA9IDEuMCAtIG1pbihkaXN0IC8gZmFkZURpc3RhbmNlLCAxLjApO1xuICAgICAgdmVjMyBjb2xvciA9IG1peChjZWxsQ29sb3IsIHNlY3Rpb25Db2xvciwgbWluKDEuMCwgc2VjdGlvblRoaWNrbmVzcyAqIGcyKSk7XG5cbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIChnMSArIGcyKSAqIHBvdyhkLCBmYWRlU3RyZW5ndGgpKTtcbiAgICAgIGdsX0ZyYWdDb2xvci5hID0gbWl4KDAuNzUgKiBnbF9GcmFnQ29sb3IuYSwgZ2xfRnJhZ0NvbG9yLmEsIGcyKTtcbiAgICAgIGlmIChnbF9GcmFnQ29sb3IuYSA8PSAwLjApIGRpc2NhcmQ7XG5cbiAgICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cbiAgICAgICNpbmNsdWRlIDwke3ZlcnNpb24gPj0gMTU0ID8gJ2NvbG9yc3BhY2VfZnJhZ21lbnQnIDogJ2VuY29kaW5nc19mcmFnbWVudCd9PlxuICAgIH1cbiAgYCk7XG5jb25zdCBHcmlkID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBhcmdzLFxuICBjZWxsQ29sb3IgPSAnIzAwMDAwMCcsXG4gIHNlY3Rpb25Db2xvciA9ICcjMjA4MGZmJyxcbiAgY2VsbFNpemUgPSAwLjUsXG4gIHNlY3Rpb25TaXplID0gMSxcbiAgZm9sbG93Q2FtZXJhID0gZmFsc2UsXG4gIGluZmluaXRlR3JpZCA9IGZhbHNlLFxuICBmYWRlRGlzdGFuY2UgPSAxMDAsXG4gIGZhZGVTdHJlbmd0aCA9IDEsXG4gIGZhZGVGcm9tID0gMSxcbiAgY2VsbFRoaWNrbmVzcyA9IDAuNSxcbiAgc2VjdGlvblRoaWNrbmVzcyA9IDEsXG4gIHNpZGUgPSBUSFJFRS5CYWNrU2lkZSxcbiAgLi4ucHJvcHNcbn0sIGZSZWYpID0+IHtcbiAgZXh0ZW5kKHtcbiAgICBHcmlkTWF0ZXJpYWxcbiAgfSk7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmUmVmLCAoKSA9PiByZWYuY3VycmVudCwgW10pO1xuICBjb25zdCBwbGFuZSA9IG5ldyBUSFJFRS5QbGFuZSgpO1xuICBjb25zdCB1cFZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApO1xuICBjb25zdCB6ZXJvVmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCk7XG4gIHVzZUZyYW1lKHN0YXRlID0+IHtcbiAgICBwbGFuZS5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCh1cFZlY3RvciwgemVyb1ZlY3RvcikuYXBwbHlNYXRyaXg0KHJlZi5jdXJyZW50Lm1hdHJpeFdvcmxkKTtcbiAgICBjb25zdCBncmlkTWF0ZXJpYWwgPSByZWYuY3VycmVudC5tYXRlcmlhbDtcbiAgICBjb25zdCB3b3JsZENhbVByb2pQb3NpdGlvbiA9IGdyaWRNYXRlcmlhbC51bmlmb3Jtcy53b3JsZENhbVByb2pQb3NpdGlvbjtcbiAgICBjb25zdCB3b3JsZFBsYW5lUG9zaXRpb24gPSBncmlkTWF0ZXJpYWwudW5pZm9ybXMud29ybGRQbGFuZVBvc2l0aW9uO1xuICAgIHBsYW5lLnByb2plY3RQb2ludChzdGF0ZS5jYW1lcmEucG9zaXRpb24sIHdvcmxkQ2FtUHJvalBvc2l0aW9uLnZhbHVlKTtcbiAgICB3b3JsZFBsYW5lUG9zaXRpb24udmFsdWUuc2V0KDAsIDAsIDApLmFwcGx5TWF0cml4NChyZWYuY3VycmVudC5tYXRyaXhXb3JsZCk7XG4gIH0pO1xuICBjb25zdCB1bmlmb3JtczEgPSB7XG4gICAgY2VsbFNpemUsXG4gICAgc2VjdGlvblNpemUsXG4gICAgY2VsbENvbG9yLFxuICAgIHNlY3Rpb25Db2xvcixcbiAgICBjZWxsVGhpY2tuZXNzLFxuICAgIHNlY3Rpb25UaGlja25lc3NcbiAgfTtcbiAgY29uc3QgdW5pZm9ybXMyID0ge1xuICAgIGZhZGVEaXN0YW5jZSxcbiAgICBmYWRlU3RyZW5ndGgsXG4gICAgZmFkZUZyb20sXG4gICAgaW5maW5pdGVHcmlkLFxuICAgIGZvbGxvd0NhbWVyYVxuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZixcbiAgICBmcnVzdHVtQ3VsbGVkOiBmYWxzZVxuICB9LCBwcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JpZE1hdGVyaWFsXCIsIF9leHRlbmRzKHtcbiAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICBcImV4dGVuc2lvbnMtZGVyaXZhdGl2ZXNcIjogdHJ1ZSxcbiAgICBzaWRlOiBzaWRlXG4gIH0sIHVuaWZvcm1zMSwgdW5pZm9ybXMyKSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGxhbmVHZW9tZXRyeVwiLCB7XG4gICAgYXJnczogYXJnc1xuICB9KSk7XG59KTtcblxuZXhwb3J0IHsgR3JpZCB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiUmVhY3QiLCJUSFJFRSIsImV4dGVuZCIsInVzZUZyYW1lIiwic2hhZGVyTWF0ZXJpYWwiLCJ2ZXJzaW9uIiwiR3JpZE1hdGVyaWFsIiwiY2VsbFNpemUiLCJzZWN0aW9uU2l6ZSIsImZhZGVEaXN0YW5jZSIsImZhZGVTdHJlbmd0aCIsImZhZGVGcm9tIiwiY2VsbFRoaWNrbmVzcyIsInNlY3Rpb25UaGlja25lc3MiLCJjZWxsQ29sb3IiLCJDb2xvciIsInNlY3Rpb25Db2xvciIsImluZmluaXRlR3JpZCIsImZvbGxvd0NhbWVyYSIsIndvcmxkQ2FtUHJvalBvc2l0aW9uIiwiVmVjdG9yMyIsIndvcmxkUGxhbmVQb3NpdGlvbiIsIkdyaWQiLCJmb3J3YXJkUmVmIiwiYXJncyIsInNpZGUiLCJCYWNrU2lkZSIsInByb3BzIiwiZlJlZiIsInJlZiIsInVzZVJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJjdXJyZW50IiwicGxhbmUiLCJQbGFuZSIsInVwVmVjdG9yIiwiemVyb1ZlY3RvciIsInN0YXRlIiwic2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQiLCJhcHBseU1hdHJpeDQiLCJtYXRyaXhXb3JsZCIsImdyaWRNYXRlcmlhbCIsIm1hdGVyaWFsIiwidW5pZm9ybXMiLCJwcm9qZWN0UG9pbnQiLCJjYW1lcmEiLCJwb3NpdGlvbiIsInZhbHVlIiwic2V0IiwidW5pZm9ybXMxIiwidW5pZm9ybXMyIiwiY3JlYXRlRWxlbWVudCIsImZydXN0dW1DdWxsZWQiLCJ0cmFuc3BhcmVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Grid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/OrbitControls.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/OrbitControls.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrbitControls: () => (/* binding */ OrbitControls)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/controls/OrbitControls.js\");\n\n\n\n\nconst OrbitControls = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ makeDefault, camera, regress, domElement, enableDamping = true, keyEvents = false, onChange, onStart, onEnd, ...restProps }, ref)=>{\n    const invalidate = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.invalidate);\n    const defaultCamera = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.camera);\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.gl);\n    const events = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.events);\n    const setEvents = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.setEvents);\n    const set = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.set);\n    const get = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.get);\n    const performance = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.performance);\n    const explCamera = camera || defaultCamera;\n    const explDomElement = domElement || events.connected || gl.domElement;\n    const controls = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>new three_stdlib__WEBPACK_IMPORTED_MODULE_3__.OrbitControls(explCamera), [\n        explCamera\n    ]);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(()=>{\n        if (controls.enabled) controls.update();\n    }, -1);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (keyEvents) {\n            controls.connect(keyEvents === true ? explDomElement : keyEvents);\n        }\n        controls.connect(explDomElement);\n        return ()=>void controls.dispose();\n    }, [\n        keyEvents,\n        explDomElement,\n        regress,\n        controls,\n        invalidate\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const callback = (e)=>{\n            invalidate();\n            if (regress) performance.regress();\n            if (onChange) onChange(e);\n        };\n        const onStartCb = (e)=>{\n            if (onStart) onStart(e);\n        };\n        const onEndCb = (e)=>{\n            if (onEnd) onEnd(e);\n        };\n        controls.addEventListener(\"change\", callback);\n        controls.addEventListener(\"start\", onStartCb);\n        controls.addEventListener(\"end\", onEndCb);\n        return ()=>{\n            controls.removeEventListener(\"start\", onStartCb);\n            controls.removeEventListener(\"end\", onEndCb);\n            controls.removeEventListener(\"change\", callback);\n        };\n    }, [\n        onChange,\n        onStart,\n        onEnd,\n        controls,\n        invalidate,\n        setEvents\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (makeDefault) {\n            const old = get().controls;\n            // @ts-ignore https://github.com/three-types/three-ts-types/pull/1398\n            set({\n                controls\n            });\n            return ()=>set({\n                    controls: old\n                });\n        }\n    }, [\n        makeDefault,\n        controls\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: ref,\n        object: controls,\n        enableDamping: enableDamping\n    }, restProps));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9PcmJpdENvbnRyb2xzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwRDtBQUNGO0FBQ3pCO0FBQ2lDO0FBRWhFLE1BQU1JLGdCQUFnQixhQUFhLGlCQUFFRCw2Q0FBZ0IsQ0FBQyxDQUFDLEVBQ3JESSxXQUFXLEVBQ1hDLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxVQUFVLEVBQ1ZDLGdCQUFnQixJQUFJLEVBQ3BCQyxZQUFZLEtBQUssRUFDakJDLFFBQVEsRUFDUkMsT0FBTyxFQUNQQyxLQUFLLEVBQ0wsR0FBR0MsV0FDSixFQUFFQztJQUNELE1BQU1DLGFBQWFqQixxREFBUUEsQ0FBQ2tCLENBQUFBLFFBQVNBLE1BQU1ELFVBQVU7SUFDckQsTUFBTUUsZ0JBQWdCbkIscURBQVFBLENBQUNrQixDQUFBQSxRQUFTQSxNQUFNWCxNQUFNO0lBQ3BELE1BQU1hLEtBQUtwQixxREFBUUEsQ0FBQ2tCLENBQUFBLFFBQVNBLE1BQU1FLEVBQUU7SUFDckMsTUFBTUMsU0FBU3JCLHFEQUFRQSxDQUFDa0IsQ0FBQUEsUUFBU0EsTUFBTUcsTUFBTTtJQUM3QyxNQUFNQyxZQUFZdEIscURBQVFBLENBQUNrQixDQUFBQSxRQUFTQSxNQUFNSSxTQUFTO0lBQ25ELE1BQU1DLE1BQU12QixxREFBUUEsQ0FBQ2tCLENBQUFBLFFBQVNBLE1BQU1LLEdBQUc7SUFDdkMsTUFBTUMsTUFBTXhCLHFEQUFRQSxDQUFDa0IsQ0FBQUEsUUFBU0EsTUFBTU0sR0FBRztJQUN2QyxNQUFNQyxjQUFjekIscURBQVFBLENBQUNrQixDQUFBQSxRQUFTQSxNQUFNTyxXQUFXO0lBQ3ZELE1BQU1DLGFBQWFuQixVQUFVWTtJQUM3QixNQUFNUSxpQkFBaUJsQixjQUFjWSxPQUFPTyxTQUFTLElBQUlSLEdBQUdYLFVBQVU7SUFDdEUsTUFBTW9CLFdBQVczQiwwQ0FBYSxDQUFDLElBQU0sSUFBSUUsdURBQWVBLENBQUNzQixhQUFhO1FBQUNBO0tBQVc7SUFDbEZ6QixxREFBUUEsQ0FBQztRQUNQLElBQUk0QixTQUFTRSxPQUFPLEVBQUVGLFNBQVNHLE1BQU07SUFDdkMsR0FBRyxDQUFDO0lBQ0o5Qiw0Q0FBZSxDQUFDO1FBQ2QsSUFBSVMsV0FBVztZQUNia0IsU0FBU0ssT0FBTyxDQUFDdkIsY0FBYyxPQUFPZ0IsaUJBQWlCaEI7UUFDekQ7UUFDQWtCLFNBQVNLLE9BQU8sQ0FBQ1A7UUFDakIsT0FBTyxJQUFNLEtBQUtFLFNBQVNNLE9BQU87SUFDcEMsR0FBRztRQUFDeEI7UUFBV2dCO1FBQWdCbkI7UUFBU3FCO1FBQVVaO0tBQVc7SUFDN0RmLDRDQUFlLENBQUM7UUFDZCxNQUFNa0MsV0FBV0MsQ0FBQUE7WUFDZnBCO1lBQ0EsSUFBSVQsU0FBU2lCLFlBQVlqQixPQUFPO1lBQ2hDLElBQUlJLFVBQVVBLFNBQVN5QjtRQUN6QjtRQUNBLE1BQU1DLFlBQVlELENBQUFBO1lBQ2hCLElBQUl4QixTQUFTQSxRQUFRd0I7UUFDdkI7UUFDQSxNQUFNRSxVQUFVRixDQUFBQTtZQUNkLElBQUl2QixPQUFPQSxNQUFNdUI7UUFDbkI7UUFDQVIsU0FBU1csZ0JBQWdCLENBQUMsVUFBVUo7UUFDcENQLFNBQVNXLGdCQUFnQixDQUFDLFNBQVNGO1FBQ25DVCxTQUFTVyxnQkFBZ0IsQ0FBQyxPQUFPRDtRQUNqQyxPQUFPO1lBQ0xWLFNBQVNZLG1CQUFtQixDQUFDLFNBQVNIO1lBQ3RDVCxTQUFTWSxtQkFBbUIsQ0FBQyxPQUFPRjtZQUNwQ1YsU0FBU1ksbUJBQW1CLENBQUMsVUFBVUw7UUFDekM7SUFDRixHQUFHO1FBQUN4QjtRQUFVQztRQUFTQztRQUFPZTtRQUFVWjtRQUFZSztLQUFVO0lBQzlEcEIsNENBQWUsQ0FBQztRQUNkLElBQUlJLGFBQWE7WUFDZixNQUFNb0MsTUFBTWxCLE1BQU1LLFFBQVE7WUFDMUIscUVBQXFFO1lBQ3JFTixJQUFJO2dCQUNGTTtZQUNGO1lBQ0EsT0FBTyxJQUFNTixJQUFJO29CQUNmTSxVQUFVYTtnQkFDWjtRQUNGO0lBQ0YsR0FBRztRQUFDcEM7UUFBYXVCO0tBQVM7SUFDMUIsT0FBTyxXQUFXLEdBQUUzQixnREFBbUIsQ0FBQyxhQUFhSCw4RUFBUUEsQ0FBQztRQUM1RGlCLEtBQUtBO1FBQ0w0QixRQUFRZjtRQUNSbkIsZUFBZUE7SUFDakIsR0FBR0s7QUFDTDtBQUV5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JvY2tldHNpbS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL09yYml0Q29udHJvbHMuanM/YzhlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgeyB1c2VUaHJlZSwgdXNlRnJhbWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgT3JiaXRDb250cm9scyBhcyBPcmJpdENvbnRyb2xzJDEgfSBmcm9tICd0aHJlZS1zdGRsaWInO1xuXG5jb25zdCBPcmJpdENvbnRyb2xzID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBtYWtlRGVmYXVsdCxcbiAgY2FtZXJhLFxuICByZWdyZXNzLFxuICBkb21FbGVtZW50LFxuICBlbmFibGVEYW1waW5nID0gdHJ1ZSxcbiAga2V5RXZlbnRzID0gZmFsc2UsXG4gIG9uQ2hhbmdlLFxuICBvblN0YXJ0LFxuICBvbkVuZCxcbiAgLi4ucmVzdFByb3BzXG59LCByZWYpID0+IHtcbiAgY29uc3QgaW52YWxpZGF0ZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmludmFsaWRhdGUpO1xuICBjb25zdCBkZWZhdWx0Q2FtZXJhID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuY2FtZXJhKTtcbiAgY29uc3QgZ2wgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5nbCk7XG4gIGNvbnN0IGV2ZW50cyA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmV2ZW50cyk7XG4gIGNvbnN0IHNldEV2ZW50cyA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNldEV2ZW50cyk7XG4gIGNvbnN0IHNldCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNldCk7XG4gIGNvbnN0IGdldCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmdldCk7XG4gIGNvbnN0IHBlcmZvcm1hbmNlID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUucGVyZm9ybWFuY2UpO1xuICBjb25zdCBleHBsQ2FtZXJhID0gY2FtZXJhIHx8IGRlZmF1bHRDYW1lcmE7XG4gIGNvbnN0IGV4cGxEb21FbGVtZW50ID0gZG9tRWxlbWVudCB8fCBldmVudHMuY29ubmVjdGVkIHx8IGdsLmRvbUVsZW1lbnQ7XG4gIGNvbnN0IGNvbnRyb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiBuZXcgT3JiaXRDb250cm9scyQxKGV4cGxDYW1lcmEpLCBbZXhwbENhbWVyYV0pO1xuICB1c2VGcmFtZSgoKSA9PiB7XG4gICAgaWYgKGNvbnRyb2xzLmVuYWJsZWQpIGNvbnRyb2xzLnVwZGF0ZSgpO1xuICB9LCAtMSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGtleUV2ZW50cykge1xuICAgICAgY29udHJvbHMuY29ubmVjdChrZXlFdmVudHMgPT09IHRydWUgPyBleHBsRG9tRWxlbWVudCA6IGtleUV2ZW50cyk7XG4gICAgfVxuICAgIGNvbnRyb2xzLmNvbm5lY3QoZXhwbERvbUVsZW1lbnQpO1xuICAgIHJldHVybiAoKSA9PiB2b2lkIGNvbnRyb2xzLmRpc3Bvc2UoKTtcbiAgfSwgW2tleUV2ZW50cywgZXhwbERvbUVsZW1lbnQsIHJlZ3Jlc3MsIGNvbnRyb2xzLCBpbnZhbGlkYXRlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBlID0+IHtcbiAgICAgIGludmFsaWRhdGUoKTtcbiAgICAgIGlmIChyZWdyZXNzKSBwZXJmb3JtYW5jZS5yZWdyZXNzKCk7XG4gICAgICBpZiAob25DaGFuZ2UpIG9uQ2hhbmdlKGUpO1xuICAgIH07XG4gICAgY29uc3Qgb25TdGFydENiID0gZSA9PiB7XG4gICAgICBpZiAob25TdGFydCkgb25TdGFydChlKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRW5kQ2IgPSBlID0+IHtcbiAgICAgIGlmIChvbkVuZCkgb25FbmQoZSk7XG4gICAgfTtcbiAgICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignc3RhcnQnLCBvblN0YXJ0Q2IpO1xuICAgIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIG9uRW5kQ2IpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGFydCcsIG9uU3RhcnRDYik7XG4gICAgICBjb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmQnLCBvbkVuZENiKTtcbiAgICAgIGNvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9LCBbb25DaGFuZ2UsIG9uU3RhcnQsIG9uRW5kLCBjb250cm9scywgaW52YWxpZGF0ZSwgc2V0RXZlbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1ha2VEZWZhdWx0KSB7XG4gICAgICBjb25zdCBvbGQgPSBnZXQoKS5jb250cm9scztcbiAgICAgIC8vIEB0cy1pZ25vcmUgaHR0cHM6Ly9naXRodWIuY29tL3RocmVlLXR5cGVzL3RocmVlLXRzLXR5cGVzL3B1bGwvMTM5OFxuICAgICAgc2V0KHtcbiAgICAgICAgY29udHJvbHNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHNldCh7XG4gICAgICAgIGNvbnRyb2xzOiBvbGRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW21ha2VEZWZhdWx0LCBjb250cm9sc10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmLFxuICAgIG9iamVjdDogY29udHJvbHMsXG4gICAgZW5hYmxlRGFtcGluZzogZW5hYmxlRGFtcGluZ1xuICB9LCByZXN0UHJvcHMpKTtcbn0pO1xuXG5leHBvcnQgeyBPcmJpdENvbnRyb2xzIH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJ1c2VUaHJlZSIsInVzZUZyYW1lIiwiUmVhY3QiLCJPcmJpdENvbnRyb2xzIiwiT3JiaXRDb250cm9scyQxIiwiZm9yd2FyZFJlZiIsIm1ha2VEZWZhdWx0IiwiY2FtZXJhIiwicmVncmVzcyIsImRvbUVsZW1lbnQiLCJlbmFibGVEYW1waW5nIiwia2V5RXZlbnRzIiwib25DaGFuZ2UiLCJvblN0YXJ0Iiwib25FbmQiLCJyZXN0UHJvcHMiLCJyZWYiLCJpbnZhbGlkYXRlIiwic3RhdGUiLCJkZWZhdWx0Q2FtZXJhIiwiZ2wiLCJldmVudHMiLCJzZXRFdmVudHMiLCJzZXQiLCJnZXQiLCJwZXJmb3JtYW5jZSIsImV4cGxDYW1lcmEiLCJleHBsRG9tRWxlbWVudCIsImNvbm5lY3RlZCIsImNvbnRyb2xzIiwidXNlTWVtbyIsImVuYWJsZWQiLCJ1cGRhdGUiLCJ1c2VFZmZlY3QiLCJjb25uZWN0IiwiZGlzcG9zZSIsImNhbGxiYWNrIiwiZSIsIm9uU3RhcnRDYiIsIm9uRW5kQ2IiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9sZCIsImNyZWF0ZUVsZW1lbnQiLCJvYmplY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/OrbitControls.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/PerspectiveCamera.js":
/*!******************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/PerspectiveCamera.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PerspectiveCamera: () => (/* binding */ PerspectiveCamera)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n/* harmony import */ var _Fbo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Fbo.js */ \"(ssr)/./node_modules/@react-three/drei/core/Fbo.js\");\n\n\n\n\nconst isFunction = (node)=>typeof node === \"function\";\nconst PerspectiveCamera = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ envMap, resolution = 256, frames = Infinity, makeDefault, children, ...props }, ref)=>{\n    const set = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(({ set })=>set);\n    const camera = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(({ camera })=>camera);\n    const size = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(({ size })=>size);\n    const cameraRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, ()=>cameraRef.current, []);\n    const groupRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const fbo = (0,_Fbo_js__WEBPACK_IMPORTED_MODULE_3__.useFBO)(resolution);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (!props.manual) {\n            cameraRef.current.aspect = size.width / size.height;\n        }\n    }, [\n        size,\n        props\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        cameraRef.current.updateProjectionMatrix();\n    });\n    let count = 0;\n    let oldEnvMap = null;\n    const functional = isFunction(children);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)((state)=>{\n        if (functional && (frames === Infinity || count < frames)) {\n            groupRef.current.visible = false;\n            state.gl.setRenderTarget(fbo);\n            oldEnvMap = state.scene.background;\n            if (envMap) state.scene.background = envMap;\n            state.gl.render(state.scene, cameraRef.current);\n            state.scene.background = oldEnvMap;\n            state.gl.setRenderTarget(null);\n            groupRef.current.visible = true;\n            count++;\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (makeDefault) {\n            const oldCam = camera;\n            set(()=>({\n                    camera: cameraRef.current\n                }));\n            return ()=>set(()=>({\n                        camera: oldCam\n                    }));\n        }\n    // The camera should not be part of the dependency list because this components camera is a stable reference\n    // that must exchange the default, and clean up after itself on unmount.\n    }, [\n        cameraRef,\n        makeDefault,\n        set\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"perspectiveCamera\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: cameraRef\n    }, props), !functional && children), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", {\n        ref: groupRef\n    }, functional && children(fbo.texture)));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9QZXJzcGVjdGl2ZUNhbWVyYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDeUI7QUFDdEI7QUFFbEMsTUFBTUssYUFBYUMsQ0FBQUEsT0FBUSxPQUFPQSxTQUFTO0FBQzNDLE1BQU1DLG9CQUFvQixhQUFhLGlCQUFFTiw2Q0FBZ0IsQ0FBQyxDQUFDLEVBQ3pEUSxNQUFNLEVBQ05DLGFBQWEsR0FBRyxFQUNoQkMsU0FBU0MsUUFBUSxFQUNqQkMsV0FBVyxFQUNYQyxRQUFRLEVBQ1IsR0FBR0MsT0FDSixFQUFFQztJQUNELE1BQU1DLE1BQU1mLHFEQUFRQSxDQUFDLENBQUMsRUFDcEJlLEdBQUcsRUFDSixHQUFLQTtJQUNOLE1BQU1DLFNBQVNoQixxREFBUUEsQ0FBQyxDQUFDLEVBQ3ZCZ0IsTUFBTSxFQUNQLEdBQUtBO0lBQ04sTUFBTUMsT0FBT2pCLHFEQUFRQSxDQUFDLENBQUMsRUFDckJpQixJQUFJLEVBQ0wsR0FBS0E7SUFDTixNQUFNQyxZQUFZbkIseUNBQVksQ0FBQztJQUMvQkEsc0RBQXlCLENBQUNlLEtBQUssSUFBTUksVUFBVUcsT0FBTyxFQUFFLEVBQUU7SUFDMUQsTUFBTUMsV0FBV3ZCLHlDQUFZLENBQUM7SUFDOUIsTUFBTXdCLE1BQU1yQiwrQ0FBTUEsQ0FBQ007SUFDbkJULGtEQUFxQixDQUFDO1FBQ3BCLElBQUksQ0FBQ2MsTUFBTVksTUFBTSxFQUFFO1lBQ2pCUCxVQUFVRyxPQUFPLENBQUNLLE1BQU0sR0FBR1QsS0FBS1UsS0FBSyxHQUFHVixLQUFLVyxNQUFNO1FBQ3JEO0lBQ0YsR0FBRztRQUFDWDtRQUFNSjtLQUFNO0lBQ2hCZCxrREFBcUIsQ0FBQztRQUNwQm1CLFVBQVVHLE9BQU8sQ0FBQ1Esc0JBQXNCO0lBQzFDO0lBQ0EsSUFBSUMsUUFBUTtJQUNaLElBQUlDLFlBQVk7SUFDaEIsTUFBTUMsYUFBYTdCLFdBQVdTO0lBQzlCWCxxREFBUUEsQ0FBQ2dDLENBQUFBO1FBQ1AsSUFBSUQsY0FBZXZCLENBQUFBLFdBQVdDLFlBQVlvQixRQUFRckIsTUFBSyxHQUFJO1lBQ3pEYSxTQUFTRCxPQUFPLENBQUNhLE9BQU8sR0FBRztZQUMzQkQsTUFBTUUsRUFBRSxDQUFDQyxlQUFlLENBQUNiO1lBQ3pCUSxZQUFZRSxNQUFNSSxLQUFLLENBQUNDLFVBQVU7WUFDbEMsSUFBSS9CLFFBQVEwQixNQUFNSSxLQUFLLENBQUNDLFVBQVUsR0FBRy9CO1lBQ3JDMEIsTUFBTUUsRUFBRSxDQUFDSSxNQUFNLENBQUNOLE1BQU1JLEtBQUssRUFBRW5CLFVBQVVHLE9BQU87WUFDOUNZLE1BQU1JLEtBQUssQ0FBQ0MsVUFBVSxHQUFHUDtZQUN6QkUsTUFBTUUsRUFBRSxDQUFDQyxlQUFlLENBQUM7WUFDekJkLFNBQVNELE9BQU8sQ0FBQ2EsT0FBTyxHQUFHO1lBQzNCSjtRQUNGO0lBQ0Y7SUFDQS9CLGtEQUFxQixDQUFDO1FBQ3BCLElBQUlZLGFBQWE7WUFDZixNQUFNNkIsU0FBU3hCO1lBQ2ZELElBQUksSUFBTztvQkFDVEMsUUFBUUUsVUFBVUcsT0FBTztnQkFDM0I7WUFDQSxPQUFPLElBQU1OLElBQUksSUFBTzt3QkFDdEJDLFFBQVF3QjtvQkFDVjtRQUNGO0lBQ0EsNEdBQTRHO0lBQzVHLHdFQUF3RTtJQUMxRSxHQUFHO1FBQUN0QjtRQUFXUDtRQUFhSTtLQUFJO0lBQ2hDLE9BQU8sV0FBVyxHQUFFaEIsZ0RBQW1CLENBQUNBLDJDQUFjLEVBQUUsTUFBTSxXQUFXLEdBQUVBLGdEQUFtQixDQUFDLHFCQUFxQkQsOEVBQVFBLENBQUM7UUFDM0hnQixLQUFLSTtJQUNQLEdBQUdMLFFBQVEsQ0FBQ21CLGNBQWNwQixXQUFXLFdBQVcsR0FBRWIsZ0RBQW1CLENBQUMsU0FBUztRQUM3RWUsS0FBS1E7SUFDUCxHQUFHVSxjQUFjcEIsU0FBU1csSUFBSW9CLE9BQU87QUFDdkM7QUFFNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yb2NrZXRzaW0vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9QZXJzcGVjdGl2ZUNhbWVyYS5qcz80NjZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVRocmVlLCB1c2VGcmFtZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyB1c2VGQk8gfSBmcm9tICcuL0Ziby5qcyc7XG5cbmNvbnN0IGlzRnVuY3Rpb24gPSBub2RlID0+IHR5cGVvZiBub2RlID09PSAnZnVuY3Rpb24nO1xuY29uc3QgUGVyc3BlY3RpdmVDYW1lcmEgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIGVudk1hcCxcbiAgcmVzb2x1dGlvbiA9IDI1NixcbiAgZnJhbWVzID0gSW5maW5pdHksXG4gIG1ha2VEZWZhdWx0LFxuICBjaGlsZHJlbixcbiAgLi4ucHJvcHNcbn0sIHJlZikgPT4ge1xuICBjb25zdCBzZXQgPSB1c2VUaHJlZSgoe1xuICAgIHNldFxuICB9KSA9PiBzZXQpO1xuICBjb25zdCBjYW1lcmEgPSB1c2VUaHJlZSgoe1xuICAgIGNhbWVyYVxuICB9KSA9PiBjYW1lcmEpO1xuICBjb25zdCBzaXplID0gdXNlVGhyZWUoKHtcbiAgICBzaXplXG4gIH0pID0+IHNpemUpO1xuICBjb25zdCBjYW1lcmFSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiBjYW1lcmFSZWYuY3VycmVudCwgW10pO1xuICBjb25zdCBncm91cFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZmJvID0gdXNlRkJPKHJlc29sdXRpb24pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcHJvcHMubWFudWFsKSB7XG4gICAgICBjYW1lcmFSZWYuY3VycmVudC5hc3BlY3QgPSBzaXplLndpZHRoIC8gc2l6ZS5oZWlnaHQ7XG4gICAgfVxuICB9LCBbc2l6ZSwgcHJvcHNdKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjYW1lcmFSZWYuY3VycmVudC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gIH0pO1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgb2xkRW52TWFwID0gbnVsbDtcbiAgY29uc3QgZnVuY3Rpb25hbCA9IGlzRnVuY3Rpb24oY2hpbGRyZW4pO1xuICB1c2VGcmFtZShzdGF0ZSA9PiB7XG4gICAgaWYgKGZ1bmN0aW9uYWwgJiYgKGZyYW1lcyA9PT0gSW5maW5pdHkgfHwgY291bnQgPCBmcmFtZXMpKSB7XG4gICAgICBncm91cFJlZi5jdXJyZW50LnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmdsLnNldFJlbmRlclRhcmdldChmYm8pO1xuICAgICAgb2xkRW52TWFwID0gc3RhdGUuc2NlbmUuYmFja2dyb3VuZDtcbiAgICAgIGlmIChlbnZNYXApIHN0YXRlLnNjZW5lLmJhY2tncm91bmQgPSBlbnZNYXA7XG4gICAgICBzdGF0ZS5nbC5yZW5kZXIoc3RhdGUuc2NlbmUsIGNhbWVyYVJlZi5jdXJyZW50KTtcbiAgICAgIHN0YXRlLnNjZW5lLmJhY2tncm91bmQgPSBvbGRFbnZNYXA7XG4gICAgICBzdGF0ZS5nbC5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICBncm91cFJlZi5jdXJyZW50LnZpc2libGUgPSB0cnVlO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH0pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYWtlRGVmYXVsdCkge1xuICAgICAgY29uc3Qgb2xkQ2FtID0gY2FtZXJhO1xuICAgICAgc2V0KCgpID0+ICh7XG4gICAgICAgIGNhbWVyYTogY2FtZXJhUmVmLmN1cnJlbnRcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiAoKSA9PiBzZXQoKCkgPT4gKHtcbiAgICAgICAgY2FtZXJhOiBvbGRDYW1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLy8gVGhlIGNhbWVyYSBzaG91bGQgbm90IGJlIHBhcnQgb2YgdGhlIGRlcGVuZGVuY3kgbGlzdCBiZWNhdXNlIHRoaXMgY29tcG9uZW50cyBjYW1lcmEgaXMgYSBzdGFibGUgcmVmZXJlbmNlXG4gICAgLy8gdGhhdCBtdXN0IGV4Y2hhbmdlIHRoZSBkZWZhdWx0LCBhbmQgY2xlYW4gdXAgYWZ0ZXIgaXRzZWxmIG9uIHVubW91bnQuXG4gIH0sIFtjYW1lcmFSZWYsIG1ha2VEZWZhdWx0LCBzZXRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBlcnNwZWN0aXZlQ2FtZXJhXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IGNhbWVyYVJlZlxuICB9LCBwcm9wcyksICFmdW5jdGlvbmFsICYmIGNoaWxkcmVuKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCB7XG4gICAgcmVmOiBncm91cFJlZlxuICB9LCBmdW5jdGlvbmFsICYmIGNoaWxkcmVuKGZiby50ZXh0dXJlKSkpO1xufSk7XG5cbmV4cG9ydCB7IFBlcnNwZWN0aXZlQ2FtZXJhIH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJSZWFjdCIsInVzZVRocmVlIiwidXNlRnJhbWUiLCJ1c2VGQk8iLCJpc0Z1bmN0aW9uIiwibm9kZSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiZm9yd2FyZFJlZiIsImVudk1hcCIsInJlc29sdXRpb24iLCJmcmFtZXMiLCJJbmZpbml0eSIsIm1ha2VEZWZhdWx0IiwiY2hpbGRyZW4iLCJwcm9wcyIsInJlZiIsInNldCIsImNhbWVyYSIsInNpemUiLCJjYW1lcmFSZWYiLCJ1c2VSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiY3VycmVudCIsImdyb3VwUmVmIiwiZmJvIiwidXNlTGF5b3V0RWZmZWN0IiwibWFudWFsIiwiYXNwZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwiY291bnQiLCJvbGRFbnZNYXAiLCJmdW5jdGlvbmFsIiwic3RhdGUiLCJ2aXNpYmxlIiwiZ2wiLCJzZXRSZW5kZXJUYXJnZXQiLCJzY2VuZSIsImJhY2tncm91bmQiLCJyZW5kZXIiLCJvbGRDYW0iLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJ0ZXh0dXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/PerspectiveCamera.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/shaderMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/shaderMaterial.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shaderMaterial: () => (/* binding */ shaderMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nfunction shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {\n    const material = class material extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n        constructor(parameters = {}){\n            const entries = Object.entries(uniforms);\n            // Create unforms and shaders\n            super({\n                uniforms: entries.reduce((acc, [name, value])=>{\n                    const uniform = three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone({\n                        [name]: {\n                            value\n                        }\n                    });\n                    return {\n                        ...acc,\n                        ...uniform\n                    };\n                }, {}),\n                vertexShader,\n                fragmentShader\n            });\n            // Create getter/setters\n            this.key = \"\";\n            entries.forEach(([name])=>Object.defineProperty(this, name, {\n                    get: ()=>this.uniforms[name].value,\n                    set: (v)=>this.uniforms[name].value = v\n                }));\n            // Assign parameters, this might include uniforms\n            Object.assign(this, parameters);\n            // Call onInit\n            if (onInit) onInit(this);\n        }\n    };\n    material.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n    return material;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9zaGFkZXJNYXRlcmlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjtBQUUvQixTQUFTQyxlQUFlQyxRQUFRLEVBQUVDLFlBQVksRUFBRUMsY0FBYyxFQUFFQyxNQUFNO0lBQ3BFLE1BQU1DLFdBQVcsTUFBTUEsaUJBQWlCTixpREFBb0I7UUFDMURRLFlBQVlDLGFBQWEsQ0FBQyxDQUFDLENBQUU7WUFDM0IsTUFBTUMsVUFBVUMsT0FBT0QsT0FBTyxDQUFDUjtZQUMvQiw2QkFBNkI7WUFDN0IsS0FBSyxDQUFDO2dCQUNKQSxVQUFVUSxRQUFRRSxNQUFNLENBQUMsQ0FBQ0MsS0FBSyxDQUFDQyxNQUFNQyxNQUFNO29CQUMxQyxNQUFNQyxVQUFVaEIsZ0RBQW1CLENBQUNrQixLQUFLLENBQUM7d0JBQ3hDLENBQUNKLEtBQUssRUFBRTs0QkFDTkM7d0JBQ0Y7b0JBQ0Y7b0JBQ0EsT0FBTzt3QkFDTCxHQUFHRixHQUFHO3dCQUNOLEdBQUdHLE9BQU87b0JBQ1o7Z0JBQ0YsR0FBRyxDQUFDO2dCQUNKYjtnQkFDQUM7WUFDRjtZQUNBLHdCQUF3QjtZQUN4QixJQUFJLENBQUNlLEdBQUcsR0FBRztZQUNYVCxRQUFRVSxPQUFPLENBQUMsQ0FBQyxDQUFDTixLQUFLLEdBQUtILE9BQU9VLGNBQWMsQ0FBQyxJQUFJLEVBQUVQLE1BQU07b0JBQzVEUSxLQUFLLElBQU0sSUFBSSxDQUFDcEIsUUFBUSxDQUFDWSxLQUFLLENBQUNDLEtBQUs7b0JBQ3BDUSxLQUFLQyxDQUFBQSxJQUFLLElBQUksQ0FBQ3RCLFFBQVEsQ0FBQ1ksS0FBSyxDQUFDQyxLQUFLLEdBQUdTO2dCQUN4QztZQUVBLGlEQUFpRDtZQUNqRGIsT0FBT2MsTUFBTSxDQUFDLElBQUksRUFBRWhCO1lBQ3BCLGNBQWM7WUFDZCxJQUFJSixRQUFRQSxPQUFPLElBQUk7UUFDekI7SUFDRjtJQUNBQyxTQUFTYSxHQUFHLEdBQUduQiw0Q0FBZSxDQUFDMkIsWUFBWTtJQUMzQyxPQUFPckI7QUFDVDtBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JvY2tldHNpbS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL3NoYWRlck1hdGVyaWFsLmpzPzc3ODMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuXG5mdW5jdGlvbiBzaGFkZXJNYXRlcmlhbCh1bmlmb3JtcywgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciwgb25Jbml0KSB7XG4gIGNvbnN0IG1hdGVyaWFsID0gY2xhc3MgbWF0ZXJpYWwgZXh0ZW5kcyBUSFJFRS5TaGFkZXJNYXRlcmlhbCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXModW5pZm9ybXMpO1xuICAgICAgLy8gQ3JlYXRlIHVuZm9ybXMgYW5kIHNoYWRlcnNcbiAgICAgIHN1cGVyKHtcbiAgICAgICAgdW5pZm9ybXM6IGVudHJpZXMucmVkdWNlKChhY2MsIFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBjb25zdCB1bmlmb3JtID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSh7XG4gICAgICAgICAgICBbbmFtZV06IHtcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgICAgLi4udW5pZm9ybVxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHt9KSxcbiAgICAgICAgdmVydGV4U2hhZGVyLFxuICAgICAgICBmcmFnbWVudFNoYWRlclxuICAgICAgfSk7XG4gICAgICAvLyBDcmVhdGUgZ2V0dGVyL3NldHRlcnNcbiAgICAgIHRoaXMua2V5ID0gJyc7XG4gICAgICBlbnRyaWVzLmZvckVhY2goKFtuYW1lXSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB0aGlzLnVuaWZvcm1zW25hbWVdLnZhbHVlLFxuICAgICAgICBzZXQ6IHYgPT4gdGhpcy51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IHZcbiAgICAgIH0pKTtcblxuICAgICAgLy8gQXNzaWduIHBhcmFtZXRlcnMsIHRoaXMgbWlnaHQgaW5jbHVkZSB1bmlmb3Jtc1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwYXJhbWV0ZXJzKTtcbiAgICAgIC8vIENhbGwgb25Jbml0XG4gICAgICBpZiAob25Jbml0KSBvbkluaXQodGhpcyk7XG4gICAgfVxuICB9O1xuICBtYXRlcmlhbC5rZXkgPSBUSFJFRS5NYXRoVXRpbHMuZ2VuZXJhdGVVVUlEKCk7XG4gIHJldHVybiBtYXRlcmlhbDtcbn1cblxuZXhwb3J0IHsgc2hhZGVyTWF0ZXJpYWwgfTtcbiJdLCJuYW1lcyI6WyJUSFJFRSIsInNoYWRlck1hdGVyaWFsIiwidW5pZm9ybXMiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsIm9uSW5pdCIsIm1hdGVyaWFsIiwiU2hhZGVyTWF0ZXJpYWwiLCJjb25zdHJ1Y3RvciIsInBhcmFtZXRlcnMiLCJlbnRyaWVzIiwiT2JqZWN0IiwicmVkdWNlIiwiYWNjIiwibmFtZSIsInZhbHVlIiwidW5pZm9ybSIsIlVuaWZvcm1zVXRpbHMiLCJjbG9uZSIsImtleSIsImZvckVhY2giLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsInNldCIsInYiLCJhc3NpZ24iLCJNYXRoVXRpbHMiLCJnZW5lcmF0ZVVVSUQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/shaderMaterial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useEnvironment.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEnvironment: () => (/* binding */ useEnvironment)\n/* harmony export */ });\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/RGBELoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/EXRLoader.js\");\n/* harmony import */ var _monogrid_gainmap_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @monogrid/gainmap-js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js\");\n/* harmony import */ var _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/environment-assets.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\");\n/* harmony import */ var _helpers_deprecated_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/deprecated.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/deprecated.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\n\n\n\nconst CUBEMAP_ROOT = \"https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/\";\nconst isArray = (arr)=>Array.isArray(arr);\nconst defaultFiles = [\n    \"/px.png\",\n    \"/nx.png\",\n    \"/py.png\",\n    \"/ny.png\",\n    \"/pz.png\",\n    \"/nz.png\"\n];\nfunction useEnvironment({ files = defaultFiles, path = \"\", preset = undefined, encoding = undefined, extensions } = {}) {\n    let loader = null;\n    let multiFile = false;\n    if (preset) {\n        validatePreset(preset);\n        files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj[preset];\n        path = CUBEMAP_ROOT;\n    }\n    // Everything else\n    multiFile = isArray(files);\n    const { extension, isCubemap } = getExtension(files);\n    loader = getLoader(extension);\n    if (!loader) throw new Error(\"useEnvironment: Unrecognized file extension: \" + files);\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.gl);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        // Only required for gainmap\n        if (extension !== \"webp\" && extension !== \"jpg\" && extension !== \"jpeg\") return;\n        function clearGainmapTexture() {\n            _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.F.clear(// @ts-expect-error\n            loader, multiFile ? [\n                files\n            ] : files);\n        }\n        gl.domElement.addEventListener(\"webglcontextlost\", clearGainmapTexture, {\n            once: true\n        });\n    }, [\n        files,\n        gl.domElement\n    ]);\n    const loaderResult = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.F)(// @ts-expect-error\n    loader, multiFile ? [\n        files\n    ] : files, (loader)=>{\n        // Gainmap requires a renderer\n        if (extension === \"webp\" || extension === \"jpg\" || extension === \"jpeg\") {\n            loader.setRenderer(gl);\n        }\n        loader.setPath == null || loader.setPath(path);\n        if (extensions) extensions(loader);\n    });\n    let texture = multiFile ? // @ts-ignore\n    loaderResult[0] : loaderResult;\n    if (extension === \"jpg\" || extension === \"jpeg\" || extension === \"webp\") {\n        var _renderTarget;\n        texture = (_renderTarget = texture.renderTarget) == null ? void 0 : _renderTarget.texture;\n    }\n    texture.mapping = isCubemap ? three__WEBPACK_IMPORTED_MODULE_3__.CubeReflectionMapping : three__WEBPACK_IMPORTED_MODULE_3__.EquirectangularReflectionMapping;\n    if (\"colorSpace\" in texture) texture.colorSpace = (encoding !== null && encoding !== void 0 ? encoding : isCubemap) ? \"srgb\" : \"srgb-linear\";\n    else texture.encoding = (encoding !== null && encoding !== void 0 ? encoding : isCubemap) ? _helpers_deprecated_js__WEBPACK_IMPORTED_MODULE_4__.sRGBEncoding : _helpers_deprecated_js__WEBPACK_IMPORTED_MODULE_4__.LinearEncoding;\n    return texture;\n}\nconst preloadDefaultOptions = {\n    files: defaultFiles,\n    path: \"\",\n    preset: undefined,\n    extensions: undefined\n};\nuseEnvironment.preload = (preloadOptions)=>{\n    const options = {\n        ...preloadDefaultOptions,\n        ...preloadOptions\n    };\n    let { files, path = \"\" } = options;\n    const { preset, extensions } = options;\n    if (preset) {\n        validatePreset(preset);\n        files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj[preset];\n        path = CUBEMAP_ROOT;\n    }\n    const { extension } = getExtension(files);\n    if (extension === \"webp\" || extension === \"jpg\" || extension === \"jpeg\") {\n        throw new Error(\"useEnvironment: Preloading gainmaps is not supported\");\n    }\n    const loader = getLoader(extension);\n    if (!loader) throw new Error(\"useEnvironment: Unrecognized file extension: \" + files);\n    _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.F.preload(// @ts-expect-error\n    loader, isArray(files) ? [\n        files\n    ] : files, (loader)=>{\n        loader.setPath == null || loader.setPath(path);\n        if (extensions) extensions(loader);\n    });\n};\nconst clearDefaultOptins = {\n    files: defaultFiles,\n    preset: undefined\n};\nuseEnvironment.clear = (clearOptions)=>{\n    const options = {\n        ...clearDefaultOptins,\n        ...clearOptions\n    };\n    let { files } = options;\n    const { preset } = options;\n    if (preset) {\n        validatePreset(preset);\n        files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj[preset];\n    }\n    const { extension } = getExtension(files);\n    const loader = getLoader(extension);\n    if (!loader) throw new Error(\"useEnvironment: Unrecognized file extension: \" + files);\n    _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.F.clear(// @ts-expect-error\n    loader, isArray(files) ? [\n        files\n    ] : files);\n};\nfunction validatePreset(preset) {\n    if (!(preset in _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj)) throw new Error(\"Preset must be one of: \" + Object.keys(_helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj).join(\", \"));\n}\nfunction getExtension(files) {\n    var _firstEntry$split$pop;\n    const isCubemap = isArray(files) && files.length === 6;\n    const isGainmap = isArray(files) && files.length === 3 && files.some((file)=>file.endsWith(\"json\"));\n    const firstEntry = isArray(files) ? files[0] : files;\n    // Everything else\n    const extension = isCubemap ? \"cube\" : isGainmap ? \"webp\" : firstEntry.startsWith(\"data:application/exr\") ? \"exr\" : firstEntry.startsWith(\"data:application/hdr\") ? \"hdr\" : firstEntry.startsWith(\"data:image/jpeg\") ? \"jpg\" : (_firstEntry$split$pop = firstEntry.split(\".\").pop()) == null || (_firstEntry$split$pop = _firstEntry$split$pop.split(\"?\")) == null || (_firstEntry$split$pop = _firstEntry$split$pop.shift()) == null ? void 0 : _firstEntry$split$pop.toLowerCase();\n    return {\n        extension,\n        isCubemap,\n        isGainmap\n    };\n}\nfunction getLoader(extension) {\n    const loader = extension === \"cube\" ? three__WEBPACK_IMPORTED_MODULE_3__.CubeTextureLoader : extension === \"hdr\" ? three_stdlib__WEBPACK_IMPORTED_MODULE_5__.RGBELoader : extension === \"exr\" ? three_stdlib__WEBPACK_IMPORTED_MODULE_6__.EXRLoader : extension === \"jpg\" || extension === \"jpeg\" ? _monogrid_gainmap_js__WEBPACK_IMPORTED_MODULE_7__.HDRJPGLoader : extension === \"webp\" ? _monogrid_gainmap_js__WEBPACK_IMPORTED_MODULE_7__.GainMapLoader : null;\n    return loader;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VFbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQzBDO0FBQzlDO0FBQ2M7QUFDTDtBQUNVO0FBQ2hDO0FBRXhDLE1BQU1hLGVBQWU7QUFDckIsTUFBTUMsVUFBVUMsQ0FBQUEsTUFBT0MsTUFBTUYsT0FBTyxDQUFDQztBQUNyQyxNQUFNRSxlQUFlO0lBQUM7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0NBQVU7QUFDdkYsU0FBU0MsZUFBZSxFQUN0QkMsUUFBUUYsWUFBWSxFQUNwQkcsT0FBTyxFQUFFLEVBQ1RDLFNBQVNDLFNBQVMsRUFDbEJDLFdBQVdELFNBQVMsRUFDcEJFLFVBQVUsRUFDWCxHQUFHLENBQUMsQ0FBQztJQUNKLElBQUlDLFNBQVM7SUFDYixJQUFJQyxZQUFZO0lBQ2hCLElBQUlMLFFBQVE7UUFDVk0sZUFBZU47UUFDZkYsUUFBUVYsc0VBQVUsQ0FBQ1ksT0FBTztRQUMxQkQsT0FBT1A7SUFDVDtJQUVBLGtCQUFrQjtJQUNsQmEsWUFBWVosUUFBUUs7SUFDcEIsTUFBTSxFQUNKUyxTQUFTLEVBQ1RDLFNBQVMsRUFDVixHQUFHQyxhQUFhWDtJQUNqQk0sU0FBU00sVUFBVUg7SUFDbkIsSUFBSSxDQUFDSCxRQUFRLE1BQU0sSUFBSU8sTUFBTSxrREFBa0RiO0lBQy9FLE1BQU1jLEtBQUtqQyxxREFBUUEsQ0FBQ2tDLENBQUFBLFFBQVNBLE1BQU1ELEVBQUU7SUFDckNyQixzREFBZUEsQ0FBQztRQUNkLDRCQUE0QjtRQUM1QixJQUFJZ0IsY0FBYyxVQUFVQSxjQUFjLFNBQVNBLGNBQWMsUUFBUTtRQUN6RSxTQUFTTztZQUNQbEMsaURBQVNBLENBQUNtQyxLQUFLLENBQ2YsbUJBQW1CO1lBQ25CWCxRQUFRQyxZQUFZO2dCQUFDUDthQUFNLEdBQUdBO1FBQ2hDO1FBQ0FjLEdBQUdJLFVBQVUsQ0FBQ0MsZ0JBQWdCLENBQUMsb0JB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LG9EQUFpQkEsR0FBR3dCLGNBQWMsUUFBUXZCLG9EQUFVQSxHQUFHdUIsY0FBYyxRQUFRdEIsbURBQVNBLEdBQUdzQixjQUFjLFNBQVNBLGNBQWMsU0FBU3JCLDhEQUFZQSxHQUFHcUIsY0FBYyxTQUFTcEIsK0RBQWFBLEdBQUc7SUFDbk8sT0FBT2lCO0FBQ1Q7QUFFMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yb2NrZXRzaW0vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VFbnZpcm9ubWVudC5qcz83MGM5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVRocmVlLCB1c2VMb2FkZXIgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLCBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZywgQ3ViZVRleHR1cmVMb2FkZXIgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBSR0JFTG9hZGVyLCBFWFJMb2FkZXIgfSBmcm9tICd0aHJlZS1zdGRsaWInO1xuaW1wb3J0IHsgSERSSlBHTG9hZGVyLCBHYWluTWFwTG9hZGVyIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnO1xuaW1wb3J0IHsgcHJlc2V0c09iaiB9IGZyb20gJy4uL2hlbHBlcnMvZW52aXJvbm1lbnQtYXNzZXRzLmpzJztcbmltcG9ydCB7IHNSR0JFbmNvZGluZywgTGluZWFyRW5jb2RpbmcgfSBmcm9tICcuLi9oZWxwZXJzL2RlcHJlY2F0ZWQuanMnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBDVUJFTUFQX1JPT1QgPSAnaHR0cHM6Ly9yYXcuZ2l0aGFjay5jb20vcG1uZHJzL2RyZWktYXNzZXRzLzQ1NjA2MGEyNmJiZWI4ZmRmNzkzMjZmMjI0YjZkOTliOGJjY2U3MzYvaGRyaS8nO1xuY29uc3QgaXNBcnJheSA9IGFyciA9PiBBcnJheS5pc0FycmF5KGFycik7XG5jb25zdCBkZWZhdWx0RmlsZXMgPSBbJy9weC5wbmcnLCAnL254LnBuZycsICcvcHkucG5nJywgJy9ueS5wbmcnLCAnL3B6LnBuZycsICcvbnoucG5nJ107XG5mdW5jdGlvbiB1c2VFbnZpcm9ubWVudCh7XG4gIGZpbGVzID0gZGVmYXVsdEZpbGVzLFxuICBwYXRoID0gJycsXG4gIHByZXNldCA9IHVuZGVmaW5lZCxcbiAgZW5jb2RpbmcgPSB1bmRlZmluZWQsXG4gIGV4dGVuc2lvbnNcbn0gPSB7fSkge1xuICBsZXQgbG9hZGVyID0gbnVsbDtcbiAgbGV0IG11bHRpRmlsZSA9IGZhbHNlO1xuICBpZiAocHJlc2V0KSB7XG4gICAgdmFsaWRhdGVQcmVzZXQocHJlc2V0KTtcbiAgICBmaWxlcyA9IHByZXNldHNPYmpbcHJlc2V0XTtcbiAgICBwYXRoID0gQ1VCRU1BUF9ST09UO1xuICB9XG5cbiAgLy8gRXZlcnl0aGluZyBlbHNlXG4gIG11bHRpRmlsZSA9IGlzQXJyYXkoZmlsZXMpO1xuICBjb25zdCB7XG4gICAgZXh0ZW5zaW9uLFxuICAgIGlzQ3ViZW1hcFxuICB9ID0gZ2V0RXh0ZW5zaW9uKGZpbGVzKTtcbiAgbG9hZGVyID0gZ2V0TG9hZGVyKGV4dGVuc2lvbik7XG4gIGlmICghbG9hZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ3VzZUVudmlyb25tZW50OiBVbnJlY29nbml6ZWQgZmlsZSBleHRlbnNpb246ICcgKyBmaWxlcyk7XG4gIGNvbnN0IGdsID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuZ2wpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIC8vIE9ubHkgcmVxdWlyZWQgZm9yIGdhaW5tYXBcbiAgICBpZiAoZXh0ZW5zaW9uICE9PSAnd2VicCcgJiYgZXh0ZW5zaW9uICE9PSAnanBnJyAmJiBleHRlbnNpb24gIT09ICdqcGVnJykgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGNsZWFyR2Fpbm1hcFRleHR1cmUoKSB7XG4gICAgICB1c2VMb2FkZXIuY2xlYXIoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBsb2FkZXIsIG11bHRpRmlsZSA/IFtmaWxlc10gOiBmaWxlcyk7XG4gICAgfVxuICAgIGdsLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIGNsZWFyR2Fpbm1hcFRleHR1cmUsIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgfSwgW2ZpbGVzLCBnbC5kb21FbGVtZW50XSk7XG4gIGNvbnN0IGxvYWRlclJlc3VsdCA9IHVzZUxvYWRlcihcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBsb2FkZXIsIG11bHRpRmlsZSA/IFtmaWxlc10gOiBmaWxlcywgbG9hZGVyID0+IHtcbiAgICAvLyBHYWlubWFwIHJlcXVpcmVzIGEgcmVuZGVyZXJcbiAgICBpZiAoZXh0ZW5zaW9uID09PSAnd2VicCcgfHwgZXh0ZW5zaW9uID09PSAnanBnJyB8fCBleHRlbnNpb24gPT09ICdqcGVnJykge1xuICAgICAgbG9hZGVyLnNldFJlbmRlcmVyKGdsKTtcbiAgICB9XG4gICAgbG9hZGVyLnNldFBhdGggPT0gbnVsbCB8fCBsb2FkZXIuc2V0UGF0aChwYXRoKTtcbiAgICBpZiAoZXh0ZW5zaW9ucykgZXh0ZW5zaW9ucyhsb2FkZXIpO1xuICB9KTtcbiAgbGV0IHRleHR1cmUgPSBtdWx0aUZpbGUgP1xuICAvLyBAdHMtaWdub3JlXG4gIGxvYWRlclJlc3VsdFswXSA6IGxvYWRlclJlc3VsdDtcbiAgaWYgKGV4dGVuc2lvbiA9PT0gJ2pwZycgfHwgZXh0ZW5zaW9uID09PSAnanBlZycgfHwgZXh0ZW5zaW9uID09PSAnd2VicCcpIHtcbiAgICB2YXIgX3JlbmRlclRhcmdldDtcbiAgICB0ZXh0dXJlID0gKF9yZW5kZXJUYXJnZXQgPSB0ZXh0dXJlLnJlbmRlclRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICB0ZXh0dXJlLm1hcHBpbmcgPSBpc0N1YmVtYXAgPyBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgOiBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZztcbiAgaWYgKCdjb2xvclNwYWNlJyBpbiB0ZXh0dXJlKSB0ZXh0dXJlLmNvbG9yU3BhY2UgPSAoZW5jb2RpbmcgIT09IG51bGwgJiYgZW5jb2RpbmcgIT09IHZvaWQgMCA/IGVuY29kaW5nIDogaXNDdWJlbWFwKSA/ICdzcmdiJyA6ICdzcmdiLWxpbmVhcic7ZWxzZSB0ZXh0dXJlLmVuY29kaW5nID0gKGVuY29kaW5nICE9PSBudWxsICYmIGVuY29kaW5nICE9PSB2b2lkIDAgPyBlbmNvZGluZyA6IGlzQ3ViZW1hcCkgPyBzUkdCRW5jb2RpbmcgOiBMaW5lYXJFbmNvZGluZztcbiAgcmV0dXJuIHRleHR1cmU7XG59XG5jb25zdCBwcmVsb2FkRGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZpbGVzOiBkZWZhdWx0RmlsZXMsXG4gIHBhdGg6ICcnLFxuICBwcmVzZXQ6IHVuZGVmaW5lZCxcbiAgZXh0ZW5zaW9uczogdW5kZWZpbmVkXG59O1xudXNlRW52aXJvbm1lbnQucHJlbG9hZCA9IHByZWxvYWRPcHRpb25zID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5wcmVsb2FkRGVmYXVsdE9wdGlvbnMsXG4gICAgLi4ucHJlbG9hZE9wdGlvbnNcbiAgfTtcbiAgbGV0IHtcbiAgICBmaWxlcyxcbiAgICBwYXRoID0gJydcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHtcbiAgICBwcmVzZXQsXG4gICAgZXh0ZW5zaW9uc1xuICB9ID0gb3B0aW9ucztcbiAgaWYgKHByZXNldCkge1xuICAgIHZhbGlkYXRlUHJlc2V0KHByZXNldCk7XG4gICAgZmlsZXMgPSBwcmVzZXRzT2JqW3ByZXNldF07XG4gICAgcGF0aCA9IENVQkVNQVBfUk9PVDtcbiAgfVxuICBjb25zdCB7XG4gICAgZXh0ZW5zaW9uXG4gIH0gPSBnZXRFeHRlbnNpb24oZmlsZXMpO1xuICBpZiAoZXh0ZW5zaW9uID09PSAnd2VicCcgfHwgZXh0ZW5zaW9uID09PSAnanBnJyB8fCBleHRlbnNpb24gPT09ICdqcGVnJykge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlRW52aXJvbm1lbnQ6IFByZWxvYWRpbmcgZ2Fpbm1hcHMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG4gIGNvbnN0IGxvYWRlciA9IGdldExvYWRlcihleHRlbnNpb24pO1xuICBpZiAoIWxvYWRlcikgdGhyb3cgbmV3IEVycm9yKCd1c2VFbnZpcm9ubWVudDogVW5yZWNvZ25pemVkIGZpbGUgZXh0ZW5zaW9uOiAnICsgZmlsZXMpO1xuICB1c2VMb2FkZXIucHJlbG9hZChcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBsb2FkZXIsIGlzQXJyYXkoZmlsZXMpID8gW2ZpbGVzXSA6IGZpbGVzLCBsb2FkZXIgPT4ge1xuICAgIGxvYWRlci5zZXRQYXRoID09IG51bGwgfHwgbG9hZGVyLnNldFBhdGgocGF0aCk7XG4gICAgaWYgKGV4dGVuc2lvbnMpIGV4dGVuc2lvbnMobG9hZGVyKTtcbiAgfSk7XG59O1xuY29uc3QgY2xlYXJEZWZhdWx0T3B0aW5zID0ge1xuICBmaWxlczogZGVmYXVsdEZpbGVzLFxuICBwcmVzZXQ6IHVuZGVmaW5lZFxufTtcbnVzZUVudmlyb25tZW50LmNsZWFyID0gY2xlYXJPcHRpb25zID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5jbGVhckRlZmF1bHRPcHRpbnMsXG4gICAgLi4uY2xlYXJPcHRpb25zXG4gIH07XG4gIGxldCB7XG4gICAgZmlsZXNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHtcbiAgICBwcmVzZXRcbiAgfSA9IG9wdGlvbnM7XG4gIGlmIChwcmVzZXQpIHtcbiAgICB2YWxpZGF0ZVByZXNldChwcmVzZXQpO1xuICAgIGZpbGVzID0gcHJlc2V0c09ialtwcmVzZXRdO1xuICB9XG4gIGNvbnN0IHtcbiAgICBleHRlbnNpb25cbiAgfSA9IGdldEV4dGVuc2lvbihmaWxlcyk7XG4gIGNvbnN0IGxvYWRlciA9IGdldExvYWRlcihleHRlbnNpb24pO1xuICBpZiAoIWxvYWRlcikgdGhyb3cgbmV3IEVycm9yKCd1c2VFbnZpcm9ubWVudDogVW5yZWNvZ25pemVkIGZpbGUgZXh0ZW5zaW9uOiAnICsgZmlsZXMpO1xuICB1c2VMb2FkZXIuY2xlYXIoXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgbG9hZGVyLCBpc0FycmF5KGZpbGVzKSA/IFtmaWxlc10gOiBmaWxlcyk7XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVQcmVzZXQocHJlc2V0KSB7XG4gIGlmICghKHByZXNldCBpbiBwcmVzZXRzT2JqKSkgdGhyb3cgbmV3IEVycm9yKCdQcmVzZXQgbXVzdCBiZSBvbmUgb2Y6ICcgKyBPYmplY3Qua2V5cyhwcmVzZXRzT2JqKS5qb2luKCcsICcpKTtcbn1cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbihmaWxlcykge1xuICB2YXIgX2ZpcnN0RW50cnkkc3BsaXQkcG9wO1xuICBjb25zdCBpc0N1YmVtYXAgPSBpc0FycmF5KGZpbGVzKSAmJiBmaWxlcy5sZW5ndGggPT09IDY7XG4gIGNvbnN0IGlzR2Fpbm1hcCA9IGlzQXJyYXkoZmlsZXMpICYmIGZpbGVzLmxlbmd0aCA9PT0gMyAmJiBmaWxlcy5zb21lKGZpbGUgPT4gZmlsZS5lbmRzV2l0aCgnanNvbicpKTtcbiAgY29uc3QgZmlyc3RFbnRyeSA9IGlzQXJyYXkoZmlsZXMpID8gZmlsZXNbMF0gOiBmaWxlcztcblxuICAvLyBFdmVyeXRoaW5nIGVsc2VcbiAgY29uc3QgZXh0ZW5zaW9uID0gaXNDdWJlbWFwID8gJ2N1YmUnIDogaXNHYWlubWFwID8gJ3dlYnAnIDogZmlyc3RFbnRyeS5zdGFydHNXaXRoKCdkYXRhOmFwcGxpY2F0aW9uL2V4cicpID8gJ2V4cicgOiBmaXJzdEVudHJ5LnN0YXJ0c1dpdGgoJ2RhdGE6YXBwbGljYXRpb24vaGRyJykgPyAnaGRyJyA6IGZpcnN0RW50cnkuc3RhcnRzV2l0aCgnZGF0YTppbWFnZS9qcGVnJykgPyAnanBnJyA6IChfZmlyc3RFbnRyeSRzcGxpdCRwb3AgPSBmaXJzdEVudHJ5LnNwbGl0KCcuJykucG9wKCkpID09IG51bGwgfHwgKF9maXJzdEVudHJ5JHNwbGl0JHBvcCA9IF9maXJzdEVudHJ5JHNwbGl0JHBvcC5zcGxpdCgnPycpKSA9PSBudWxsIHx8IChfZmlyc3RFbnRyeSRzcGxpdCRwb3AgPSBfZmlyc3RFbnRyeSRzcGxpdCRwb3Auc2hpZnQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9maXJzdEVudHJ5JHNwbGl0JHBvcC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4ge1xuICAgIGV4dGVuc2lvbixcbiAgICBpc0N1YmVtYXAsXG4gICAgaXNHYWlubWFwXG4gIH07XG59XG5mdW5jdGlvbiBnZXRMb2FkZXIoZXh0ZW5zaW9uKSB7XG4gIGNvbnN0IGxvYWRlciA9IGV4dGVuc2lvbiA9PT0gJ2N1YmUnID8gQ3ViZVRleHR1cmVMb2FkZXIgOiBleHRlbnNpb24gPT09ICdoZHInID8gUkdCRUxvYWRlciA6IGV4dGVuc2lvbiA9PT0gJ2V4cicgPyBFWFJMb2FkZXIgOiBleHRlbnNpb24gPT09ICdqcGcnIHx8IGV4dGVuc2lvbiA9PT0gJ2pwZWcnID8gSERSSlBHTG9hZGVyIDogZXh0ZW5zaW9uID09PSAnd2VicCcgPyBHYWluTWFwTG9hZGVyIDogbnVsbDtcbiAgcmV0dXJuIGxvYWRlcjtcbn1cblxuZXhwb3J0IHsgdXNlRW52aXJvbm1lbnQgfTtcbiJdLCJuYW1lcyI6WyJ1c2VUaHJlZSIsInVzZUxvYWRlciIsIkN1YmVSZWZsZWN0aW9uTWFwcGluZyIsIkVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nIiwiQ3ViZVRleHR1cmVMb2FkZXIiLCJSR0JFTG9hZGVyIiwiRVhSTG9hZGVyIiwiSERSSlBHTG9hZGVyIiwiR2Fpbk1hcExvYWRlciIsInByZXNldHNPYmoiLCJzUkdCRW5jb2RpbmciLCJMaW5lYXJFbmNvZGluZyIsInVzZUxheW91dEVmZmVjdCIsIkNVQkVNQVBfUk9PVCIsImlzQXJyYXkiLCJhcnIiLCJBcnJheSIsImRlZmF1bHRGaWxlcyIsInVzZUVudmlyb25tZW50IiwiZmlsZXMiLCJwYXRoIiwicHJlc2V0IiwidW5kZWZpbmVkIiwiZW5jb2RpbmciLCJleHRlbnNpb25zIiwibG9hZGVyIiwibXVsdGlGaWxlIiwidmFsaWRhdGVQcmVzZXQiLCJleHRlbnNpb24iLCJpc0N1YmVtYXAiLCJnZXRFeHRlbnNpb24iLCJnZXRMb2FkZXIiLCJFcnJvciIsImdsIiwic3RhdGUiLCJjbGVhckdhaW5tYXBUZXh0dXJlIiwiY2xlYXIiLCJkb21FbGVtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJsb2FkZXJSZXN1bHQiLCJzZXRSZW5kZXJlciIsInNldFBhdGgiLCJ0ZXh0dXJlIiwiX3JlbmRlclRhcmdldCIsInJlbmRlclRhcmdldCIsIm1hcHBpbmciLCJjb2xvclNwYWNlIiwicHJlbG9hZERlZmF1bHRPcHRpb25zIiwicHJlbG9hZCIsInByZWxvYWRPcHRpb25zIiwib3B0aW9ucyIsImNsZWFyRGVmYXVsdE9wdGlucyIsImNsZWFyT3B0aW9ucyIsIk9iamVjdCIsImtleXMiLCJqb2luIiwiX2ZpcnN0RW50cnkkc3BsaXQkcG9wIiwibGVuZ3RoIiwiaXNHYWlubWFwIiwic29tZSIsImZpbGUiLCJlbmRzV2l0aCIsImZpcnN0RW50cnkiLCJzdGFydHNXaXRoIiwic3BsaXQiLCJwb3AiLCJzaGlmdCIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst getVersion = ()=>parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\nconst version = /* @__PURE__ */ getVersion();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFFakMsTUFBTUMsYUFBYSxJQUFNQyxTQUFTRiwyQ0FBUUEsQ0FBQ0csT0FBTyxDQUFDLFFBQVE7QUFDM0QsTUFBTUMsVUFBVSxhQUFhLEdBQUVIO0FBRVoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yb2NrZXRzaW0vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9jb25zdGFudHMuanM/NTA5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSRVZJU0lPTiB9IGZyb20gJ3RocmVlJztcblxuY29uc3QgZ2V0VmVyc2lvbiA9ICgpID0+IHBhcnNlSW50KFJFVklTSU9OLnJlcGxhY2UoL1xcRCsvZywgJycpKTtcbmNvbnN0IHZlcnNpb24gPSAvKiBAX19QVVJFX18gKi9nZXRWZXJzaW9uKCk7XG5cbmV4cG9ydCB7IHZlcnNpb24gfTtcbiJdLCJuYW1lcyI6WyJSRVZJU0lPTiIsImdldFZlcnNpb24iLCJwYXJzZUludCIsInJlcGxhY2UiLCJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/deprecated.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/deprecated.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinearEncoding: () => (/* binding */ LinearEncoding),\n/* harmony export */   sRGBEncoding: () => (/* binding */ sRGBEncoding),\n/* harmony export */   setUpdateRange: () => (/* binding */ setUpdateRange)\n/* harmony export */ });\n/**\n * Sets `BufferAttribute.updateRange` since r159.\n */ const setUpdateRange = (attribute, updateRange)=>{\n    if (\"updateRanges\" in attribute) {\n        // r159\n        // @ts-ignore\n        attribute.updateRanges[0] = updateRange;\n    } else {\n        attribute.updateRange = updateRange;\n    }\n};\nconst LinearEncoding = 3000;\nconst sRGBEncoding = 3001;\n/**\n * TextureEncoding was deprecated in r152, and removed in r162.\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9kZXByZWNhdGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztDQUVDLEdBQ0QsTUFBTUEsaUJBQWlCLENBQUNDLFdBQVdDO0lBQ2pDLElBQUksa0JBQWtCRCxXQUFXO1FBQy9CLE9BQU87UUFDUCxhQUFhO1FBQ2JBLFVBQVVFLFlBQVksQ0FBQyxFQUFFLEdBQUdEO0lBQzlCLE9BQU87UUFDTEQsVUFBVUMsV0FBVyxHQUFHQTtJQUMxQjtBQUNGO0FBQ0EsTUFBTUUsaUJBQWlCO0FBQ3ZCLE1BQU1DLGVBQWU7QUFFckI7O0NBRUMsR0FFdUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yb2NrZXRzaW0vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9kZXByZWNhdGVkLmpzP2UwMDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTZXRzIGBCdWZmZXJBdHRyaWJ1dGUudXBkYXRlUmFuZ2VgIHNpbmNlIHIxNTkuXG4gKi9cbmNvbnN0IHNldFVwZGF0ZVJhbmdlID0gKGF0dHJpYnV0ZSwgdXBkYXRlUmFuZ2UpID0+IHtcbiAgaWYgKCd1cGRhdGVSYW5nZXMnIGluIGF0dHJpYnV0ZSkge1xuICAgIC8vIHIxNTlcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYXR0cmlidXRlLnVwZGF0ZVJhbmdlc1swXSA9IHVwZGF0ZVJhbmdlO1xuICB9IGVsc2Uge1xuICAgIGF0dHJpYnV0ZS51cGRhdGVSYW5nZSA9IHVwZGF0ZVJhbmdlO1xuICB9XG59O1xuY29uc3QgTGluZWFyRW5jb2RpbmcgPSAzMDAwO1xuY29uc3Qgc1JHQkVuY29kaW5nID0gMzAwMTtcblxuLyoqXG4gKiBUZXh0dXJlRW5jb2Rpbmcgd2FzIGRlcHJlY2F0ZWQgaW4gcjE1MiwgYW5kIHJlbW92ZWQgaW4gcjE2Mi5cbiAqL1xuXG5leHBvcnQgeyBMaW5lYXJFbmNvZGluZywgc1JHQkVuY29kaW5nLCBzZXRVcGRhdGVSYW5nZSB9O1xuIl0sIm5hbWVzIjpbInNldFVwZGF0ZVJhbmdlIiwiYXR0cmlidXRlIiwidXBkYXRlUmFuZ2UiLCJ1cGRhdGVSYW5nZXMiLCJMaW5lYXJFbmNvZGluZyIsInNSR0JFbmNvZGluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/deprecated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/environment-assets.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   presetsObj: () => (/* binding */ presetsObj)\n/* harmony export */ });\nconst presetsObj = {\n    apartment: \"lebombo_1k.hdr\",\n    city: \"potsdamer_platz_1k.hdr\",\n    dawn: \"kiara_1_dawn_1k.hdr\",\n    forest: \"forest_slope_1k.hdr\",\n    lobby: \"st_fagans_interior_1k.hdr\",\n    night: \"dikhololo_night_1k.hdr\",\n    park: \"rooitou_park_1k.hdr\",\n    studio: \"studio_small_03_1k.hdr\",\n    sunset: \"venice_sunset_1k.hdr\",\n    warehouse: \"empty_warehouse_01_1k.hdr\"\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9lbnZpcm9ubWVudC1hc3NldHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGFBQWE7SUFDakJDLFdBQVc7SUFDWEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFdBQVc7QUFDYjtBQUVzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JvY2tldHNpbS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9oZWxwZXJzL2Vudmlyb25tZW50LWFzc2V0cy5qcz8xNjUxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHByZXNldHNPYmogPSB7XG4gIGFwYXJ0bWVudDogJ2xlYm9tYm9fMWsuaGRyJyxcbiAgY2l0eTogJ3BvdHNkYW1lcl9wbGF0el8xay5oZHInLFxuICBkYXduOiAna2lhcmFfMV9kYXduXzFrLmhkcicsXG4gIGZvcmVzdDogJ2ZvcmVzdF9zbG9wZV8xay5oZHInLFxuICBsb2JieTogJ3N0X2ZhZ2Fuc19pbnRlcmlvcl8xay5oZHInLFxuICBuaWdodDogJ2Rpa2hvbG9sb19uaWdodF8xay5oZHInLFxuICBwYXJrOiAncm9vaXRvdV9wYXJrXzFrLmhkcicsXG4gIHN0dWRpbzogJ3N0dWRpb19zbWFsbF8wM18xay5oZHInLFxuICBzdW5zZXQ6ICd2ZW5pY2Vfc3Vuc2V0XzFrLmhkcicsXG4gIHdhcmVob3VzZTogJ2VtcHR5X3dhcmVob3VzZV8wMV8xay5oZHInXG59O1xuXG5leHBvcnQgeyBwcmVzZXRzT2JqIH07XG4iXSwibmFtZXMiOlsicHJlc2V0c09iaiIsImFwYXJ0bWVudCIsImNpdHkiLCJkYXduIiwiZm9yZXN0IiwibG9iYnkiLCJuaWdodCIsInBhcmsiLCJzdHVkaW8iLCJzdW5zZXQiLCJ3YXJlaG91c2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/index-8afac004.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useThree),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useFrame),\n/* harmony export */   D: () => (/* binding */ useGraph),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   F: () => (/* binding */ useLoader),\n/* harmony export */   a: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   b: () => (/* binding */ createRoot),\n/* harmony export */   c: () => (/* binding */ createEvents),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ context),\n/* harmony export */   g: () => (/* binding */ createPortal),\n/* harmony export */   h: () => (/* binding */ reconciler),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ applyProps),\n/* harmony export */   k: () => (/* binding */ dispose),\n/* harmony export */   l: () => (/* binding */ invalidate),\n/* harmony export */   m: () => (/* binding */ advance),\n/* harmony export */   n: () => (/* binding */ addEffect),\n/* harmony export */   o: () => (/* binding */ addAfterEffect),\n/* harmony export */   p: () => (/* binding */ addTail),\n/* harmony export */   q: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   r: () => (/* binding */ render),\n/* harmony export */   s: () => (/* binding */ getRootState),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useMutableCallback),\n/* harmony export */   v: () => (/* binding */ act),\n/* harmony export */   w: () => (/* binding */ buildGraph),\n/* harmony export */   x: () => (/* binding */ roots),\n/* harmony export */   y: () => (/* binding */ useInstanceHandle),\n/* harmony export */   z: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/esm/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst catalogue = {};\nconst extend = (objects)=>void Object.assign(catalogue, objects);\nfunction createRenderer(_roots, _getEventPriority) {\n    function createInstance(type, { args = [], attach, ...props }, root) {\n        let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n        let instance;\n        if (type === \"primitive\") {\n            if (props.object === undefined) throw new Error(\"R3F: Primitives without 'object' are invalid!\");\n            const object = props.object;\n            instance = prepare(object, {\n                type,\n                root,\n                attach,\n                primitive: true\n            });\n        } else {\n            const target = catalogue[name];\n            if (!target) {\n                throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n            }\n            // Throw if an object or literal was passed for args\n            if (!Array.isArray(args)) throw new Error(\"R3F: The args prop must be an array!\");\n            // Instanciate new object, link it to the root\n            // Append memoized props with args so it's not forgotten\n            instance = prepare(new target(...args), {\n                type,\n                root,\n                attach,\n                // Save args in case we need to reconstruct later for HMR\n                memoizedProps: {\n                    args\n                }\n            });\n        }\n        // Auto-attach geometries and materials\n        if (instance.__r3f.attach === undefined) {\n            if (instance instanceof three__WEBPACK_IMPORTED_MODULE_4__.BufferGeometry) instance.__r3f.attach = \"geometry\";\n            else if (instance instanceof three__WEBPACK_IMPORTED_MODULE_4__.Material) instance.__r3f.attach = \"material\";\n        }\n        // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n        // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n        // why it passes \"true\" here\n        // There is no reason to apply props to injects\n        if (name !== \"inject\") applyProps$1(instance, props);\n        return instance;\n    }\n    function appendChild(parentInstance, child) {\n        let added = false;\n        if (child) {\n            var _child$__r3f, _parentInstance$__r3f;\n            // The attach attribute implies that the object attaches itself on the parent\n            if ((_child$__r3f = child.__r3f) != null && _child$__r3f.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                // add in the usual parent-child way\n                parentInstance.add(child);\n                added = true;\n            }\n            // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n            // that is, anything that's a child in React but not a child in the scenegraph.\n            if (!added) (_parentInstance$__r3f = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function insertBefore(parentInstance, child, beforeChild) {\n        let added = false;\n        if (child) {\n            var _child$__r3f2, _parentInstance$__r3f2;\n            if ((_child$__r3f2 = child.__r3f) != null && _child$__r3f2.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                child.parent = parentInstance;\n                child.dispatchEvent({\n                    type: \"added\"\n                });\n                const restSiblings = parentInstance.children.filter((sibling)=>sibling !== child);\n                const index = restSiblings.indexOf(beforeChild);\n                parentInstance.children = [\n                    ...restSiblings.slice(0, index),\n                    child,\n                    ...restSiblings.slice(index)\n                ];\n                added = true;\n            }\n            if (!added) (_parentInstance$__r3f2 = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f2.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function removeRecursive(array, parent, dispose = false) {\n        if (array) [\n            ...array\n        ].forEach((child)=>removeChild(parent, child, dispose));\n    }\n    function removeChild(parentInstance, child, dispose) {\n        if (child) {\n            var _parentInstance$__r3f3, _child$__r3f3, _child$__r3f5;\n            // Clear the parent reference\n            if (child.__r3f) child.__r3f.parent = null;\n            // Remove child from the parents objects\n            if ((_parentInstance$__r3f3 = parentInstance.__r3f) != null && _parentInstance$__r3f3.objects) parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter((x)=>x !== child);\n            // Remove attachment\n            if ((_child$__r3f3 = child.__r3f) != null && _child$__r3f3.attach) {\n                detach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                var _child$__r3f4;\n                parentInstance.remove(child);\n                // @ts-ignore\n                // Remove interactivity on the initial root\n                if ((_child$__r3f4 = child.__r3f) != null && _child$__r3f4.root) {\n                    removeInteractivity(findInitialRoot(child), child);\n                }\n            }\n            // Allow objects to bail out of recursive dispose altogether by passing dispose={null}\n            // Never dispose of primitives because their state may be kept outside of React!\n            // In order for an object to be able to dispose it has to have\n            //   - a dispose method,\n            //   - it cannot be a <primitive object={...} />\n            //   - it cannot be a THREE.Scene, because three has broken it's own api\n            //\n            // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n            // when the reconciler calls it, but then carry our own check recursively\n            const isPrimitive = (_child$__r3f5 = child.__r3f) == null ? void 0 : _child$__r3f5.primitive;\n            const shouldDispose = !isPrimitive && (dispose === undefined ? child.dispose !== null : dispose);\n            // Remove nested child objects. Primitives should not have objects and children that are\n            // attached to them declaratively ...\n            if (!isPrimitive) {\n                var _child$__r3f6;\n                removeRecursive((_child$__r3f6 = child.__r3f) == null ? void 0 : _child$__r3f6.objects, child, shouldDispose);\n                removeRecursive(child.children, child, shouldDispose);\n            }\n            // Remove references\n            delete child.__r3f;\n            // Dispose item whenever the reconciler feels like it\n            if (shouldDispose && child.dispose && child.type !== \"Scene\") {\n                const callback = ()=>{\n                    try {\n                        child.dispose();\n                    } catch (e) {\n                    /* ... */ }\n                };\n                // Schedule async at runtime, flush sync in testing\n                if (typeof IS_REACT_ACT_ENVIRONMENT === \"undefined\") {\n                    (0,scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_IdlePriority, callback);\n                } else {\n                    callback();\n                }\n            }\n            invalidateInstance(parentInstance);\n        }\n    }\n    function switchInstance(instance, type, newProps, fiber) {\n        var _instance$__r3f;\n        const parent = (_instance$__r3f = instance.__r3f) == null ? void 0 : _instance$__r3f.parent;\n        if (!parent) return;\n        const newInstance = createInstance(type, newProps, instance.__r3f.root);\n        // https://github.com/pmndrs/react-three-fiber/issues/1348\n        // When args change the instance has to be re-constructed, which then\n        // forces r3f to re-parent the children and non-scene objects\n        if (instance.children) {\n            for (const child of instance.children){\n                if (child.__r3f) appendChild(newInstance, child);\n            }\n            instance.children = instance.children.filter((child)=>!child.__r3f);\n        }\n        instance.__r3f.objects.forEach((child)=>appendChild(newInstance, child));\n        instance.__r3f.objects = [];\n        if (!instance.__r3f.autoRemovedBeforeAppend) {\n            removeChild(parent, instance);\n        }\n        if (newInstance.parent) {\n            newInstance.__r3f.autoRemovedBeforeAppend = true;\n        }\n        appendChild(parent, newInstance);\n        // Re-bind event handlers on the initial root\n        if (newInstance.raycast && newInstance.__r3f.eventCount) {\n            const rootState = findInitialRoot(newInstance).getState();\n            rootState.internal.interaction.push(newInstance);\n        }\n        [\n            fiber,\n            fiber.alternate\n        ].forEach((fiber)=>{\n            if (fiber !== null) {\n                fiber.stateNode = newInstance;\n                if (fiber.ref) {\n                    if (typeof fiber.ref === \"function\") fiber.ref(newInstance);\n                    else fiber.ref.current = newInstance;\n                }\n            }\n        });\n    }\n    // Don't handle text instances, warn on undefined behavior\n    const handleTextInstance = ()=>console.warn(\"Text is not allowed in the R3F tree! This could be stray whitespace or characters.\");\n    const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_2___default()({\n        createInstance,\n        removeChild,\n        appendChild,\n        appendInitialChild: appendChild,\n        insertBefore,\n        supportsMutation: true,\n        isPrimaryRenderer: false,\n        supportsPersistence: false,\n        supportsHydration: false,\n        noTimeout: -1,\n        appendChildToContainer: (container, child)=>{\n            if (!child) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            // Link current root to the default scene\n            scene.__r3f.root = container;\n            appendChild(scene, child);\n        },\n        removeChildFromContainer: (container, child)=>{\n            if (!child) return;\n            removeChild(container.getState().scene, child);\n        },\n        insertInContainerBefore: (container, child, beforeChild)=>{\n            if (!child || !beforeChild) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            insertBefore(scene, child, beforeChild);\n        },\n        getRootHostContext: ()=>null,\n        getChildHostContext: (parentHostContext)=>parentHostContext,\n        finalizeInitialChildren (instance) {\n            var _instance$__r3f2;\n            const localState = (_instance$__r3f2 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f2 : {};\n            // https://github.com/facebook/react/issues/20271\n            // Returning true will trigger commitMount\n            return Boolean(localState.handlers);\n        },\n        prepareUpdate (instance, _type, oldProps, newProps) {\n            var _instance$__r3f3;\n            const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n            // Create diff-sets\n            if (localState.primitive && newProps.object && newProps.object !== instance) {\n                return [\n                    true\n                ];\n            } else {\n                // This is a data object, let's extract critical information about it\n                const { args: argsNew = [], children: cN, ...restNew } = newProps;\n                const { args: argsOld = [], children: cO, ...restOld } = oldProps;\n                // Throw if an object or literal was passed for args\n                if (!Array.isArray(argsNew)) throw new Error(\"R3F: the args prop must be an array!\");\n                // If it has new props or arguments, then it needs to be re-instantiated\n                if (argsNew.some((value, index)=>value !== argsOld[index])) return [\n                    true\n                ];\n                // Create a diff-set, flag if there are any changes\n                const diff = diffProps(instance, restNew, restOld, true);\n                if (diff.changes.length) return [\n                    false,\n                    diff\n                ];\n                // Otherwise do not touch the instance\n                return null;\n            }\n        },\n        commitUpdate (instance, [reconstruct, diff], type, _oldProps, newProps, fiber) {\n            // Reconstruct when args or <primitive object={...} have changes\n            if (reconstruct) switchInstance(instance, type, newProps, fiber);\n            else applyProps$1(instance, diff);\n        },\n        commitMount (instance, _type, _props, _int) {\n            var _instance$__r3f4;\n            // https://github.com/facebook/react/issues/20271\n            // This will make sure events are only added once to the central container on the initial root\n            const localState = (_instance$__r3f4 = instance.__r3f) != null ? _instance$__r3f4 : {};\n            if (instance.raycast && localState.handlers && localState.eventCount) {\n                findInitialRoot(instance).getState().internal.interaction.push(instance);\n            }\n        },\n        getPublicInstance: (instance)=>instance,\n        prepareForCommit: ()=>null,\n        preparePortalMount: (container)=>prepare(container.getState().scene),\n        resetAfterCommit: ()=>{},\n        shouldSetTextContent: ()=>false,\n        clearContainer: ()=>false,\n        hideInstance (instance) {\n            var _instance$__r3f5;\n            // Detach while the instance is hidden\n            const { attach: type, parent } = (_instance$__r3f5 = instance.__r3f) != null ? _instance$__r3f5 : {};\n            if (type && parent) detach(parent, instance, type);\n            if (instance.isObject3D) instance.visible = false;\n            invalidateInstance(instance);\n        },\n        unhideInstance (instance, props) {\n            var _instance$__r3f6;\n            // Re-attach when the instance is unhidden\n            const { attach: type, parent } = (_instance$__r3f6 = instance.__r3f) != null ? _instance$__r3f6 : {};\n            if (type && parent) attach(parent, instance, type);\n            if (instance.isObject3D && props.visible == null || props.visible) instance.visible = true;\n            invalidateInstance(instance);\n        },\n        createTextInstance: handleTextInstance,\n        hideTextInstance: handleTextInstance,\n        unhideTextInstance: handleTextInstance,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874\n        // @ts-ignore\n        getCurrentEventPriority: ()=>_getEventPriority ? _getEventPriority() : react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority,\n        beforeActiveInstanceBlur: ()=>{},\n        afterActiveInstanceBlur: ()=>{},\n        detachDeletedInstance: ()=>{},\n        now: typeof performance !== \"undefined\" && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : ()=>0,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503\n        scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n        cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined\n    });\n    return {\n        reconciler,\n        applyProps: applyProps$1\n    };\n}\nvar _window$document, _window$navigator;\n/**\r\n * Returns `true` with correct TS type inference if an object has a configurable color space (since r152).\r\n */ const hasColorSpace = (object)=>\"colorSpace\" in object || \"outputColorSpace\" in object;\n/**\r\n * The current THREE.ColorManagement instance, if present.\r\n */ const getColorManagement = ()=>{\n    var _ColorManagement;\n    return (_ColorManagement = catalogue.ColorManagement) != null ? _ColorManagement : null;\n};\nconst isOrthographicCamera = (def)=>def && def.isOrthographicCamera;\nconst isRef = (obj)=>obj && obj.hasOwnProperty(\"current\");\n/**\r\n * An SSR-friendly useLayoutEffect.\r\n *\r\n * React currently throws a warning when using useLayoutEffect on the server.\r\n * To get around it, we can conditionally useEffect on the server (no-op) and\r\n * useLayoutEffect elsewhere.\r\n *\r\n * @see https://github.com/facebook/react/issues/14927\r\n */ const useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n    useIsomorphicLayoutEffect(()=>void (ref.current = fn), [\n        fn\n    ]);\n    return ref;\n}\nfunction Block({ set }) {\n    useIsomorphicLayoutEffect(()=>{\n        set(new Promise(()=>null));\n        return ()=>set(false);\n    }, [\n        set\n    ]);\n    return null;\n}\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            error: false\n        };\n    }\n    componentDidCatch(err) {\n        this.props.set(err);\n    }\n    render() {\n        return this.state.error ? null : this.props.children;\n    }\n}\nErrorBoundary.getDerivedStateFromError = ()=>({\n        error: true\n    });\nconst DEFAULT = \"__default\";\nconst DEFAULTS = new Map();\nconst isDiffSet = (def)=>def && !!def.memoized && !!def.changes;\nfunction calculateDpr(dpr) {\n    var _window$devicePixelRa;\n    // Err on the side of progress by assuming 2x dpr if we can't detect it\n    // This will happen in workers where window is defined but dpr isn't.\n    const target =  false ? 0 : 1;\n    return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n/**\r\n * Returns instance root state\r\n */ const getRootState = (obj)=>{\n    var _r3f;\n    return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n};\n/**\r\n * Returns the instances initial (outmost) root\r\n */ function findInitialRoot(child) {\n    let root = child.__r3f.root;\n    while(root.getState().previousRoot)root = root.getState().previousRoot;\n    return root;\n}\n// A collection of compare functions\nconst is = {\n    obj: (a)=>a === Object(a) && !is.arr(a) && typeof a !== \"function\",\n    fun: (a)=>typeof a === \"function\",\n    str: (a)=>typeof a === \"string\",\n    num: (a)=>typeof a === \"number\",\n    boo: (a)=>typeof a === \"boolean\",\n    und: (a)=>a === void 0,\n    arr: (a)=>Array.isArray(a),\n    equ (a, b, { arrays = \"shallow\", objects = \"reference\", strict = true } = {}) {\n        // Wrong type or one of the two undefined, doesn't match\n        if (typeof a !== typeof b || !!a !== !!b) return false;\n        // Atomic, just compare a against b\n        if (is.str(a) || is.num(a)) return a === b;\n        const isObj = is.obj(a);\n        if (isObj && objects === \"reference\") return a === b;\n        const isArr = is.arr(a);\n        if (isArr && arrays === \"reference\") return a === b;\n        // Array or Object, shallow compare first to see if it's a match\n        if ((isArr || isObj) && a === b) return true;\n        // Last resort, go through keys\n        let i;\n        // Check if a has all the keys of b\n        for(i in a)if (!(i in b)) return false;\n        // Check if values between keys match\n        if (isObj && arrays === \"shallow\" && objects === \"shallow\") {\n            for(i in strict ? b : a)if (!is.equ(a[i], b[i], {\n                strict,\n                objects: \"reference\"\n            })) return false;\n        } else {\n            for(i in strict ? b : a)if (a[i] !== b[i]) return false;\n        }\n        // If i is undefined\n        if (is.und(i)) {\n            // If both arrays are empty we consider them equal\n            if (isArr && a.length === 0 && b.length === 0) return true;\n            // If both objects are empty we consider them equal\n            if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n            // Otherwise match them by value\n            if (a !== b) return false;\n        }\n        return true;\n    }\n};\n/**\r\n * Collects nodes and materials from a THREE.Object3D.\r\n */ function buildGraph(object) {\n    const data = {\n        nodes: {},\n        materials: {}\n    };\n    if (object) {\n        object.traverse((obj)=>{\n            if (obj.name) data.nodes[obj.name] = obj;\n            if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n        });\n    }\n    return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n    if (obj.dispose && obj.type !== \"Scene\") obj.dispose();\n    for(const p in obj){\n        p.dispose == null ? void 0 : p.dispose();\n        delete obj[p];\n    }\n}\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(object, state) {\n    const instance = object;\n    instance.__r3f = {\n        type: \"\",\n        root: null,\n        previousAttach: null,\n        memoizedProps: {},\n        eventCount: 0,\n        handlers: {},\n        objects: [],\n        parent: null,\n        ...state\n    };\n    return object;\n}\nfunction resolve(instance, key) {\n    let target = instance;\n    if (key.includes(\"-\")) {\n        const entries = key.split(\"-\");\n        const last = entries.pop();\n        target = entries.reduce((acc, key)=>acc[key], instance);\n        return {\n            target,\n            key: last\n        };\n    } else return {\n        target,\n        key\n    };\n}\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child, type) {\n    if (is.str(type)) {\n        // If attaching into an array (foo-0), create one\n        if (INDEX_REGEX.test(type)) {\n            const root = type.replace(INDEX_REGEX, \"\");\n            const { target, key } = resolve(parent, root);\n            if (!Array.isArray(target[key])) target[key] = [];\n        }\n        const { target, key } = resolve(parent, type);\n        child.__r3f.previousAttach = target[key];\n        target[key] = child;\n    } else child.__r3f.previousAttach = type(parent, child);\n}\nfunction detach(parent, child, type) {\n    var _child$__r3f, _child$__r3f2;\n    if (is.str(type)) {\n        const { target, key } = resolve(parent, type);\n        const previous = child.__r3f.previousAttach;\n        // When the previous value was undefined, it means the value was never set to begin with\n        if (previous === undefined) delete target[key];\n        else target[key] = previous;\n    } else (_child$__r3f = child.__r3f) == null ? void 0 : _child$__r3f.previousAttach == null ? void 0 : _child$__r3f.previousAttach(parent, child);\n    (_child$__r3f2 = child.__r3f) == null ? true : delete _child$__r3f2.previousAttach;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, { children: cN, key: kN, ref: rN, ...props }, { children: cP, key: kP, ref: rP, ...previous } = {}, remove = false) {\n    var _instance$__r3f;\n    const localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};\n    const entries = Object.entries(props);\n    const changes = [];\n    // Catch removed props, prepend them so they can be reset or removed\n    if (remove) {\n        const previousKeys = Object.keys(previous);\n        for(let i = 0; i < previousKeys.length; i++){\n            if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([\n                previousKeys[i],\n                DEFAULT + \"remove\"\n            ]);\n        }\n    }\n    entries.forEach(([key, value])=>{\n        var _instance$__r3f2;\n        // Bail out on primitive object\n        if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.primitive && key === \"object\") return;\n        // When props match bail out\n        if (is.equ(value, previous[key])) return;\n        // Collect handlers and bail out\n        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([\n            key,\n            value,\n            true,\n            []\n        ]);\n        // Split dashed props\n        let entries = [];\n        if (key.includes(\"-\")) entries = key.split(\"-\");\n        changes.push([\n            key,\n            value,\n            false,\n            entries\n        ]);\n        // Reset pierced props\n        for(const prop in props){\n            const value = props[prop];\n            if (prop.startsWith(`${key}-`)) changes.push([\n                prop,\n                value,\n                false,\n                prop.split(\"-\")\n            ]);\n        }\n    });\n    const memoized = {\n        ...props\n    };\n    if (localState.memoizedProps && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n    if (localState.memoizedProps && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n    return {\n        memoized,\n        changes\n    };\n}\nconst __DEV__ = typeof process !== \"undefined\" && \"development\" !== \"production\";\n// This function applies a set of changes to the instance\nfunction applyProps$1(instance, data) {\n    var _instance$__r3f3, _root$getState, _instance$__r3f4;\n    // Filter equals, events and reserved props\n    const localState = (_instance$__r3f3 = instance.__r3f) != null ? _instance$__r3f3 : {};\n    const root = localState.root;\n    const rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};\n    const { memoized, changes } = isDiffSet(data) ? data : diffProps(instance, data);\n    const prevHandlers = localState.eventCount;\n    // Prepare memoized props\n    if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n    for(let i = 0; i < changes.length; i++){\n        let [key, value, isEvent, keys] = changes[i];\n        // Alias (output)encoding => (output)colorSpace (since r152)\n        // https://github.com/pmndrs/react-three-fiber/pull/2829\n        if (hasColorSpace(instance)) {\n            const sRGBEncoding = 3001;\n            const SRGBColorSpace = \"srgb\";\n            const LinearSRGBColorSpace = \"srgb-linear\";\n            if (key === \"encoding\") {\n                key = \"colorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            } else if (key === \"outputEncoding\") {\n                key = \"outputColorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            }\n        }\n        let currentInstance = instance;\n        let targetProp = currentInstance[key];\n        // Revolve dashed props\n        if (keys.length) {\n            targetProp = keys.reduce((acc, key)=>acc[key], instance);\n            // If the target is atomic, it forces us to switch the root\n            if (!(targetProp && targetProp.set)) {\n                const [name, ...reverseEntries] = keys.reverse();\n                currentInstance = reverseEntries.reverse().reduce((acc, key)=>acc[key], instance);\n                key = name;\n            }\n        }\n        // https://github.com/mrdoob/three.js/issues/21209\n        // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n        // has no means to do this. Hence we curate a small collection of value-classes\n        // with their respective constructor/set arguments\n        // For removed props, try to set default values, if possible\n        if (value === DEFAULT + \"remove\") {\n            if (currentInstance.constructor) {\n                // create a blank slate of the instance and copy the particular parameter.\n                let ctor = DEFAULTS.get(currentInstance.constructor);\n                if (!ctor) {\n                    // @ts-ignore\n                    ctor = new currentInstance.constructor();\n                    DEFAULTS.set(currentInstance.constructor, ctor);\n                }\n                value = ctor[key];\n            } else {\n                // instance does not have constructor, just set it to 0\n                value = 0;\n            }\n        }\n        // Deal with pointer events ...\n        if (isEvent) {\n            if (value) localState.handlers[key] = value;\n            else delete localState.handlers[key];\n            localState.eventCount = Object.keys(localState.handlers).length;\n        } else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers)) {\n            // If value is an array\n            if (Array.isArray(value)) {\n                if (targetProp.fromArray) targetProp.fromArray(value);\n                else targetProp.set(...value);\n            } else if (targetProp.copy && value && value.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.\n            // Loosen to unminified names, ignoring descendents.\n            // https://github.com/pmndrs/react-three-fiber/issues/2856\n            // TODO: fix upstream and remove in v9\n            (__DEV__ ? targetProp.constructor.name === value.constructor.name : targetProp.constructor === value.constructor)) {\n                targetProp.copy(value);\n            } else if (value !== undefined) {\n                const isColor = targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Color;\n                // Allow setting array scalars\n                if (!isColor && targetProp.setScalar) targetProp.setScalar(value);\n                else if (targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers) targetProp.mask = value.mask;\n                else targetProp.set(value);\n                // For versions of three which don't support THREE.ColorManagement,\n                // Auto-convert sRGB colors\n                // https://github.com/pmndrs/react-three-fiber/issues/344\n                if (!getColorManagement() && !rootState.linear && isColor) targetProp.convertSRGBToLinear();\n            }\n        // Else, just overwrite the value\n        } else {\n            currentInstance[key] = value;\n            // Auto-convert sRGB textures, for now ...\n            // https://github.com/pmndrs/react-three-fiber/issues/344\n            if (currentInstance[key] instanceof three__WEBPACK_IMPORTED_MODULE_4__.Texture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n            currentInstance[key].format === three__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat && currentInstance[key].type === three__WEBPACK_IMPORTED_MODULE_4__.UnsignedByteType) {\n                const texture = currentInstance[key];\n                if (hasColorSpace(texture) && hasColorSpace(rootState.gl)) texture.colorSpace = rootState.gl.outputColorSpace;\n                else texture.encoding = rootState.gl.outputEncoding;\n            }\n        }\n        invalidateInstance(instance);\n    }\n    if (localState.parent && instance.raycast && prevHandlers !== localState.eventCount) {\n        // Get the initial root state's internals\n        const internal = findInitialRoot(instance).getState().internal;\n        // Pre-emptively remove the instance from the interaction manager\n        const index = internal.interaction.indexOf(instance);\n        if (index > -1) internal.interaction.splice(index, 1);\n        // Add the instance to the interaction manager only when it has handlers\n        if (localState.eventCount) internal.interaction.push(instance);\n    }\n    // Call the update lifecycle when it is being updated, but only when it is part of the scene.\n    // Skip updates to the `onUpdate` prop itself\n    const isCircular = changes.length === 1 && changes[0][0] === \"onUpdate\";\n    if (!isCircular && changes.length && (_instance$__r3f4 = instance.__r3f) != null && _instance$__r3f4.parent) updateInstance(instance);\n    return instance;\n}\nfunction invalidateInstance(instance) {\n    var _instance$__r3f5, _instance$__r3f5$root;\n    const state = (_instance$__r3f5 = instance.__r3f) == null ? void 0 : (_instance$__r3f5$root = _instance$__r3f5.root) == null ? void 0 : _instance$__r3f5$root.getState == null ? void 0 : _instance$__r3f5$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n}\nfunction updateCamera(camera, size) {\n    // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n    if (!camera.manual) {\n        if (isOrthographicCamera(camera)) {\n            camera.left = size.width / -2;\n            camera.right = size.width / 2;\n            camera.top = size.height / 2;\n            camera.bottom = size.height / -2;\n        } else {\n            camera.aspect = size.width / size.height;\n        }\n        camera.updateProjectionMatrix();\n        // https://github.com/pmndrs/react-three-fiber/issues/178\n        // Update matrix world since the renderer is a frame late\n        camera.updateMatrixWorld();\n    }\n}\nfunction makeId(event) {\n    return (event.eventObject || event.object).uuid + \"/\" + event.index + event.instanceId;\n}\n// https://github.com/facebook/react/tree/main/packages/react-reconciler#getcurrenteventpriority\n// Gives React a clue as to how import the current interaction is\nfunction getEventPriority() {\n    var _globalScope$event;\n    // Get a handle to the current global scope in window and worker contexts if able\n    // https://github.com/pmndrs/react-three-fiber/pull/2493\n    const globalScope = typeof self !== \"undefined\" && self ||  false && 0;\n    if (!globalScope) return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    const name = (_globalScope$event = globalScope.event) == null ? void 0 : _globalScope$event.type;\n    switch(name){\n        case \"click\":\n        case \"contextmenu\":\n        case \"dblclick\":\n        case \"pointercancel\":\n        case \"pointerdown\":\n        case \"pointerup\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n        case \"pointermove\":\n        case \"pointerout\":\n        case \"pointerover\":\n        case \"pointerenter\":\n        case \"pointerleave\":\n        case \"wheel\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n        default:\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    }\n}\n/**\r\n * Release pointer captures.\r\n * This is called by releasePointerCapture in the API, and when an object is removed.\r\n */ function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n    const captureData = captures.get(obj);\n    if (captureData) {\n        captures.delete(obj);\n        // If this was the last capturing object for this pointer\n        if (captures.size === 0) {\n            capturedMap.delete(pointerId);\n            captureData.target.releasePointerCapture(pointerId);\n        }\n    }\n}\nfunction removeInteractivity(store, object) {\n    const { internal } = store.getState();\n    // Removes every trace of an object from the data store\n    internal.interaction = internal.interaction.filter((o)=>o !== object);\n    internal.initialHits = internal.initialHits.filter((o)=>o !== object);\n    internal.hovered.forEach((value, key)=>{\n        if (value.eventObject === object || value.object === object) {\n            // Clear out intersects, they are outdated by now\n            internal.hovered.delete(key);\n        }\n    });\n    internal.capturedMap.forEach((captures, pointerId)=>{\n        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n    });\n}\nfunction createEvents(store) {\n    /** Calculates delta */ function calculateDistance(event) {\n        const { internal } = store.getState();\n        const dx = event.offsetX - internal.initialClick[0];\n        const dy = event.offsetY - internal.initialClick[1];\n        return Math.round(Math.sqrt(dx * dx + dy * dy));\n    }\n    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */ function filterPointerEvents(objects) {\n        return objects.filter((obj)=>[\n                \"Move\",\n                \"Over\",\n                \"Enter\",\n                \"Out\",\n                \"Leave\"\n            ].some((name)=>{\n                var _r3f;\n                return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers[\"onPointer\" + name];\n            }));\n    }\n    function intersect(event, filter) {\n        const state = store.getState();\n        const duplicates = new Set();\n        const intersections = [];\n        // Allow callers to eliminate event objects\n        const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n        // Reset all raycaster cameras to undefined\n        for(let i = 0; i < eventsObjects.length; i++){\n            const state = getRootState(eventsObjects[i]);\n            if (state) {\n                state.raycaster.camera = undefined;\n            }\n        }\n        if (!state.previousRoot) {\n            // Make sure root-level pointer and ray are set up\n            state.events.compute == null ? void 0 : state.events.compute(event, state);\n        }\n        function handleRaycast(obj) {\n            const state = getRootState(obj);\n            // Skip event handling when noEvents is set, or when the raycasters camera is null\n            if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n            // When the camera is undefined we have to call the event layers update function\n            if (state.raycaster.camera === undefined) {\n                var _state$previousRoot;\n                state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n                // If the camera is still undefined we have to skip this layer entirely\n                if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n            }\n            // Intersect object by object\n            return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n        }\n        // Collect events\n        let hits = eventsObjects// Intersect objects\n        .flatMap(handleRaycast)// Sort by event priority and distance\n        .sort((a, b)=>{\n            const aState = getRootState(a.object);\n            const bState = getRootState(b.object);\n            if (!aState || !bState) return a.distance - b.distance;\n            return bState.events.priority - aState.events.priority || a.distance - b.distance;\n        })// Filter out duplicates\n        .filter((item)=>{\n            const id = makeId(item);\n            if (duplicates.has(id)) return false;\n            duplicates.add(id);\n            return true;\n        });\n        // https://github.com/mrdoob/three.js/issues/16031\n        // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n        if (state.events.filter) hits = state.events.filter(hits, state);\n        // Bubble up the events, find the event source (eventObject)\n        for (const hit of hits){\n            let eventObject = hit.object;\n            // Bubble event up\n            while(eventObject){\n                var _r3f2;\n                if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n                    ...hit,\n                    eventObject\n                });\n                eventObject = eventObject.parent;\n            }\n        }\n        // If the interaction is captured, make all capturing targets part of the intersect.\n        if (\"pointerId\" in event && state.internal.capturedMap.has(event.pointerId)) {\n            for (let captureData of state.internal.capturedMap.get(event.pointerId).values()){\n                if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n            }\n        }\n        return intersections;\n    }\n    /**  Handles intersections by forwarding them to handlers */ function handleIntersects(intersections, event, delta, callback) {\n        const rootState = store.getState();\n        // If anything has been found, forward it to the event listeners\n        if (intersections.length) {\n            const localState = {\n                stopped: false\n            };\n            for (const hit of intersections){\n                const state = getRootState(hit.object) || rootState;\n                const { raycaster, pointer, camera, internal } = state;\n                const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n                const hasPointerCapture = (id)=>{\n                    var _internal$capturedMap, _internal$capturedMap2;\n                    return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n                };\n                const setPointerCapture = (id)=>{\n                    const captureData = {\n                        intersection: hit,\n                        target: event.target\n                    };\n                    if (internal.capturedMap.has(id)) {\n                        // if the pointerId was previously captured, we add the hit to the\n                        // event capturedMap.\n                        internal.capturedMap.get(id).set(hit.eventObject, captureData);\n                    } else {\n                        // if the pointerId was not previously captured, we create a map\n                        // containing the hitObject, and the hit. hitObject is used for\n                        // faster access.\n                        internal.capturedMap.set(id, new Map([\n                            [\n                                hit.eventObject,\n                                captureData\n                            ]\n                        ]));\n                    }\n                    event.target.setPointerCapture(id);\n                };\n                const releasePointerCapture = (id)=>{\n                    const captures = internal.capturedMap.get(id);\n                    if (captures) {\n                        releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n                    }\n                };\n                // Add native event props\n                let extractEventProps = {};\n                // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n                for(let prop in event){\n                    let property = event[prop];\n                    // Only copy over atomics, leave functions alone as these should be\n                    // called as event.nativeEvent.fn()\n                    if (typeof property !== \"function\") extractEventProps[prop] = property;\n                }\n                let raycastEvent = {\n                    ...hit,\n                    ...extractEventProps,\n                    pointer,\n                    intersections,\n                    stopped: localState.stopped,\n                    delta,\n                    unprojectedPoint,\n                    ray: raycaster.ray,\n                    camera: camera,\n                    // Hijack stopPropagation, which just sets a flag\n                    stopPropagation () {\n                        // https://github.com/pmndrs/react-three-fiber/issues/596\n                        // Events are not allowed to stop propagation if the pointer has been captured\n                        const capturesForPointer = \"pointerId\" in event && internal.capturedMap.get(event.pointerId);\n                        // We only authorize stopPropagation...\n                        if (// ...if this pointer hasn't been captured\n                        !capturesForPointer || // ... or if the hit object is capturing the pointer\n                        capturesForPointer.has(hit.eventObject)) {\n                            raycastEvent.stopped = localState.stopped = true;\n                            // Propagation is stopped, remove all other hover records\n                            // An event handler is only allowed to flush other handlers if it is hovered itself\n                            if (internal.hovered.size && Array.from(internal.hovered.values()).find((i)=>i.eventObject === hit.eventObject)) {\n                                // Objects cannot flush out higher up objects that have already caught the event\n                                const higher = intersections.slice(0, intersections.indexOf(hit));\n                                cancelPointer([\n                                    ...higher,\n                                    hit\n                                ]);\n                            }\n                        }\n                    },\n                    // there should be a distinction between target and currentTarget\n                    target: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    currentTarget: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    nativeEvent: event\n                };\n                // Call subscribers\n                callback(raycastEvent);\n                // Event bubbling may be interrupted by stopPropagation\n                if (localState.stopped === true) break;\n            }\n        }\n        return intersections;\n    }\n    function cancelPointer(intersections) {\n        const { internal } = store.getState();\n        for (const hoveredObj of internal.hovered.values()){\n            // When no objects were hit or the the hovered object wasn't found underneath the cursor\n            // we call onPointerOut and delete the object from the hovered-elements map\n            if (!intersections.length || !intersections.find((hit)=>hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n                const eventObject = hoveredObj.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                internal.hovered.delete(makeId(hoveredObj));\n                if (instance != null && instance.eventCount) {\n                    // Clear out intersects, they are outdated by now\n                    const data = {\n                        ...hoveredObj,\n                        intersections\n                    };\n                    handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n                    handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n                }\n            }\n        }\n    }\n    function pointerMissed(event, objects) {\n        for(let i = 0; i < objects.length; i++){\n            const instance = objects[i].__r3f;\n            instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n        }\n    }\n    function handlePointer(name) {\n        // Deal with cancelation\n        switch(name){\n            case \"onPointerLeave\":\n            case \"onPointerCancel\":\n                return ()=>cancelPointer([]);\n            case \"onLostPointerCapture\":\n                return (event)=>{\n                    const { internal } = store.getState();\n                    if (\"pointerId\" in event && internal.capturedMap.has(event.pointerId)) {\n                        // If the object event interface had onLostPointerCapture, we'd call it here on every\n                        // object that's getting removed. We call it on the next frame because onLostPointerCapture\n                        // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n                        // happen in the object it originated from, leaving components in a in-between state.\n                        requestAnimationFrame(()=>{\n                            // Only release if pointer-up didn't do it already\n                            if (internal.capturedMap.has(event.pointerId)) {\n                                internal.capturedMap.delete(event.pointerId);\n                                cancelPointer([]);\n                            }\n                        });\n                    }\n                };\n        }\n        // Any other pointer goes here ...\n        return function handleEvent(event) {\n            const { onPointerMissed, internal } = store.getState();\n            // prepareRay(event)\n            internal.lastEvent.current = event;\n            // Get fresh intersects\n            const isPointerMove = name === \"onPointerMove\";\n            const isClickEvent = name === \"onClick\" || name === \"onContextMenu\" || name === \"onDoubleClick\";\n            const filter = isPointerMove ? filterPointerEvents : undefined;\n            const hits = intersect(event, filter);\n            const delta = isClickEvent ? calculateDistance(event) : 0;\n            // Save initial coordinates on pointer-down\n            if (name === \"onPointerDown\") {\n                internal.initialClick = [\n                    event.offsetX,\n                    event.offsetY\n                ];\n                internal.initialHits = hits.map((hit)=>hit.eventObject);\n            }\n            // If a click yields no results, pass it back to the user as a miss\n            // Missed events have to come first in order to establish user-land side-effect clean up\n            if (isClickEvent && !hits.length) {\n                if (delta <= 2) {\n                    pointerMissed(event, internal.interaction);\n                    if (onPointerMissed) onPointerMissed(event);\n                }\n            }\n            // Take care of unhover\n            if (isPointerMove) cancelPointer(hits);\n            function onIntersect(data) {\n                const eventObject = data.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                // Check presence of handlers\n                if (!(instance != null && instance.eventCount)) return;\n                /*\r\n        MAYBE TODO, DELETE IF NOT: \r\n          Check if the object is captured, captured events should not have intersects running in parallel\r\n          But wouldn't it be better to just replace capturedMap with a single entry?\r\n          Also, are we OK with straight up making picking up multiple objects impossible?\r\n          \r\n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \r\n        if (pointerId !== undefined) {\r\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\r\n          if (capturedMeshSet) {\r\n            const captured = capturedMeshSet.get(eventObject)\r\n            if (captured && captured.localState.stopped) return\r\n          }\r\n        }*/ if (isPointerMove) {\n                    // Move event ...\n                    if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n                        // When enter or out is present take care of hover-state\n                        const id = makeId(data);\n                        const hoveredItem = internal.hovered.get(id);\n                        if (!hoveredItem) {\n                            // If the object wasn't previously hovered, book it and call its handler\n                            internal.hovered.set(id, data);\n                            handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n                            handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n                        } else if (hoveredItem.stopped) {\n                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n                            data.stopPropagation();\n                        }\n                    }\n                    // Call mouse move\n                    handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n                } else {\n                    // All other events ...\n                    const handler = handlers[name];\n                    if (handler) {\n                        // Forward all events back to their respective handlers with the exception of click events,\n                        // which must use the initial target\n                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n                            // Missed events have to come first\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                            // Now call the handler\n                            handler(data);\n                        }\n                    } else {\n                        // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n                        if (isClickEvent && internal.initialHits.includes(eventObject)) {\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                        }\n                    }\n                }\n            }\n            handleIntersects(hits, event, delta, onIntersect);\n        };\n    }\n    return {\n        handlePointer\n    };\n}\n// Keys that shouldn't be copied between R3F stores\nconst privateKeys = [\n    \"set\",\n    \"get\",\n    \"setSize\",\n    \"setFrameloop\",\n    \"setDpr\",\n    \"events\",\n    \"invalidate\",\n    \"advance\",\n    \"size\",\n    \"viewport\"\n];\nconst isRenderer = (def)=>!!(def != null && def.render);\nconst context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance)=>{\n    const rootState = (0,zustand__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((set, get)=>{\n        const position = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        const tempTarget = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n            const { width, height, top, left } = size;\n            const aspect = width / height;\n            if (target instanceof three__WEBPACK_IMPORTED_MODULE_4__.Vector3) tempTarget.copy(target);\n            else tempTarget.set(...target);\n            const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n            if (isOrthographicCamera(camera)) {\n                return {\n                    width: width / camera.zoom,\n                    height: height / camera.zoom,\n                    top,\n                    left,\n                    factor: 1,\n                    distance,\n                    aspect\n                };\n            } else {\n                const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n                const h = 2 * Math.tan(fov / 2) * distance; // visible height\n                const w = h * (width / height);\n                return {\n                    width: w,\n                    height: h,\n                    top,\n                    left,\n                    factor: width / w,\n                    distance,\n                    aspect\n                };\n            }\n        }\n        let performanceTimeout = undefined;\n        const setPerformanceCurrent = (current)=>set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        current\n                    }\n                }));\n        const pointer = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2();\n        const rootState = {\n            set,\n            get,\n            // Mock objects that have to be configured\n            gl: null,\n            camera: null,\n            raycaster: null,\n            events: {\n                priority: 1,\n                enabled: true,\n                connected: false\n            },\n            xr: null,\n            scene: null,\n            invalidate: (frames = 1)=>invalidate(get(), frames),\n            advance: (timestamp, runGlobalEffects)=>advance(timestamp, runGlobalEffects, get()),\n            legacy: false,\n            linear: false,\n            flat: false,\n            controls: null,\n            clock: new three__WEBPACK_IMPORTED_MODULE_4__.Clock(),\n            pointer,\n            mouse: pointer,\n            frameloop: \"always\",\n            onPointerMissed: undefined,\n            performance: {\n                current: 1,\n                min: 0.5,\n                max: 1,\n                debounce: 200,\n                regress: ()=>{\n                    const state = get();\n                    // Clear timeout\n                    if (performanceTimeout) clearTimeout(performanceTimeout);\n                    // Set lower bound performance\n                    if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n                    // Go back to upper bound performance after a while unless something regresses meanwhile\n                    performanceTimeout = setTimeout(()=>setPerformanceCurrent(get().performance.max), state.performance.debounce);\n                }\n            },\n            size: {\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                updateStyle: false\n            },\n            viewport: {\n                initialDpr: 0,\n                dpr: 0,\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                aspect: 0,\n                distance: 0,\n                factor: 0,\n                getCurrentViewport\n            },\n            setEvents: (events)=>set((state)=>({\n                        ...state,\n                        events: {\n                            ...state.events,\n                            ...events\n                        }\n                    })),\n            setSize: (width, height, updateStyle, top, left)=>{\n                const camera = get().camera;\n                const size = {\n                    width,\n                    height,\n                    top: top || 0,\n                    left: left || 0,\n                    updateStyle\n                };\n                set((state)=>({\n                        size,\n                        viewport: {\n                            ...state.viewport,\n                            ...getCurrentViewport(camera, defaultTarget, size)\n                        }\n                    }));\n            },\n            setDpr: (dpr)=>set((state)=>{\n                    const resolved = calculateDpr(dpr);\n                    return {\n                        viewport: {\n                            ...state.viewport,\n                            dpr: resolved,\n                            initialDpr: state.viewport.initialDpr || resolved\n                        }\n                    };\n                }),\n            setFrameloop: (frameloop = \"always\")=>{\n                const clock = get().clock;\n                // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n                clock.stop();\n                clock.elapsedTime = 0;\n                if (frameloop !== \"never\") {\n                    clock.start();\n                    clock.elapsedTime = 0;\n                }\n                set(()=>({\n                        frameloop\n                    }));\n            },\n            previousRoot: undefined,\n            internal: {\n                active: false,\n                priority: 0,\n                frames: 0,\n                lastEvent: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n                interaction: [],\n                hovered: new Map(),\n                subscribers: [],\n                initialClick: [\n                    0,\n                    0\n                ],\n                initialHits: [],\n                capturedMap: new Map(),\n                subscribe: (ref, priority, store)=>{\n                    const internal = get().internal;\n                    // If this subscription was given a priority, it takes rendering into its own hands\n                    // For that reason we switch off automatic rendering and increase the manual flag\n                    // As long as this flag is positive there can be no internal rendering at all\n                    // because there could be multiple render subscriptions\n                    internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n                    internal.subscribers.push({\n                        ref,\n                        priority,\n                        store\n                    });\n                    // Register subscriber and sort layers from lowest to highest, meaning,\n                    // highest priority renders last (on top of the other frames)\n                    internal.subscribers = internal.subscribers.sort((a, b)=>a.priority - b.priority);\n                    return ()=>{\n                        const internal = get().internal;\n                        if (internal != null && internal.subscribers) {\n                            // Decrease manual flag if this subscription had a priority\n                            internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n                            // Remove subscriber from list\n                            internal.subscribers = internal.subscribers.filter((s)=>s.ref !== ref);\n                        }\n                    };\n                }\n            }\n        };\n        return rootState;\n    });\n    const state = rootState.getState();\n    let oldSize = state.size;\n    let oldDpr = state.viewport.dpr;\n    let oldCamera = state.camera;\n    rootState.subscribe(()=>{\n        const { camera, size, viewport, gl, set } = rootState.getState();\n        // Resize camera and renderer on changes to size and pixelratio\n        if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n            var _size$updateStyle;\n            oldSize = size;\n            oldDpr = viewport.dpr;\n            // Update camera & renderer\n            updateCamera(camera, size);\n            gl.setPixelRatio(viewport.dpr);\n            const updateStyle = (_size$updateStyle = size.updateStyle) != null ? _size$updateStyle : typeof HTMLCanvasElement !== \"undefined\" && gl.domElement instanceof HTMLCanvasElement;\n            gl.setSize(size.width, size.height, updateStyle);\n        }\n        // Update viewport once the camera changes\n        if (camera !== oldCamera) {\n            oldCamera = camera;\n            // Update viewport\n            set((state)=>({\n                    viewport: {\n                        ...state.viewport,\n                        ...state.viewport.getCurrentViewport(camera)\n                    }\n                }));\n        }\n    });\n    // Invalidate on any change\n    rootState.subscribe((state)=>invalidate(state));\n    // Return root state\n    return rootState;\n};\nfunction createSubs(callback, subs) {\n    const sub = {\n        callback\n    };\n    subs.add(sub);\n    return ()=>void subs.delete(sub);\n}\nlet i;\nlet globalEffects = new Set();\nlet globalAfterEffects = new Set();\nlet globalTailEffects = new Set();\n/**\r\n * Adds a global render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\r\n */ const addEffect = (callback)=>createSubs(callback, globalEffects);\n/**\r\n * Adds a global after-render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\r\n */ const addAfterEffect = (callback)=>createSubs(callback, globalAfterEffects);\n/**\r\n * Adds a global callback which is called when rendering stops.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\r\n */ const addTail = (callback)=>createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n    if (!effects.size) return;\n    for (const { callback } of effects.values()){\n        callback(timestamp);\n    }\n}\nfunction flushGlobalEffects(type, timestamp) {\n    switch(type){\n        case \"before\":\n            return run(globalEffects, timestamp);\n        case \"after\":\n            return run(globalAfterEffects, timestamp);\n        case \"tail\":\n            return run(globalTailEffects, timestamp);\n    }\n}\nlet subscribers;\nlet subscription;\nfunction render$1(timestamp, state, frame) {\n    // Run local effects\n    let delta = state.clock.getDelta();\n    // In frameloop='never' mode, clock times are updated using the provided timestamp\n    if (state.frameloop === \"never\" && typeof timestamp === \"number\") {\n        delta = timestamp - state.clock.elapsedTime;\n        state.clock.oldTime = state.clock.elapsedTime;\n        state.clock.elapsedTime = timestamp;\n    }\n    // Call subscribers (useFrame)\n    subscribers = state.internal.subscribers;\n    for(i = 0; i < subscribers.length; i++){\n        subscription = subscribers[i];\n        subscription.ref.current(subscription.store.getState(), delta, frame);\n    }\n    // Render content\n    if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n    // Decrease frame count\n    state.internal.frames = Math.max(0, state.internal.frames - 1);\n    return state.frameloop === \"always\" ? 1 : state.internal.frames;\n}\nfunction createLoop(roots) {\n    let running = false;\n    let repeat;\n    let frame;\n    let state;\n    function loop(timestamp) {\n        frame = requestAnimationFrame(loop);\n        running = true;\n        repeat = 0;\n        // Run effects\n        flushGlobalEffects(\"before\", timestamp);\n        // Render all roots\n        for (const root of roots.values()){\n            var _state$gl$xr;\n            state = root.store.getState();\n            // If the frameloop is invalidated, do not run another frame\n            if (state.internal.active && (state.frameloop === \"always\" || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n                repeat += render$1(timestamp, state);\n            }\n        }\n        // Run after-effects\n        flushGlobalEffects(\"after\", timestamp);\n        // Stop the loop if nothing invalidates it\n        if (repeat === 0) {\n            // Tail call effects, they are called when rendering stops\n            flushGlobalEffects(\"tail\", timestamp);\n            // Flag end of operation\n            running = false;\n            return cancelAnimationFrame(frame);\n        }\n    }\n    function invalidate(state, frames = 1) {\n        var _state$gl$xr2;\n        if (!state) return roots.forEach((root)=>invalidate(root.store.getState()), frames);\n        if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === \"never\") return;\n        // Increase frames, do not go higher than 60\n        state.internal.frames = Math.min(60, state.internal.frames + frames);\n        // If the render-loop isn't active, start it\n        if (!running) {\n            running = true;\n            requestAnimationFrame(loop);\n        }\n    }\n    function advance(timestamp, runGlobalEffects = true, state, frame) {\n        if (runGlobalEffects) flushGlobalEffects(\"before\", timestamp);\n        if (!state) for (const root of roots.values())render$1(timestamp, root.store.getState());\n        else render$1(timestamp, state, frame);\n        if (runGlobalEffects) flushGlobalEffects(\"after\", timestamp);\n    }\n    return {\n        loop,\n        /**\r\n     * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.\r\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate\r\n     */ invalidate,\n        /**\r\n     * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop=\"never\"`.\r\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance\r\n     */ advance\n    };\n}\n/**\r\n * Exposes an object's {@link LocalState}.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\r\n *\r\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\r\n */ function useInstanceHandle(ref) {\n    const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    useIsomorphicLayoutEffect(()=>void (instance.current = ref.current.__r3f), [\n        ref\n    ]);\n    return instance;\n}\nfunction useStore() {\n    const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (!store) throw new Error(\"R3F: Hooks can only be used within the Canvas component!\");\n    return store;\n}\n/**\r\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\r\n */ function useThree(selector = (state)=>state, equalityFn) {\n    return useStore()(selector, equalityFn);\n}\n/**\r\n * Executes a callback before render in a shared frame loop.\r\n * Can order effects with render priority or manually render with a positive priority.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\r\n */ function useFrame(callback, renderPriority = 0) {\n    const store = useStore();\n    const subscribe = store.getState().internal.subscribe;\n    // Memoize ref\n    const ref = useMutableCallback(callback);\n    // Subscribe on mount, unsubscribe on unmount\n    useIsomorphicLayoutEffect(()=>subscribe(ref, renderPriority, store), [\n        renderPriority,\n        subscribe,\n        store\n    ]);\n    return null;\n}\n/**\r\n * Returns a node graph of an object with named nodes & materials.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\r\n */ function useGraph(object) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>buildGraph(object), [\n        object\n    ]);\n}\nconst memoizedLoaders = new WeakMap();\nfunction loadingFn(extensions, onProgress) {\n    return function(Proto, ...input) {\n        // Construct new loader and run extensions\n        let loader = memoizedLoaders.get(Proto);\n        if (!loader) {\n            loader = new Proto();\n            memoizedLoaders.set(Proto, loader);\n        }\n        if (extensions) extensions(loader);\n        // Go through the urls and load them\n        return Promise.all(input.map((input)=>new Promise((res, reject)=>loader.load(input, (data)=>{\n                    if (data.scene) Object.assign(data, buildGraph(data.scene));\n                    res(data);\n                }, onProgress, (error)=>reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`)))))).finally(()=>loader.dispose == null ? void 0 : loader.dispose());\n    };\n}\n/**\r\n * Synchronously loads and caches assets with a three loader.\r\n *\r\n * Note: this hook's caller must be wrapped with `React.Suspense`\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\r\n */ function useLoader(Proto, input, extensions, onProgress) {\n    // Use suspense to load async assets\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.suspend)(loadingFn(extensions, onProgress), [\n        Proto,\n        ...keys\n    ], {\n        equal: is.equ\n    });\n    // Return the object/s\n    return Array.isArray(input) ? results : results[0];\n}\n/**\r\n * Preloads an asset into cache as a side-effect.\r\n */ useLoader.preload = function(Proto, input, extensions) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.preload)(loadingFn(extensions), [\n        Proto,\n        ...keys\n    ]);\n};\n/**\r\n * Removes a loaded asset from cache.\r\n */ useLoader.clear = function(Proto, input) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.clear)([\n        Proto,\n        ...keys\n    ]);\n};\nconst roots = new Map();\nconst { invalidate, advance } = createLoop(roots);\nconst { reconciler, applyProps } = createRenderer(roots, getEventPriority);\nconst shallowLoose = {\n    objects: \"shallow\",\n    strict: false\n};\nconst createRendererInstance = (gl, canvas)=>{\n    const customRenderer = typeof gl === \"function\" ? gl(canvas) : gl;\n    if (isRenderer(customRenderer)) return customRenderer;\n    else return new three__WEBPACK_IMPORTED_MODULE_4__.WebGLRenderer({\n        powerPreference: \"high-performance\",\n        canvas: canvas,\n        antialias: true,\n        alpha: true,\n        ...gl\n    });\n};\nfunction computeInitialSize(canvas, defaultSize) {\n    const defaultStyle = typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement;\n    if (defaultSize) {\n        const { width, height, top, left, updateStyle = defaultStyle } = defaultSize;\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle\n        };\n    } else if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n        const { width, height, top, left } = canvas.parentElement.getBoundingClientRect();\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle: defaultStyle\n        };\n    } else if (typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return {\n            width: canvas.width,\n            height: canvas.height,\n            top: 0,\n            left: 0,\n            updateStyle: defaultStyle\n        };\n    }\n    return {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n    };\n}\nfunction createRoot(canvas) {\n    // Check against mistaken use of createRoot\n    const prevRoot = roots.get(canvas);\n    const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n    const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n    if (prevRoot) console.warn(\"R3F.createRoot should only be called once!\");\n    // Report when an error was detected in a previous render\n    // https://github.com/pmndrs/react-three-fiber/pull/2261\n    const logRecoverableError = typeof reportError === \"function\" ? // In modern browsers, reportError will dispatch an error event,\n    // emulating an uncaught JavaScript error.\n    reportError : // In older browsers and test environments, fallback to console.error.\n    console.error;\n    // Create store\n    const store = prevStore || createStore(invalidate, advance);\n    // Create renderer\n    const fiber = prevFiber || reconciler.createContainer(store, react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot, null, false, null, \"\", logRecoverableError, null);\n    // Map it\n    if (!prevRoot) roots.set(canvas, {\n        fiber,\n        store\n    });\n    // Locals\n    let onCreated;\n    let configured = false;\n    let lastCamera;\n    return {\n        configure (props = {}) {\n            let { gl: glConfig, size: propsSize, scene: sceneOptions, events, onCreated: onCreatedCallback, shadows = false, linear = false, flat = false, legacy = false, orthographic = false, frameloop = \"always\", dpr = [\n                1,\n                2\n            ], performance: performance1, raycaster: raycastOptions, camera: cameraOptions, onPointerMissed } = props;\n            let state = store.getState();\n            // Set up renderer (one time only!)\n            let gl = state.gl;\n            if (!state.gl) state.set({\n                gl: gl = createRendererInstance(glConfig, canvas)\n            });\n            // Set up raycaster (one time only!)\n            let raycaster = state.raycaster;\n            if (!raycaster) state.set({\n                raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster()\n            });\n            // Set raycaster options\n            const { params, ...options } = raycastOptions || {};\n            if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n                ...options\n            });\n            if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n                params: {\n                    ...raycaster.params,\n                    ...params\n                }\n            });\n            // Create default camera, don't overwrite any user-set state\n            if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n                lastCamera = cameraOptions;\n                const isCamera = cameraOptions instanceof three__WEBPACK_IMPORTED_MODULE_4__.Camera;\n                const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_4__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_4__.PerspectiveCamera(75, 0, 0.1, 1000);\n                if (!isCamera) {\n                    camera.position.z = 5;\n                    if (cameraOptions) applyProps(camera, cameraOptions);\n                    // Always look at center by default\n                    if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n                }\n                state.set({\n                    camera\n                });\n                // Configure raycaster\n                // https://github.com/pmndrs/react-xr/issues/300\n                raycaster.camera = camera;\n            }\n            // Set up scene (one time only!)\n            if (!state.scene) {\n                let scene;\n                if (sceneOptions instanceof three__WEBPACK_IMPORTED_MODULE_4__.Scene) {\n                    scene = sceneOptions;\n                } else {\n                    scene = new three__WEBPACK_IMPORTED_MODULE_4__.Scene();\n                    if (sceneOptions) applyProps(scene, sceneOptions);\n                }\n                state.set({\n                    scene: prepare(scene)\n                });\n            }\n            // Set up XR (one time only!)\n            if (!state.xr) {\n                var _gl$xr;\n                // Handle frame behavior in WebXR\n                const handleXRFrame = (timestamp, frame)=>{\n                    const state = store.getState();\n                    if (state.frameloop === \"never\") return;\n                    advance(timestamp, true, state, frame);\n                };\n                // Toggle render switching on session\n                const handleSessionChange = ()=>{\n                    const state = store.getState();\n                    state.gl.xr.enabled = state.gl.xr.isPresenting;\n                    state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n                    if (!state.gl.xr.isPresenting) invalidate(state);\n                };\n                // WebXR session manager\n                const xr = {\n                    connect () {\n                        const gl = store.getState().gl;\n                        gl.xr.addEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.addEventListener(\"sessionend\", handleSessionChange);\n                    },\n                    disconnect () {\n                        const gl = store.getState().gl;\n                        gl.xr.removeEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.removeEventListener(\"sessionend\", handleSessionChange);\n                    }\n                };\n                // Subscribe to WebXR session events\n                if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === \"function\") xr.connect();\n                state.set({\n                    xr\n                });\n            }\n            // Set shadowmap\n            if (gl.shadowMap) {\n                const oldEnabled = gl.shadowMap.enabled;\n                const oldType = gl.shadowMap.type;\n                gl.shadowMap.enabled = !!shadows;\n                if (is.boo(shadows)) {\n                    gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap;\n                } else if (is.str(shadows)) {\n                    var _types$shadows;\n                    const types = {\n                        basic: three__WEBPACK_IMPORTED_MODULE_4__.BasicShadowMap,\n                        percentage: three__WEBPACK_IMPORTED_MODULE_4__.PCFShadowMap,\n                        soft: three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap,\n                        variance: three__WEBPACK_IMPORTED_MODULE_4__.VSMShadowMap\n                    };\n                    gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap;\n                } else if (is.obj(shadows)) {\n                    Object.assign(gl.shadowMap, shadows);\n                }\n                if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n            }\n            // Safely set color management if available.\n            // Avoid accessing THREE.ColorManagement to play nice with older versions\n            const ColorManagement = getColorManagement();\n            if (ColorManagement) {\n                if (\"enabled\" in ColorManagement) ColorManagement.enabled = !legacy;\n                else if (\"legacyMode\" in ColorManagement) ColorManagement.legacyMode = legacy;\n            }\n            // Set color space and tonemapping preferences\n            const LinearEncoding = 3000;\n            const sRGBEncoding = 3001;\n            applyProps(gl, {\n                outputEncoding: linear ? LinearEncoding : sRGBEncoding,\n                toneMapping: flat ? three__WEBPACK_IMPORTED_MODULE_4__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_4__.ACESFilmicToneMapping\n            });\n            // Update color management state\n            if (state.legacy !== legacy) state.set(()=>({\n                    legacy\n                }));\n            if (state.linear !== linear) state.set(()=>({\n                    linear\n                }));\n            if (state.flat !== flat) state.set(()=>({\n                    flat\n                }));\n            // Set gl props\n            if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n            // Store events internally\n            if (events && !state.events.handlers) state.set({\n                events: events(store)\n            });\n            // Check size, allow it to take on container bounds initially\n            const size = computeInitialSize(canvas, propsSize);\n            if (!is.equ(size, state.size, shallowLoose)) {\n                state.setSize(size.width, size.height, size.updateStyle, size.top, size.left);\n            }\n            // Check pixelratio\n            if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n            // Check frameloop\n            if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n            // Check pointer missed\n            if (!state.onPointerMissed) state.set({\n                onPointerMissed\n            });\n            // Check performance\n            if (performance1 && !is.equ(performance1, state.performance, shallowLoose)) state.set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        ...performance1\n                    }\n                }));\n            // Set locals\n            onCreated = onCreatedCallback;\n            configured = true;\n            return this;\n        },\n        render (children) {\n            // The root has to be configured before it can be rendered\n            if (!configured) this.configure();\n            reconciler.updateContainer(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider, {\n                store: store,\n                children: children,\n                onCreated: onCreated,\n                rootElement: canvas\n            }), fiber, null, ()=>undefined);\n            return store;\n        },\n        unmount () {\n            unmountComponentAtNode(canvas);\n        }\n    };\n}\nfunction render(children, canvas, config) {\n    console.warn(\"R3F.render is no longer supported in React 18. Use createRoot instead!\");\n    const root = createRoot(canvas);\n    root.configure(config);\n    return root.render(children);\n}\nfunction Provider({ store, children, onCreated, rootElement }) {\n    useIsomorphicLayoutEffect(()=>{\n        const state = store.getState();\n        // Flag the canvas active, rendering will now begin\n        state.set((state)=>({\n                internal: {\n                    ...state.internal,\n                    active: true\n                }\n            }));\n        // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n        if (onCreated) onCreated(state);\n        // Connect events to the targets parent, this is done to ensure events are registered on\n        // a shared target, and not on the canvas itself\n        if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: store\n    }, children);\n}\nfunction unmountComponentAtNode(canvas, callback) {\n    const root = roots.get(canvas);\n    const fiber = root == null ? void 0 : root.fiber;\n    if (fiber) {\n        const state = root == null ? void 0 : root.store.getState();\n        if (state) state.internal.active = false;\n        reconciler.updateContainer(null, fiber, null, ()=>{\n            if (state) {\n                setTimeout(()=>{\n                    try {\n                        var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n                        state.events.disconnect == null ? void 0 : state.events.disconnect();\n                        (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n                        (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n                        if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n                        dispose(state);\n                        roots.delete(canvas);\n                        if (callback) callback(canvas);\n                    } catch (e) {\n                    /* ... */ }\n                }, 500);\n            }\n        });\n    }\n}\nfunction createPortal(children, container, state) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Portal, {\n        key: container.uuid,\n        children: children,\n        container: container,\n        state: state\n    });\n}\nfunction Portal({ state = {}, children, container }) {\n    /** This has to be a component because it would not be able to call useThree/useStore otherwise since\r\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\r\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\r\n   *  <Canvas>\r\n   *    {createPortal(...)} */ const { events, size, ...rest } = state;\n    const previousRoot = useStore();\n    const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster());\n    const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Vector2());\n    const inject = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootState, injectState)=>{\n        const intersect = {\n            ...rootState\n        }; // all prev state props\n        // Only the fields of \"rootState\" that do not differ from injectState\n        // Some props should be off-limits\n        // Otherwise filter out the props that are different and let the inject layer take precedence\n        Object.keys(rootState).forEach((key)=>{\n            if (// Some props should be off-limits\n            privateKeys.includes(key) || // Otherwise filter out the props that are different and let the inject layer take precedence\n            // Unless the inject layer props is undefined, then we keep the root layer\n            rootState[key] !== injectState[key] && injectState[key]) {\n                delete intersect[key];\n            }\n        });\n        let viewport = undefined;\n        if (injectState && size) {\n            const camera = injectState.camera;\n            // Calculate the override viewport, if present\n            viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(), size);\n            // Update the portal camera, if it differs from the previous layer\n            if (camera !== rootState.camera) updateCamera(camera, size);\n        }\n        return {\n            // The intersect consists of the previous root state\n            ...intersect,\n            // Portals have their own scene, which forms the root, a raycaster and a pointer\n            scene: container,\n            raycaster,\n            pointer,\n            mouse: pointer,\n            // Their previous root is the layer before it\n            previousRoot,\n            // Events, size and viewport can be overridden by the inject layer\n            events: {\n                ...rootState.events,\n                ...injectState == null ? void 0 : injectState.events,\n                ...events\n            },\n            size: {\n                ...rootState.size,\n                ...size\n            },\n            viewport: {\n                ...rootState.viewport,\n                ...viewport\n            },\n            ...rest\n        };\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        state\n    ]);\n    const [usePortalStore] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        // Create a mirrored store, based on the previous root with a few overrides ...\n        const previousState = previousRoot.getState();\n        const store = (0,zustand__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((set, get)=>({\n                ...previousState,\n                scene: container,\n                raycaster,\n                pointer,\n                mouse: pointer,\n                previousRoot,\n                events: {\n                    ...previousState.events,\n                    ...events\n                },\n                size: {\n                    ...previousState.size,\n                    ...size\n                },\n                ...rest,\n                // Set and get refer to this root-state\n                set,\n                get,\n                // Layers are allowed to override events\n                setEvents: (events)=>set((state)=>({\n                            ...state,\n                            events: {\n                                ...state.events,\n                                ...events\n                            }\n                        }))\n            }));\n        return store;\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n        const unsub = previousRoot.subscribe((prev)=>usePortalStore.setState((state)=>inject(prev, state)));\n        return ()=>{\n            unsub();\n            usePortalStore.destroy();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        usePortalStore.setState((injectState)=>inject(previousRoot.getState(), injectState));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        inject\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, reconciler.createPortal(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: usePortalStore\n    }, children), usePortalStore, null));\n}\nreconciler.injectIntoDevTools({\n    bundleType:  false ? 0 : 1,\n    rendererPackageName: \"@react-three/fiber\",\n    version: react__WEBPACK_IMPORTED_MODULE_0__.version\n});\nconst act = react__WEBPACK_IMPORTED_MODULE_0__.unstable_act;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvaW5kZXgtOGFmYWMwMDQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0E7QUFDbUc7QUFDckc7QUFDYTtBQUNtQztBQUNyQjtBQUV4RCxJQUFJYSxhQUFhLFdBQVcsR0FBRUMsT0FBT0MsTUFBTSxDQUFDO0lBQzFDQyxXQUFXO0FBQ2I7QUFFQSxNQUFNQyxZQUFZLENBQUM7QUFDbkIsTUFBTUMsU0FBU0MsQ0FBQUEsVUFBVyxLQUFLTCxPQUFPTSxNQUFNLENBQUNILFdBQVdFO0FBQ3hELFNBQVNFLGVBQWVDLE1BQU0sRUFBRUMsaUJBQWlCO0lBQy9DLFNBQVNDLGVBQWVDLElBQUksRUFBRSxFQUM1QkMsT0FBTyxFQUFFLEVBQ1RDLE1BQU0sRUFDTixHQUFHQyxPQUNKLEVBQUVDLElBQUk7UUFDTCxJQUFJQyxPQUFPLENBQUMsRUFBRUwsSUFBSSxDQUFDLEVBQUUsQ0FBQ00sV0FBVyxHQUFHLEVBQUVOLEtBQUtPLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDckQsSUFBSUM7UUFDSixJQUFJUixTQUFTLGFBQWE7WUFDeEIsSUFBSUcsTUFBTU0sTUFBTSxLQUFLQyxXQUFXLE1BQU0sSUFBSUMsTUFBTTtZQUNoRCxNQUFNRixTQUFTTixNQUFNTSxNQUFNO1lBQzNCRCxXQUFXSSxRQUFRSCxRQUFRO2dCQUN6QlQ7Z0JBQ0FJO2dCQUNBRjtnQkFDQVcsV0FBVztZQUNiO1FBQ0YsT0FBTztZQUNMLE1BQU1DLFNBQVN0QixTQUFTLENBQUNhLEtBQUs7WUFDOUIsSUFBSSxDQUFDUyxRQUFRO2dCQUNYLE1BQU0sSUFBSUgsTUFBTSxDQUFDLEtBQUssRUFBRU4sS0FBSyw0SkFBNEosQ0FBQztZQUM1TDtZQUVBLG9EQUFvRDtZQUNwRCxJQUFJLENBQUNVLE1BQU1DLE9BQU8sQ0FBQ2YsT0FBTyxNQUFNLElBQUlVLE1B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QUFRLENBQUNMLENBQUFBLGNBQWVGLE9BQU96WSxhQUFhakksUUFBUSxJQUFJNGdCO0lBQ3ZFLHVEQUF1RDtJQUN6RCxHQUFHO1FBQUNGO0tBQU87SUFDWCxPQUFPLFdBQVcsR0FBRTVtQixnREFBbUIsQ0FBQ0EsMkNBQWMsRUFBRSxNQUFNNEcsV0FBVzRmLFlBQVksQ0FBRSxXQUFXLEdBQUV4bUIsZ0RBQW1CLENBQUN3YSxRQUFRcUwsUUFBUSxFQUFFO1FBQ3hJbGQsT0FBT29lO0lBQ1QsR0FBRy9pQixXQUFXK2lCLGdCQUFnQjtBQUNoQztBQUNBbmdCLFdBQVcwZ0Isa0JBQWtCLENBQUM7SUFDNUJDLFlBQVl0VyxNQUF5QixHQUFlLENBQUMsR0FBRztJQUN4RHVXLHFCQUFxQjtJQUNyQkMsU0FBU3puQiwwQ0FBYTtBQUN4QjtBQUNBLE1BQU0wbkIsTUFBTTFuQiwrQ0FBa0I7QUFFdWhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm9ja2V0c2ltLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9kaXN0L2luZGV4LThhZmFjMDA0LmVzbS5qcz9iNDJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERlZmF1bHRFdmVudFByaW9yaXR5LCBDb250aW51b3VzRXZlbnRQcmlvcml0eSwgRGlzY3JldGVFdmVudFByaW9yaXR5LCBDb25jdXJyZW50Um9vdCB9IGZyb20gJ3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzJztcbmltcG9ydCBjcmVhdGUgZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgUmVjb25jaWxlciBmcm9tICdyZWFjdC1yZWNvbmNpbGVyJztcbmltcG9ydCB7IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssIHVuc3RhYmxlX0lkbGVQcmlvcml0eSB9IGZyb20gJ3NjaGVkdWxlcic7XG5pbXBvcnQgeyBzdXNwZW5kLCBwcmVsb2FkLCBjbGVhciB9IGZyb20gJ3N1c3BlbmQtcmVhY3QnO1xuXG52YXIgdGhyZWVUeXBlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsXG59KTtcblxuY29uc3QgY2F0YWxvZ3VlID0ge307XG5jb25zdCBleHRlbmQgPSBvYmplY3RzID0+IHZvaWQgT2JqZWN0LmFzc2lnbihjYXRhbG9ndWUsIG9iamVjdHMpO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIoX3Jvb3RzLCBfZ2V0RXZlbnRQcmlvcml0eSkge1xuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSh0eXBlLCB7XG4gICAgYXJncyA9IFtdLFxuICAgIGF0dGFjaCxcbiAgICAuLi5wcm9wc1xuICB9LCByb290KSB7XG4gICAgbGV0IG5hbWUgPSBgJHt0eXBlWzBdLnRvVXBwZXJDYXNlKCl9JHt0eXBlLnNsaWNlKDEpfWA7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIGlmICh0eXBlID09PSAncHJpbWl0aXZlJykge1xuICAgICAgaWYgKHByb3BzLm9iamVjdCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJSM0Y6IFByaW1pdGl2ZXMgd2l0aG91dCAnb2JqZWN0JyBhcmUgaW52YWxpZCFcIik7XG4gICAgICBjb25zdCBvYmplY3QgPSBwcm9wcy5vYmplY3Q7XG4gICAgICBpbnN0YW5jZSA9IHByZXBhcmUob2JqZWN0LCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJvb3QsXG4gICAgICAgIGF0dGFjaCxcbiAgICAgICAgcHJpbWl0aXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gY2F0YWxvZ3VlW25hbWVdO1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSM0Y6ICR7bmFtZX0gaXMgbm90IHBhcnQgb2YgdGhlIFRIUkVFIG5hbWVzcGFjZSEgRGlkIHlvdSBmb3JnZXQgdG8gZXh0ZW5kPyBTZWU6IGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9vYmplY3RzI3VzaW5nLTNyZC1wYXJ0eS1vYmplY3RzLWRlY2xhcmF0aXZlbHlgKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhyb3cgaWYgYW4gb2JqZWN0IG9yIGxpdGVyYWwgd2FzIHBhc3NlZCBmb3IgYXJnc1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3MpKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogVGhlIGFyZ3MgcHJvcCBtdXN0IGJlIGFuIGFycmF5IScpO1xuXG4gICAgICAvLyBJbnN0YW5jaWF0ZSBuZXcgb2JqZWN0LCBsaW5rIGl0IHRvIHRoZSByb290XG4gICAgICAvLyBBcHBlbmQgbWVtb2l6ZWQgcHJvcHMgd2l0aCBhcmdzIHNvIGl0J3Mgbm90IGZvcmdvdHRlblxuICAgICAgaW5zdGFuY2UgPSBwcmVwYXJlKG5ldyB0YXJnZXQoLi4uYXJncyksIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgYXR0YWNoLFxuICAgICAgICAvLyBTYXZlIGFyZ3MgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlY29uc3RydWN0IGxhdGVyIGZvciBITVJcbiAgICAgICAgbWVtb2l6ZWRQcm9wczoge1xuICAgICAgICAgIGFyZ3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQXV0by1hdHRhY2ggZ2VvbWV0cmllcyBhbmQgbWF0ZXJpYWxzXG4gICAgaWYgKGluc3RhbmNlLl9fcjNmLmF0dGFjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSkgaW5zdGFuY2UuX19yM2YuYXR0YWNoID0gJ2dlb21ldHJ5JztlbHNlIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFRIUkVFLk1hdGVyaWFsKSBpbnN0YW5jZS5fX3IzZi5hdHRhY2ggPSAnbWF0ZXJpYWwnO1xuICAgIH1cblxuICAgIC8vIEl0IHNob3VsZCBOT1QgY2FsbCBvblVwZGF0ZSBvbiBvYmplY3QgaW5zdGFuY2lhdGlvbiwgYmVjYXVzZSBpdCBoYXNuJ3QgYmVlbiBhZGRlZCB0byB0aGVcbiAgICAvLyB2aWV3IHlldC4gSWYgdGhlIGNhbGxiYWNrIHJlbGllcyBvbiByZWZlcmVuY2VzIGZvciBpbnN0YW5jZSwgdGhleSB3b24ndCBiZSByZWFkeSB5ZXQsIHRoaXMgaXNcbiAgICAvLyB3aHkgaXQgcGFzc2VzIFwidHJ1ZVwiIGhlcmVcbiAgICAvLyBUaGVyZSBpcyBubyByZWFzb24gdG8gYXBwbHkgcHJvcHMgdG8gaW5qZWN0c1xuICAgIGlmIChuYW1lICE9PSAnaW5qZWN0JykgYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9jaGlsZCRfX3IzZiwgX3BhcmVudEluc3RhbmNlJF9fcjNmO1xuICAgICAgLy8gVGhlIGF0dGFjaCBhdHRyaWJ1dGUgaW1wbGllcyB0aGF0IHRoZSBvYmplY3QgYXR0YWNoZXMgaXRzZWxmIG9uIHRoZSBwYXJlbnRcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBjaGlsZC5fX3IzZi5hdHRhY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEICYmIHBhcmVudEluc3RhbmNlLmlzT2JqZWN0M0QpIHtcbiAgICAgICAgLy8gYWRkIGluIHRoZSB1c3VhbCBwYXJlbnQtY2hpbGQgd2F5XG4gICAgICAgIHBhcmVudEluc3RhbmNlLmFkZChjaGlsZCk7XG4gICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaXMgZm9yIGFueXRoaW5nIHRoYXQgdXNlZCBhdHRhY2gsIGFuZCBmb3Igbm9uLU9iamVjdDNEcyB0aGF0IGRvbid0IGdldCBhdHRhY2hlZCB0byBwcm9wcztcbiAgICAgIC8vIHRoYXQgaXMsIGFueXRoaW5nIHRoYXQncyBhIGNoaWxkIGluIFJlYWN0IGJ1dCBub3QgYSBjaGlsZCBpbiB0aGUgc2NlbmVncmFwaC5cbiAgICAgIGlmICghYWRkZWQpIChfcGFyZW50SW5zdGFuY2UkX19yM2YgPSBwYXJlbnRJbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJlbnRJbnN0YW5jZSRfX3IzZi5vYmplY3RzLnB1c2goY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5fX3IzZikgcHJlcGFyZShjaGlsZCwge30pO1xuICAgICAgY2hpbGQuX19yM2YucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9jaGlsZCRfX3IzZjIsIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjI7XG4gICAgICBpZiAoKF9jaGlsZCRfX3IzZjIgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2YyLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBjaGlsZC5fX3IzZi5hdHRhY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEICYmIHBhcmVudEluc3RhbmNlLmlzT2JqZWN0M0QpIHtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICAgIGNoaWxkLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdhZGRlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3RTaWJsaW5ncyA9IHBhcmVudEluc3RhbmNlLmNoaWxkcmVuLmZpbHRlcihzaWJsaW5nID0+IHNpYmxpbmcgIT09IGNoaWxkKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSByZXN0U2libGluZ3MuaW5kZXhPZihiZWZvcmVDaGlsZCk7XG4gICAgICAgIHBhcmVudEluc3RhbmNlLmNoaWxkcmVuID0gWy4uLnJlc3RTaWJsaW5ncy5zbGljZSgwLCBpbmRleCksIGNoaWxkLCAuLi5yZXN0U2libGluZ3Muc2xpY2UoaW5kZXgpXTtcbiAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhZGRlZCkgKF9wYXJlbnRJbnN0YW5jZSRfX3IzZjIgPSBwYXJlbnRJbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJlbnRJbnN0YW5jZSRfX3IzZjIub2JqZWN0cy5wdXNoKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuX19yM2YpIHByZXBhcmUoY2hpbGQsIHt9KTtcbiAgICAgIGNoaWxkLl9fcjNmLnBhcmVudCA9IHBhcmVudEluc3RhbmNlO1xuICAgICAgdXBkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlUmVjdXJzaXZlKGFycmF5LCBwYXJlbnQsIGRpc3Bvc2UgPSBmYWxzZSkge1xuICAgIGlmIChhcnJheSkgWy4uLmFycmF5XS5mb3JFYWNoKGNoaWxkID0+IHJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGQsIGRpc3Bvc2UpKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGRpc3Bvc2UpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIHZhciBfcGFyZW50SW5zdGFuY2UkX19yM2YzLCBfY2hpbGQkX19yM2YzLCBfY2hpbGQkX19yM2Y1O1xuICAgICAgLy8gQ2xlYXIgdGhlIHBhcmVudCByZWZlcmVuY2VcbiAgICAgIGlmIChjaGlsZC5fX3IzZikgY2hpbGQuX19yM2YucGFyZW50ID0gbnVsbDtcbiAgICAgIC8vIFJlbW92ZSBjaGlsZCBmcm9tIHRoZSBwYXJlbnRzIG9iamVjdHNcbiAgICAgIGlmICgoX3BhcmVudEluc3RhbmNlJF9fcjNmMyA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSAhPSBudWxsICYmIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjMub2JqZWN0cykgcGFyZW50SW5zdGFuY2UuX19yM2Yub2JqZWN0cyA9IHBhcmVudEluc3RhbmNlLl9fcjNmLm9iamVjdHMuZmlsdGVyKHggPT4geCAhPT0gY2hpbGQpO1xuICAgICAgLy8gUmVtb3ZlIGF0dGFjaG1lbnRcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmMyA9IGNoaWxkLl9fcjNmKSAhPSBudWxsICYmIF9jaGlsZCRfX3IzZjMuYXR0YWNoKSB7XG4gICAgICAgIGRldGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICB2YXIgX2NoaWxkJF9fcjNmNDtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAvLyBSZW1vdmUgaW50ZXJhY3Rpdml0eSBvbiB0aGUgaW5pdGlhbCByb290XG4gICAgICAgIGlmICgoX2NoaWxkJF9fcjNmNCA9IGNoaWxkLl9fcjNmKSAhPSBudWxsICYmIF9jaGlsZCRfX3IzZjQucm9vdCkge1xuICAgICAgICAgIHJlbW92ZUludGVyYWN0aXZpdHkoZmluZEluaXRpYWxSb290KGNoaWxkKSwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbG93IG9iamVjdHMgdG8gYmFpbCBvdXQgb2YgcmVjdXJzaXZlIGRpc3Bvc2UgYWx0b2dldGhlciBieSBwYXNzaW5nIGRpc3Bvc2U9e251bGx9XG4gICAgICAvLyBOZXZlciBkaXNwb3NlIG9mIHByaW1pdGl2ZXMgYmVjYXVzZSB0aGVpciBzdGF0ZSBtYXkgYmUga2VwdCBvdXRzaWRlIG9mIFJlYWN0IVxuICAgICAgLy8gSW4gb3JkZXIgZm9yIGFuIG9iamVjdCB0byBiZSBhYmxlIHRvIGRpc3Bvc2UgaXQgaGFzIHRvIGhhdmVcbiAgICAgIC8vICAgLSBhIGRpc3Bvc2UgbWV0aG9kLFxuICAgICAgLy8gICAtIGl0IGNhbm5vdCBiZSBhIDxwcmltaXRpdmUgb2JqZWN0PXsuLi59IC8+XG4gICAgICAvLyAgIC0gaXQgY2Fubm90IGJlIGEgVEhSRUUuU2NlbmUsIGJlY2F1c2UgdGhyZWUgaGFzIGJyb2tlbiBpdCdzIG93biBhcGlcbiAgICAgIC8vXG4gICAgICAvLyBTaW5jZSBkaXNwb3NhbCBpcyByZWN1cnNpdmUsIHdlIGNhbiBjaGVjayB0aGUgb3B0aW9uYWwgZGlzcG9zZSBhcmcsIHdoaWNoIHdpbGwgYmUgdW5kZWZpbmVkXG4gICAgICAvLyB3aGVuIHRoZSByZWNvbmNpbGVyIGNhbGxzIGl0LCBidXQgdGhlbiBjYXJyeSBvdXIgb3duIGNoZWNrIHJlY3Vyc2l2ZWx5XG4gICAgICBjb25zdCBpc1ByaW1pdGl2ZSA9IChfY2hpbGQkX19yM2Y1ID0gY2hpbGQuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfY2hpbGQkX19yM2Y1LnByaW1pdGl2ZTtcbiAgICAgIGNvbnN0IHNob3VsZERpc3Bvc2UgPSAhaXNQcmltaXRpdmUgJiYgKGRpc3Bvc2UgPT09IHVuZGVmaW5lZCA/IGNoaWxkLmRpc3Bvc2UgIT09IG51bGwgOiBkaXNwb3NlKTtcblxuICAgICAgLy8gUmVtb3ZlIG5lc3RlZCBjaGlsZCBvYmplY3RzLiBQcmltaXRpdmVzIHNob3VsZCBub3QgaGF2ZSBvYmplY3RzIGFuZCBjaGlsZHJlbiB0aGF0IGFyZVxuICAgICAgLy8gYXR0YWNoZWQgdG8gdGhlbSBkZWNsYXJhdGl2ZWx5IC4uLlxuICAgICAgaWYgKCFpc1ByaW1pdGl2ZSkge1xuICAgICAgICB2YXIgX2NoaWxkJF9fcjNmNjtcbiAgICAgICAgcmVtb3ZlUmVjdXJzaXZlKChfY2hpbGQkX19yM2Y2ID0gY2hpbGQuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfY2hpbGQkX19yM2Y2Lm9iamVjdHMsIGNoaWxkLCBzaG91bGREaXNwb3NlKTtcbiAgICAgICAgcmVtb3ZlUmVjdXJzaXZlKGNoaWxkLmNoaWxkcmVuLCBjaGlsZCwgc2hvdWxkRGlzcG9zZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSByZWZlcmVuY2VzXG4gICAgICBkZWxldGUgY2hpbGQuX19yM2Y7XG5cbiAgICAgIC8vIERpc3Bvc2UgaXRlbSB3aGVuZXZlciB0aGUgcmVjb25jaWxlciBmZWVscyBsaWtlIGl0XG4gICAgICBpZiAoc2hvdWxkRGlzcG9zZSAmJiBjaGlsZC5kaXNwb3NlICYmIGNoaWxkLnR5cGUgIT09ICdTY2VuZScpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNoaWxkLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiAuLi4gKi9cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2NoZWR1bGUgYXN5bmMgYXQgcnVudGltZSwgZmx1c2ggc3luYyBpbiB0ZXN0aW5nXG4gICAgICAgIGlmICh0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sodW5zdGFibGVfSWRsZVByaW9yaXR5LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKHBhcmVudEluc3RhbmNlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3dpdGNoSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCBmaWJlcikge1xuICAgIHZhciBfaW5zdGFuY2UkX19yM2Y7XG4gICAgY29uc3QgcGFyZW50ID0gKF9pbnN0YW5jZSRfX3IzZiA9IGluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJF9fcjNmLnBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkgcmV0dXJuO1xuICAgIGNvbnN0IG5ld0luc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIGluc3RhbmNlLl9fcjNmLnJvb3QpO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMTM0OFxuICAgIC8vIFdoZW4gYXJncyBjaGFuZ2UgdGhlIGluc3RhbmNlIGhhcyB0byBiZSByZS1jb25zdHJ1Y3RlZCwgd2hpY2ggdGhlblxuICAgIC8vIGZvcmNlcyByM2YgdG8gcmUtcGFyZW50IHRoZSBjaGlsZHJlbiBhbmQgbm9uLXNjZW5lIG9iamVjdHNcbiAgICBpZiAoaW5zdGFuY2UuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgaW5zdGFuY2UuY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkLl9fcjNmKSBhcHBlbmRDaGlsZChuZXdJbnN0YW5jZSwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2UuY2hpbGRyZW4gPSBpbnN0YW5jZS5jaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gIWNoaWxkLl9fcjNmKTtcbiAgICB9XG4gICAgaW5zdGFuY2UuX19yM2Yub2JqZWN0cy5mb3JFYWNoKGNoaWxkID0+IGFwcGVuZENoaWxkKG5ld0luc3RhbmNlLCBjaGlsZCkpO1xuICAgIGluc3RhbmNlLl9fcjNmLm9iamVjdHMgPSBbXTtcbiAgICBpZiAoIWluc3RhbmNlLl9fcjNmLmF1dG9SZW1vdmVkQmVmb3JlQXBwZW5kKSB7XG4gICAgICByZW1vdmVDaGlsZChwYXJlbnQsIGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKG5ld0luc3RhbmNlLnBhcmVudCkge1xuICAgICAgbmV3SW5zdGFuY2UuX19yM2YuYXV0b1JlbW92ZWRCZWZvcmVBcHBlbmQgPSB0cnVlO1xuICAgIH1cbiAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5ld0luc3RhbmNlKTtcblxuICAgIC8vIFJlLWJpbmQgZXZlbnQgaGFuZGxlcnMgb24gdGhlIGluaXRpYWwgcm9vdFxuICAgIGlmIChuZXdJbnN0YW5jZS5yYXljYXN0ICYmIG5ld0luc3RhbmNlLl9fcjNmLmV2ZW50Q291bnQpIHtcbiAgICAgIGNvbnN0IHJvb3RTdGF0ZSA9IGZpbmRJbml0aWFsUm9vdChuZXdJbnN0YW5jZSkuZ2V0U3RhdGUoKTtcbiAgICAgIHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5wdXNoKG5ld0luc3RhbmNlKTtcbiAgICB9XG4gICAgW2ZpYmVyLCBmaWJlci5hbHRlcm5hdGVdLmZvckVhY2goZmliZXIgPT4ge1xuICAgICAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuICAgICAgICBpZiAoZmliZXIucmVmKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWJlci5yZWYgPT09ICdmdW5jdGlvbicpIGZpYmVyLnJlZihuZXdJbnN0YW5jZSk7ZWxzZSBmaWJlci5yZWYuY3VycmVudCA9IG5ld0luc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBEb24ndCBoYW5kbGUgdGV4dCBpbnN0YW5jZXMsIHdhcm4gb24gdW5kZWZpbmVkIGJlaGF2aW9yXG4gIGNvbnN0IGhhbmRsZVRleHRJbnN0YW5jZSA9ICgpID0+IGNvbnNvbGUud2FybignVGV4dCBpcyBub3QgYWxsb3dlZCBpbiB0aGUgUjNGIHRyZWUhIFRoaXMgY291bGQgYmUgc3RyYXkgd2hpdGVzcGFjZSBvciBjaGFyYWN0ZXJzLicpO1xuICBjb25zdCByZWNvbmNpbGVyID0gUmVjb25jaWxlcih7XG4gICAgY3JlYXRlSW5zdGFuY2UsXG4gICAgcmVtb3ZlQ2hpbGQsXG4gICAgYXBwZW5kQ2hpbGQsXG4gICAgYXBwZW5kSW5pdGlhbENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgICBpbnNlcnRCZWZvcmUsXG4gICAgc3VwcG9ydHNNdXRhdGlvbjogdHJ1ZSxcbiAgICBpc1ByaW1hcnlSZW5kZXJlcjogZmFsc2UsXG4gICAgc3VwcG9ydHNQZXJzaXN0ZW5jZTogZmFsc2UsXG4gICAgc3VwcG9ydHNIeWRyYXRpb246IGZhbHNlLFxuICAgIG5vVGltZW91dDogLTEsXG4gICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjogKGNvbnRhaW5lciwgY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQpIHJldHVybjtcblxuICAgICAgLy8gRG9uJ3QgYXBwZW5kIHRvIHVubW91bnRlZCBjb250YWluZXJcbiAgICAgIGNvbnN0IHNjZW5lID0gY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmU7XG4gICAgICBpZiAoIXNjZW5lLl9fcjNmKSByZXR1cm47XG5cbiAgICAgIC8vIExpbmsgY3VycmVudCByb290IHRvIHRoZSBkZWZhdWx0IHNjZW5lXG4gICAgICBzY2VuZS5fX3IzZi5yb290ID0gY29udGFpbmVyO1xuICAgICAgYXBwZW5kQ2hpbGQoc2NlbmUsIGNoaWxkKTtcbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjogKGNvbnRhaW5lciwgY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQpIHJldHVybjtcbiAgICAgIHJlbW92ZUNoaWxkKGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lLCBjaGlsZCk7XG4gICAgfSxcbiAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTogKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSA9PiB7XG4gICAgICBpZiAoIWNoaWxkIHx8ICFiZWZvcmVDaGlsZCkgcmV0dXJuO1xuXG4gICAgICAvLyBEb24ndCBhcHBlbmQgdG8gdW5tb3VudGVkIGNvbnRhaW5lclxuICAgICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZTtcbiAgICAgIGlmICghc2NlbmUuX19yM2YpIHJldHVybjtcbiAgICAgIGluc2VydEJlZm9yZShzY2VuZSwgY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICB9LFxuICAgIGdldFJvb3RIb3N0Q29udGV4dDogKCkgPT4gbnVsbCxcbiAgICBnZXRDaGlsZEhvc3RDb250ZXh0OiBwYXJlbnRIb3N0Q29udGV4dCA9PiBwYXJlbnRIb3N0Q29udGV4dCxcbiAgICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihpbnN0YW5jZSkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjI7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjIgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2YyIDoge307XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwMjcxXG4gICAgICAvLyBSZXR1cm5pbmcgdHJ1ZSB3aWxsIHRyaWdnZXIgY29tbWl0TW91bnRcbiAgICAgIHJldHVybiBCb29sZWFuKGxvY2FsU3RhdGUuaGFuZGxlcnMpO1xuICAgIH0sXG4gICAgcHJlcGFyZVVwZGF0ZShpbnN0YW5jZSwgX3R5cGUsIG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjM7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2YzIDoge307XG5cbiAgICAgIC8vIENyZWF0ZSBkaWZmLXNldHNcbiAgICAgIGlmIChsb2NhbFN0YXRlLnByaW1pdGl2ZSAmJiBuZXdQcm9wcy5vYmplY3QgJiYgbmV3UHJvcHMub2JqZWN0ICE9PSBpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gW3RydWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGRhdGEgb2JqZWN0LCBsZXQncyBleHRyYWN0IGNyaXRpY2FsIGluZm9ybWF0aW9uIGFib3V0IGl0XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhcmdzOiBhcmdzTmV3ID0gW10sXG4gICAgICAgICAgY2hpbGRyZW46IGNOLFxuICAgICAgICAgIC4uLnJlc3ROZXdcbiAgICAgICAgfSA9IG5ld1Byb3BzO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYXJnczogYXJnc09sZCA9IFtdLFxuICAgICAgICAgIGNoaWxkcmVuOiBjTyxcbiAgICAgICAgICAuLi5yZXN0T2xkXG4gICAgICAgIH0gPSBvbGRQcm9wcztcblxuICAgICAgICAvLyBUaHJvdyBpZiBhbiBvYmplY3Qgb3IgbGl0ZXJhbCB3YXMgcGFzc2VkIGZvciBhcmdzXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmdzTmV3KSkgdGhyb3cgbmV3IEVycm9yKCdSM0Y6IHRoZSBhcmdzIHByb3AgbXVzdCBiZSBhbiBhcnJheSEnKTtcblxuICAgICAgICAvLyBJZiBpdCBoYXMgbmV3IHByb3BzIG9yIGFyZ3VtZW50cywgdGhlbiBpdCBuZWVkcyB0byBiZSByZS1pbnN0YW50aWF0ZWRcbiAgICAgICAgaWYgKGFyZ3NOZXcuc29tZSgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZSAhPT0gYXJnc09sZFtpbmRleF0pKSByZXR1cm4gW3RydWVdO1xuICAgICAgICAvLyBDcmVhdGUgYSBkaWZmLXNldCwgZmxhZyBpZiB0aGVyZSBhcmUgYW55IGNoYW5nZXNcbiAgICAgICAgY29uc3QgZGlmZiA9IGRpZmZQcm9wcyhpbnN0YW5jZSwgcmVzdE5ldywgcmVzdE9sZCwgdHJ1ZSk7XG4gICAgICAgIGlmIChkaWZmLmNoYW5nZXMubGVuZ3RoKSByZXR1cm4gW2ZhbHNlLCBkaWZmXTtcblxuICAgICAgICAvLyBPdGhlcndpc2UgZG8gbm90IHRvdWNoIHRoZSBpbnN0YW5jZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1pdFVwZGF0ZShpbnN0YW5jZSwgW3JlY29uc3RydWN0LCBkaWZmXSwgdHlwZSwgX29sZFByb3BzLCBuZXdQcm9wcywgZmliZXIpIHtcbiAgICAgIC8vIFJlY29uc3RydWN0IHdoZW4gYXJncyBvciA8cHJpbWl0aXZlIG9iamVjdD17Li4ufSBoYXZlIGNoYW5nZXNcbiAgICAgIGlmIChyZWNvbnN0cnVjdCkgc3dpdGNoSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCBmaWJlcik7XG4gICAgICAvLyBPdGhlcndpc2UganVzdCBvdmVyd3JpdGUgcHJvcHNcbiAgICAgIGVsc2UgYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBkaWZmKTtcbiAgICB9LFxuICAgIGNvbW1pdE1vdW50KGluc3RhbmNlLCBfdHlwZSwgX3Byb3BzLCBfaW50KSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmNDtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjAyNzFcbiAgICAgIC8vIFRoaXMgd2lsbCBtYWtlIHN1cmUgZXZlbnRzIGFyZSBvbmx5IGFkZGVkIG9uY2UgdG8gdGhlIGNlbnRyYWwgY29udGFpbmVyIG9uIHRoZSBpbml0aWFsIHJvb3RcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmNCA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmNCA6IHt9O1xuICAgICAgaWYgKGluc3RhbmNlLnJheWNhc3QgJiYgbG9jYWxTdGF0ZS5oYW5kbGVycyAmJiBsb2NhbFN0YXRlLmV2ZW50Q291bnQpIHtcbiAgICAgICAgZmluZEluaXRpYWxSb290KGluc3RhbmNlKS5nZXRTdGF0ZSgpLmludGVybmFsLmludGVyYWN0aW9uLnB1c2goaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UHVibGljSW5zdGFuY2U6IGluc3RhbmNlID0+IGluc3RhbmNlLFxuICAgIHByZXBhcmVGb3JDb21taXQ6ICgpID0+IG51bGwsXG4gICAgcHJlcGFyZVBvcnRhbE1vdW50OiBjb250YWluZXIgPT4gcHJlcGFyZShjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZSksXG4gICAgcmVzZXRBZnRlckNvbW1pdDogKCkgPT4ge30sXG4gICAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6ICgpID0+IGZhbHNlLFxuICAgIGNsZWFyQ29udGFpbmVyOiAoKSA9PiBmYWxzZSxcbiAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y1O1xuICAgICAgLy8gRGV0YWNoIHdoaWxlIHRoZSBpbnN0YW5jZSBpcyBoaWRkZW5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXR0YWNoOiB0eXBlLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSAoX2luc3RhbmNlJF9fcjNmNSA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmNSA6IHt9O1xuICAgICAgaWYgKHR5cGUgJiYgcGFyZW50KSBkZXRhY2gocGFyZW50LCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICBpZiAoaW5zdGFuY2UuaXNPYmplY3QzRCkgaW5zdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICB9LFxuICAgIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlLCBwcm9wcykge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjY7XG4gICAgICAvLyBSZS1hdHRhY2ggd2hlbiB0aGUgaW5zdGFuY2UgaXMgdW5oaWRkZW5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXR0YWNoOiB0eXBlLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSAoX2luc3RhbmNlJF9fcjNmNiA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmNiA6IHt9O1xuICAgICAgaWYgKHR5cGUgJiYgcGFyZW50KSBhdHRhY2gocGFyZW50LCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICBpZiAoaW5zdGFuY2UuaXNPYmplY3QzRCAmJiBwcm9wcy52aXNpYmxlID09IG51bGwgfHwgcHJvcHMudmlzaWJsZSkgaW5zdGFuY2UudmlzaWJsZSA9IHRydWU7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIH0sXG4gICAgY3JlYXRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gICAgaGlkZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICAgIHVuaGlkZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yMzYwI2Rpc2N1c3Npb25fcjkxNjM1Njg3NFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBnZXRDdXJyZW50RXZlbnRQcmlvcml0eTogKCkgPT4gX2dldEV2ZW50UHJpb3JpdHkgPyBfZ2V0RXZlbnRQcmlvcml0eSgpIDogRGVmYXVsdEV2ZW50UHJpb3JpdHksXG4gICAgYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyOiAoKSA9PiB7fSxcbiAgICBhZnRlckFjdGl2ZUluc3RhbmNlQmx1cjogKCkgPT4ge30sXG4gICAgZGV0YWNoRGVsZXRlZEluc3RhbmNlOiAoKSA9PiB7fSxcbiAgICBub3c6IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXMuZnVuKHBlcmZvcm1hbmNlLm5vdykgPyBwZXJmb3JtYW5jZS5ub3cgOiBpcy5mdW4oRGF0ZS5ub3cpID8gRGF0ZS5ub3cgOiAoKSA9PiAwLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yMzYwI2Rpc2N1c3Npb25fcjkyMDg4MzUwM1xuICAgIHNjaGVkdWxlVGltZW91dDogaXMuZnVuKHNldFRpbWVvdXQpID8gc2V0VGltZW91dCA6IHVuZGVmaW5lZCxcbiAgICBjYW5jZWxUaW1lb3V0OiBpcy5mdW4oY2xlYXJUaW1lb3V0KSA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICByZWNvbmNpbGVyLFxuICAgIGFwcGx5UHJvcHM6IGFwcGx5UHJvcHMkMVxuICB9O1xufVxuXG52YXIgX3dpbmRvdyRkb2N1bWVudCwgX3dpbmRvdyRuYXZpZ2F0b3I7XG4vKipcclxuICogUmV0dXJucyBgdHJ1ZWAgd2l0aCBjb3JyZWN0IFRTIHR5cGUgaW5mZXJlbmNlIGlmIGFuIG9iamVjdCBoYXMgYSBjb25maWd1cmFibGUgY29sb3Igc3BhY2UgKHNpbmNlIHIxNTIpLlxyXG4gKi9cbmNvbnN0IGhhc0NvbG9yU3BhY2UgPSBvYmplY3QgPT4gJ2NvbG9yU3BhY2UnIGluIG9iamVjdCB8fCAnb3V0cHV0Q29sb3JTcGFjZScgaW4gb2JqZWN0O1xuLyoqXHJcbiAqIFRoZSBjdXJyZW50IFRIUkVFLkNvbG9yTWFuYWdlbWVudCBpbnN0YW5jZSwgaWYgcHJlc2VudC5cclxuICovXG5jb25zdCBnZXRDb2xvck1hbmFnZW1lbnQgPSAoKSA9PiB7XG4gIHZhciBfQ29sb3JNYW5hZ2VtZW50O1xuICByZXR1cm4gKF9Db2xvck1hbmFnZW1lbnQgPSBjYXRhbG9ndWUuQ29sb3JNYW5hZ2VtZW50KSAhPSBudWxsID8gX0NvbG9yTWFuYWdlbWVudCA6IG51bGw7XG59O1xuY29uc3QgaXNPcnRob2dyYXBoaWNDYW1lcmEgPSBkZWYgPT4gZGVmICYmIGRlZi5pc09ydGhvZ3JhcGhpY0NhbWVyYTtcbmNvbnN0IGlzUmVmID0gb2JqID0+IG9iaiAmJiBvYmouaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKTtcblxuLyoqXHJcbiAqIEFuIFNTUi1mcmllbmRseSB1c2VMYXlvdXRFZmZlY3QuXHJcbiAqXHJcbiAqIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXHJcbiAqIFRvIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXHJcbiAqIHVzZUxheW91dEVmZmVjdCBlbHNld2hlcmUuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDkyN1xyXG4gKi9cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKF93aW5kb3ckZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQpICE9IG51bGwgJiYgX3dpbmRvdyRkb2N1bWVudC5jcmVhdGVFbGVtZW50IHx8ICgoX3dpbmRvdyRuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyRuYXZpZ2F0b3IucHJvZHVjdCkgPT09ICdSZWFjdE5hdGl2ZScpID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuZnVuY3Rpb24gdXNlTXV0YWJsZUNhbGxiYWNrKGZuKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihmbik7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gdm9pZCAocmVmLmN1cnJlbnQgPSBmbiksIFtmbl0pO1xuICByZXR1cm4gcmVmO1xufVxuZnVuY3Rpb24gQmxvY2soe1xuICBzZXRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2V0KG5ldyBQcm9taXNlKCgpID0+IG51bGwpKTtcbiAgICByZXR1cm4gKCkgPT4gc2V0KGZhbHNlKTtcbiAgfSwgW3NldF0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmNsYXNzIEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVycm9yOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgdGhpcy5wcm9wcy5zZXQoZXJyKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgPyBudWxsIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufVxuRXJyb3JCb3VuZGFyeS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSAoKSA9PiAoe1xuICBlcnJvcjogdHJ1ZVxufSk7XG5jb25zdCBERUZBVUxUID0gJ19fZGVmYXVsdCc7XG5jb25zdCBERUZBVUxUUyA9IG5ldyBNYXAoKTtcbmNvbnN0IGlzRGlmZlNldCA9IGRlZiA9PiBkZWYgJiYgISFkZWYubWVtb2l6ZWQgJiYgISFkZWYuY2hhbmdlcztcbmZ1bmN0aW9uIGNhbGN1bGF0ZURwcihkcHIpIHtcbiAgdmFyIF93aW5kb3ckZGV2aWNlUGl4ZWxSYTtcbiAgLy8gRXJyIG9uIHRoZSBzaWRlIG9mIHByb2dyZXNzIGJ5IGFzc3VtaW5nIDJ4IGRwciBpZiB3ZSBjYW4ndCBkZXRlY3QgaXRcbiAgLy8gVGhpcyB3aWxsIGhhcHBlbiBpbiB3b3JrZXJzIHdoZXJlIHdpbmRvdyBpcyBkZWZpbmVkIGJ1dCBkcHIgaXNuJ3QuXG4gIGNvbnN0IHRhcmdldCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gKF93aW5kb3ckZGV2aWNlUGl4ZWxSYSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSAhPSBudWxsID8gX3dpbmRvdyRkZXZpY2VQaXhlbFJhIDogMiA6IDE7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRwcikgPyBNYXRoLm1pbihNYXRoLm1heChkcHJbMF0sIHRhcmdldCksIGRwclsxXSkgOiBkcHI7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGluc3RhbmNlIHJvb3Qgc3RhdGVcclxuICovXG5jb25zdCBnZXRSb290U3RhdGUgPSBvYmogPT4ge1xuICB2YXIgX3IzZjtcbiAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5yb290LmdldFN0YXRlKCk7XG59O1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgaW5zdGFuY2VzIGluaXRpYWwgKG91dG1vc3QpIHJvb3RcclxuICovXG5mdW5jdGlvbiBmaW5kSW5pdGlhbFJvb3QoY2hpbGQpIHtcbiAgbGV0IHJvb3QgPSBjaGlsZC5fX3IzZi5yb290O1xuICB3aGlsZSAocm9vdC5nZXRTdGF0ZSgpLnByZXZpb3VzUm9vdCkgcm9vdCA9IHJvb3QuZ2V0U3RhdGUoKS5wcmV2aW91c1Jvb3Q7XG4gIHJldHVybiByb290O1xufVxuLy8gQSBjb2xsZWN0aW9uIG9mIGNvbXBhcmUgZnVuY3Rpb25zXG5jb25zdCBpcyA9IHtcbiAgb2JqOiBhID0+IGEgPT09IE9iamVjdChhKSAmJiAhaXMuYXJyKGEpICYmIHR5cGVvZiBhICE9PSAnZnVuY3Rpb24nLFxuICBmdW46IGEgPT4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbicsXG4gIHN0cjogYSA9PiB0eXBlb2YgYSA9PT0gJ3N0cmluZycsXG4gIG51bTogYSA9PiB0eXBlb2YgYSA9PT0gJ251bWJlcicsXG4gIGJvbzogYSA9PiB0eXBlb2YgYSA9PT0gJ2Jvb2xlYW4nLFxuICB1bmQ6IGEgPT4gYSA9PT0gdm9pZCAwLFxuICBhcnI6IGEgPT4gQXJyYXkuaXNBcnJheShhKSxcbiAgZXF1KGEsIGIsIHtcbiAgICBhcnJheXMgPSAnc2hhbGxvdycsXG4gICAgb2JqZWN0cyA9ICdyZWZlcmVuY2UnLFxuICAgIHN0cmljdCA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgLy8gV3JvbmcgdHlwZSBvciBvbmUgb2YgdGhlIHR3byB1bmRlZmluZWQsIGRvZXNuJ3QgbWF0Y2hcbiAgICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiIHx8ICEhYSAhPT0gISFiKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQXRvbWljLCBqdXN0IGNvbXBhcmUgYSBhZ2FpbnN0IGJcbiAgICBpZiAoaXMuc3RyKGEpIHx8IGlzLm51bShhKSkgcmV0dXJuIGEgPT09IGI7XG4gICAgY29uc3QgaXNPYmogPSBpcy5vYmooYSk7XG4gICAgaWYgKGlzT2JqICYmIG9iamVjdHMgPT09ICdyZWZlcmVuY2UnKSByZXR1cm4gYSA9PT0gYjtcbiAgICBjb25zdCBpc0FyciA9IGlzLmFycihhKTtcbiAgICBpZiAoaXNBcnIgJiYgYXJyYXlzID09PSAncmVmZXJlbmNlJykgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gQXJyYXkgb3IgT2JqZWN0LCBzaGFsbG93IGNvbXBhcmUgZmlyc3QgdG8gc2VlIGlmIGl0J3MgYSBtYXRjaFxuICAgIGlmICgoaXNBcnIgfHwgaXNPYmopICYmIGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIC8vIExhc3QgcmVzb3J0LCBnbyB0aHJvdWdoIGtleXNcbiAgICBsZXQgaTtcbiAgICAvLyBDaGVjayBpZiBhIGhhcyBhbGwgdGhlIGtleXMgb2YgYlxuICAgIGZvciAoaSBpbiBhKSBpZiAoIShpIGluIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQ2hlY2sgaWYgdmFsdWVzIGJldHdlZW4ga2V5cyBtYXRjaFxuICAgIGlmIChpc09iaiAmJiBhcnJheXMgPT09ICdzaGFsbG93JyAmJiBvYmplY3RzID09PSAnc2hhbGxvdycpIHtcbiAgICAgIGZvciAoaSBpbiBzdHJpY3QgPyBiIDogYSkgaWYgKCFpcy5lcXUoYVtpXSwgYltpXSwge1xuICAgICAgICBzdHJpY3QsXG4gICAgICAgIG9iamVjdHM6ICdyZWZlcmVuY2UnXG4gICAgICB9KSkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgaW4gc3RyaWN0ID8gYiA6IGEpIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIGkgaXMgdW5kZWZpbmVkXG4gICAgaWYgKGlzLnVuZChpKSkge1xuICAgICAgLy8gSWYgYm90aCBhcnJheXMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc0FyciAmJiBhLmxlbmd0aCA9PT0gMCAmJiBiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBJZiBib3RoIG9iamVjdHMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc09iaiAmJiBPYmplY3Qua2V5cyhhKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoYikubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIE90aGVyd2lzZSBtYXRjaCB0aGVtIGJ5IHZhbHVlXG4gICAgICBpZiAoYSAhPT0gYikgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXHJcbiAqIENvbGxlY3RzIG5vZGVzIGFuZCBtYXRlcmlhbHMgZnJvbSBhIFRIUkVFLk9iamVjdDNELlxyXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkR3JhcGgob2JqZWN0KSB7XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgbm9kZXM6IHt9LFxuICAgIG1hdGVyaWFsczoge31cbiAgfTtcbiAgaWYgKG9iamVjdCkge1xuICAgIG9iamVjdC50cmF2ZXJzZShvYmogPT4ge1xuICAgICAgaWYgKG9iai5uYW1lKSBkYXRhLm5vZGVzW29iai5uYW1lXSA9IG9iajtcbiAgICAgIGlmIChvYmoubWF0ZXJpYWwgJiYgIWRhdGEubWF0ZXJpYWxzW29iai5tYXRlcmlhbC5uYW1lXSkgZGF0YS5tYXRlcmlhbHNbb2JqLm1hdGVyaWFsLm5hbWVdID0gb2JqLm1hdGVyaWFsO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vLyBEaXNwb3NlcyBhbiBvYmplY3QgYW5kIGFsbCBpdHMgcHJvcGVydGllc1xuZnVuY3Rpb24gZGlzcG9zZShvYmopIHtcbiAgaWYgKG9iai5kaXNwb3NlICYmIG9iai50eXBlICE9PSAnU2NlbmUnKSBvYmouZGlzcG9zZSgpO1xuICBmb3IgKGNvbnN0IHAgaW4gb2JqKSB7XG4gICAgcC5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBwLmRpc3Bvc2UoKTtcbiAgICBkZWxldGUgb2JqW3BdO1xuICB9XG59XG5cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBzY2VuZSBjYXJyaWVzIGEgc21hbGwgTG9jYWxTdGF0ZSBkZXNjcmlwdG9yXG5mdW5jdGlvbiBwcmVwYXJlKG9iamVjdCwgc3RhdGUpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3Q7XG4gIGluc3RhbmNlLl9fcjNmID0ge1xuICAgIHR5cGU6ICcnLFxuICAgIHJvb3Q6IG51bGwsXG4gICAgcHJldmlvdXNBdHRhY2g6IG51bGwsXG4gICAgbWVtb2l6ZWRQcm9wczoge30sXG4gICAgZXZlbnRDb3VudDogMCxcbiAgICBoYW5kbGVyczoge30sXG4gICAgb2JqZWN0czogW10sXG4gICAgcGFyZW50OiBudWxsLFxuICAgIC4uLnN0YXRlXG4gIH07XG4gIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiByZXNvbHZlKGluc3RhbmNlLCBrZXkpIHtcbiAgbGV0IHRhcmdldCA9IGluc3RhbmNlO1xuICBpZiAoa2V5LmluY2x1ZGVzKCctJykpIHtcbiAgICBjb25zdCBlbnRyaWVzID0ga2V5LnNwbGl0KCctJyk7XG4gICAgY29uc3QgbGFzdCA9IGVudHJpZXMucG9wKCk7XG4gICAgdGFyZ2V0ID0gZW50cmllcy5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2Nba2V5XSwgaW5zdGFuY2UpO1xuICAgIHJldHVybiB7XG4gICAgICB0YXJnZXQsXG4gICAgICBrZXk6IGxhc3RcbiAgICB9O1xuICB9IGVsc2UgcmV0dXJuIHtcbiAgICB0YXJnZXQsXG4gICAga2V5XG4gIH07XG59XG5cbi8vIENoZWNrcyBpZiBhIGRhc2gtY2FzZWQgc3RyaW5nIGVuZHMgd2l0aCBhbiBpbnRlZ2VyXG5jb25zdCBJTkRFWF9SRUdFWCA9IC8tXFxkKyQvO1xuZnVuY3Rpb24gYXR0YWNoKHBhcmVudCwgY2hpbGQsIHR5cGUpIHtcbiAgaWYgKGlzLnN0cih0eXBlKSkge1xuICAgIC8vIElmIGF0dGFjaGluZyBpbnRvIGFuIGFycmF5IChmb28tMCksIGNyZWF0ZSBvbmVcbiAgICBpZiAoSU5ERVhfUkVHRVgudGVzdCh0eXBlKSkge1xuICAgICAgY29uc3Qgcm9vdCA9IHR5cGUucmVwbGFjZShJTkRFWF9SRUdFWCwgJycpO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGtleVxuICAgICAgfSA9IHJlc29sdmUocGFyZW50LCByb290KTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXRba2V5XSkpIHRhcmdldFtrZXldID0gW107XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKHBhcmVudCwgdHlwZSk7XG4gICAgY2hpbGQuX19yM2YucHJldmlvdXNBdHRhY2ggPSB0YXJnZXRba2V5XTtcbiAgICB0YXJnZXRba2V5XSA9IGNoaWxkO1xuICB9IGVsc2UgY2hpbGQuX19yM2YucHJldmlvdXNBdHRhY2ggPSB0eXBlKHBhcmVudCwgY2hpbGQpO1xufVxuZnVuY3Rpb24gZGV0YWNoKHBhcmVudCwgY2hpbGQsIHR5cGUpIHtcbiAgdmFyIF9jaGlsZCRfX3IzZiwgX2NoaWxkJF9fcjNmMjtcbiAgaWYgKGlzLnN0cih0eXBlKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKHBhcmVudCwgdHlwZSk7XG4gICAgY29uc3QgcHJldmlvdXMgPSBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaDtcbiAgICAvLyBXaGVuIHRoZSBwcmV2aW91cyB2YWx1ZSB3YXMgdW5kZWZpbmVkLCBpdCBtZWFucyB0aGUgdmFsdWUgd2FzIG5ldmVyIHNldCB0byBiZWdpbiB3aXRoXG4gICAgaWYgKHByZXZpb3VzID09PSB1bmRlZmluZWQpIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgICAvLyBPdGhlcndpc2Ugc2V0IHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgIGVsc2UgdGFyZ2V0W2tleV0gPSBwcmV2aW91cztcbiAgfSBlbHNlIChfY2hpbGQkX19yM2YgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZi5wcmV2aW91c0F0dGFjaCA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmLnByZXZpb3VzQXR0YWNoKHBhcmVudCwgY2hpbGQpO1xuICAoX2NoaWxkJF9fcjNmMiA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdHJ1ZSA6IGRlbGV0ZSBfY2hpbGQkX19yM2YyLnByZXZpb3VzQXR0YWNoO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHByZXBhcmVzIGEgc2V0IG9mIGNoYW5nZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgaW5zdGFuY2VcbmZ1bmN0aW9uIGRpZmZQcm9wcyhpbnN0YW5jZSwge1xuICBjaGlsZHJlbjogY04sXG4gIGtleToga04sXG4gIHJlZjogck4sXG4gIC4uLnByb3BzXG59LCB7XG4gIGNoaWxkcmVuOiBjUCxcbiAga2V5OiBrUCxcbiAgcmVmOiByUCxcbiAgLi4ucHJldmlvdXNcbn0gPSB7fSwgcmVtb3ZlID0gZmFsc2UpIHtcbiAgdmFyIF9pbnN0YW5jZSRfX3IzZjtcbiAgY29uc3QgbG9jYWxTdGF0ZSA9IChfaW5zdGFuY2UkX19yM2YgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2YgOiB7fTtcbiAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHByb3BzKTtcbiAgY29uc3QgY2hhbmdlcyA9IFtdO1xuXG4gIC8vIENhdGNoIHJlbW92ZWQgcHJvcHMsIHByZXBlbmQgdGhlbSBzbyB0aGV5IGNhbiBiZSByZXNldCBvciByZW1vdmVkXG4gIGlmIChyZW1vdmUpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleXMgPSBPYmplY3Qua2V5cyhwcmV2aW91cyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2aW91c0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJldmlvdXNLZXlzW2ldKSkgZW50cmllcy51bnNoaWZ0KFtwcmV2aW91c0tleXNbaV0sIERFRkFVTFQgKyAncmVtb3ZlJ10pO1xuICAgIH1cbiAgfVxuICBlbnRyaWVzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIHZhciBfaW5zdGFuY2UkX19yM2YyO1xuICAgIC8vIEJhaWwgb3V0IG9uIHByaW1pdGl2ZSBvYmplY3RcbiAgICBpZiAoKF9pbnN0YW5jZSRfX3IzZjIgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCAmJiBfaW5zdGFuY2UkX19yM2YyLnByaW1pdGl2ZSAmJiBrZXkgPT09ICdvYmplY3QnKSByZXR1cm47XG4gICAgLy8gV2hlbiBwcm9wcyBtYXRjaCBiYWlsIG91dFxuICAgIGlmIChpcy5lcXUodmFsdWUsIHByZXZpb3VzW2tleV0pKSByZXR1cm47XG4gICAgLy8gQ29sbGVjdCBoYW5kbGVycyBhbmQgYmFpbCBvdXRcbiAgICBpZiAoL15vbihQb2ludGVyfENsaWNrfERvdWJsZUNsaWNrfENvbnRleHRNZW51fFdoZWVsKS8udGVzdChrZXkpKSByZXR1cm4gY2hhbmdlcy5wdXNoKFtrZXksIHZhbHVlLCB0cnVlLCBbXV0pO1xuICAgIC8vIFNwbGl0IGRhc2hlZCBwcm9wc1xuICAgIGxldCBlbnRyaWVzID0gW107XG4gICAgaWYgKGtleS5pbmNsdWRlcygnLScpKSBlbnRyaWVzID0ga2V5LnNwbGl0KCctJyk7XG4gICAgY2hhbmdlcy5wdXNoKFtrZXksIHZhbHVlLCBmYWxzZSwgZW50cmllc10pO1xuXG4gICAgLy8gUmVzZXQgcGllcmNlZCBwcm9wc1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wXTtcbiAgICAgIGlmIChwcm9wLnN0YXJ0c1dpdGgoYCR7a2V5fS1gKSkgY2hhbmdlcy5wdXNoKFtwcm9wLCB2YWx1ZSwgZmFsc2UsIHByb3Auc3BsaXQoJy0nKV0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG1lbW9pemVkID0ge1xuICAgIC4uLnByb3BzXG4gIH07XG4gIGlmIChsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMgJiYgbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmFyZ3MpIG1lbW9pemVkLmFyZ3MgPSBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXJncztcbiAgaWYgKGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcyAmJiBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXR0YWNoKSBtZW1vaXplZC5hdHRhY2ggPSBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXR0YWNoO1xuICByZXR1cm4ge1xuICAgIG1lbW9pemVkLFxuICAgIGNoYW5nZXNcbiAgfTtcbn1cbmNvbnN0IF9fREVWX18gPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxuLy8gVGhpcyBmdW5jdGlvbiBhcHBsaWVzIGEgc2V0IG9mIGNoYW5nZXMgdG8gdGhlIGluc3RhbmNlXG5mdW5jdGlvbiBhcHBseVByb3BzJDEoaW5zdGFuY2UsIGRhdGEpIHtcbiAgdmFyIF9pbnN0YW5jZSRfX3IzZjMsIF9yb290JGdldFN0YXRlLCBfaW5zdGFuY2UkX19yM2Y0O1xuICAvLyBGaWx0ZXIgZXF1YWxzLCBldmVudHMgYW5kIHJlc2VydmVkIHByb3BzXG4gIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMyA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmMyA6IHt9O1xuICBjb25zdCByb290ID0gbG9jYWxTdGF0ZS5yb290O1xuICBjb25zdCByb290U3RhdGUgPSAoX3Jvb3QkZ2V0U3RhdGUgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LmdldFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiByb290LmdldFN0YXRlKCkpICE9IG51bGwgPyBfcm9vdCRnZXRTdGF0ZSA6IHt9O1xuICBjb25zdCB7XG4gICAgbWVtb2l6ZWQsXG4gICAgY2hhbmdlc1xuICB9ID0gaXNEaWZmU2V0KGRhdGEpID8gZGF0YSA6IGRpZmZQcm9wcyhpbnN0YW5jZSwgZGF0YSk7XG4gIGNvbnN0IHByZXZIYW5kbGVycyA9IGxvY2FsU3RhdGUuZXZlbnRDb3VudDtcblxuICAvLyBQcmVwYXJlIG1lbW9pemVkIHByb3BzXG4gIGlmIChpbnN0YW5jZS5fX3IzZikgaW5zdGFuY2UuX19yM2YubWVtb2l6ZWRQcm9wcyA9IG1lbW9pemVkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgW2tleSwgdmFsdWUsIGlzRXZlbnQsIGtleXNdID0gY2hhbmdlc1tpXTtcblxuICAgIC8vIEFsaWFzIChvdXRwdXQpZW5jb2RpbmcgPT4gKG91dHB1dCljb2xvclNwYWNlIChzaW5jZSByMTUyKVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yODI5XG4gICAgaWYgKGhhc0NvbG9yU3BhY2UoaW5zdGFuY2UpKSB7XG4gICAgICBjb25zdCBzUkdCRW5jb2RpbmcgPSAzMDAxO1xuICAgICAgY29uc3QgU1JHQkNvbG9yU3BhY2UgPSAnc3JnYic7XG4gICAgICBjb25zdCBMaW5lYXJTUkdCQ29sb3JTcGFjZSA9ICdzcmdiLWxpbmVhcic7XG4gICAgICBpZiAoa2V5ID09PSAnZW5jb2RpbmcnKSB7XG4gICAgICAgIGtleSA9ICdjb2xvclNwYWNlJztcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gc1JHQkVuY29kaW5nID8gU1JHQkNvbG9yU3BhY2UgOiBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnb3V0cHV0RW5jb2RpbmcnKSB7XG4gICAgICAgIGtleSA9ICdvdXRwdXRDb2xvclNwYWNlJztcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gc1JHQkVuY29kaW5nID8gU1JHQkNvbG9yU3BhY2UgOiBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGN1cnJlbnRJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIGxldCB0YXJnZXRQcm9wID0gY3VycmVudEluc3RhbmNlW2tleV07XG5cbiAgICAvLyBSZXZvbHZlIGRhc2hlZCBwcm9wc1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgdGFyZ2V0UHJvcCA9IGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIGluc3RhbmNlKTtcbiAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYXRvbWljLCBpdCBmb3JjZXMgdXMgdG8gc3dpdGNoIHRoZSByb290XG4gICAgICBpZiAoISh0YXJnZXRQcm9wICYmIHRhcmdldFByb3Auc2V0KSkge1xuICAgICAgICBjb25zdCBbbmFtZSwgLi4ucmV2ZXJzZUVudHJpZXNdID0ga2V5cy5yZXZlcnNlKCk7XG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9IHJldmVyc2VFbnRyaWVzLnJldmVyc2UoKS5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2Nba2V5XSwgaW5zdGFuY2UpO1xuICAgICAgICBrZXkgPSBuYW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzIxMjA5XG4gICAgLy8gSE1SL2Zhc3QtcmVmcmVzaCByZWxpZXMgb24gdGhlIGFiaWxpdHkgdG8gY2FuY2VsIG91dCBwcm9wcywgYnV0IHRocmVlanNcbiAgICAvLyBoYXMgbm8gbWVhbnMgdG8gZG8gdGhpcy4gSGVuY2Ugd2UgY3VyYXRlIGEgc21hbGwgY29sbGVjdGlvbiBvZiB2YWx1ZS1jbGFzc2VzXG4gICAgLy8gd2l0aCB0aGVpciByZXNwZWN0aXZlIGNvbnN0cnVjdG9yL3NldCBhcmd1bWVudHNcbiAgICAvLyBGb3IgcmVtb3ZlZCBwcm9wcywgdHJ5IHRvIHNldCBkZWZhdWx0IHZhbHVlcywgaWYgcG9zc2libGVcbiAgICBpZiAodmFsdWUgPT09IERFRkFVTFQgKyAncmVtb3ZlJykge1xuICAgICAgaWYgKGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAvLyBjcmVhdGUgYSBibGFuayBzbGF0ZSBvZiB0aGUgaW5zdGFuY2UgYW5kIGNvcHkgdGhlIHBhcnRpY3VsYXIgcGFyYW1ldGVyLlxuICAgICAgICBsZXQgY3RvciA9IERFRkFVTFRTLmdldChjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoIWN0b3IpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY3RvciA9IG5ldyBjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IoKTtcbiAgICAgICAgICBERUZBVUxUUy5zZXQoY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yLCBjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGN0b3Jba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluc3RhbmNlIGRvZXMgbm90IGhhdmUgY29uc3RydWN0b3IsIGp1c3Qgc2V0IGl0IHRvIDBcbiAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlYWwgd2l0aCBwb2ludGVyIGV2ZW50cyAuLi5cbiAgICBpZiAoaXNFdmVudCkge1xuICAgICAgaWYgKHZhbHVlKSBsb2NhbFN0YXRlLmhhbmRsZXJzW2tleV0gPSB2YWx1ZTtlbHNlIGRlbGV0ZSBsb2NhbFN0YXRlLmhhbmRsZXJzW2tleV07XG4gICAgICBsb2NhbFN0YXRlLmV2ZW50Q291bnQgPSBPYmplY3Qua2V5cyhsb2NhbFN0YXRlLmhhbmRsZXJzKS5sZW5ndGg7XG4gICAgfVxuICAgIC8vIFNwZWNpYWwgdHJlYXRtZW50IGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3Igc2V0L2NvcHksIGFuZCBsYXllcnNcbiAgICBlbHNlIGlmICh0YXJnZXRQcm9wICYmIHRhcmdldFByb3Auc2V0ICYmICh0YXJnZXRQcm9wLmNvcHkgfHwgdGFyZ2V0UHJvcCBpbnN0YW5jZW9mIFRIUkVFLkxheWVycykpIHtcbiAgICAgIC8vIElmIHZhbHVlIGlzIGFuIGFycmF5XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHRhcmdldFByb3AuZnJvbUFycmF5KSB0YXJnZXRQcm9wLmZyb21BcnJheSh2YWx1ZSk7ZWxzZSB0YXJnZXRQcm9wLnNldCguLi52YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBUZXN0IGFnYWluIHRhcmdldC5jb3B5KGNsYXNzKSBuZXh0IC4uLlxuICAgICAgZWxzZSBpZiAodGFyZ2V0UHJvcC5jb3B5ICYmIHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIChcbiAgICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIG1heSBicmVhayBzdHJpY3QgaWRlbnRpdHkgY2hlY2tzIGJ5IGR1cGxpY2F0aW5nIHZlcnNpb25zIG9mIHRocmVlLmpzLlxuICAgICAgLy8gTG9vc2VuIHRvIHVubWluaWZpZWQgbmFtZXMsIGlnbm9yaW5nIGRlc2NlbmRlbnRzLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMjg1NlxuICAgICAgLy8gVE9ETzogZml4IHVwc3RyZWFtIGFuZCByZW1vdmUgaW4gdjlcbiAgICAgIF9fREVWX18gPyB0YXJnZXRQcm9wLmNvbnN0cnVjdG9yLm5hbWUgPT09IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgOiB0YXJnZXRQcm9wLmNvbnN0cnVjdG9yID09PSB2YWx1ZS5jb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGFyZ2V0UHJvcC5jb3B5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5vdGhpbmcgZWxzZSBmaXRzLCBqdXN0IHNldCB0aGUgc2luZ2xlIHZhbHVlLCBpZ25vcmUgdW5kZWZpbmVkXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8yNzRcbiAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgaXNDb2xvciA9IHRhcmdldFByb3AgaW5zdGFuY2VvZiBUSFJFRS5Db2xvcjtcbiAgICAgICAgLy8gQWxsb3cgc2V0dGluZyBhcnJheSBzY2FsYXJzXG4gICAgICAgIGlmICghaXNDb2xvciAmJiB0YXJnZXRQcm9wLnNldFNjYWxhcikgdGFyZ2V0UHJvcC5zZXRTY2FsYXIodmFsdWUpO1xuICAgICAgICAvLyBMYXllcnMgaGF2ZSBubyBjb3B5IGZ1bmN0aW9uLCB3ZSBtdXN0IHRoZXJlZm9yZSBjb3B5IHRoZSBtYXNrIHByb3BlcnR5XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldFByb3AgaW5zdGFuY2VvZiBUSFJFRS5MYXllcnMgJiYgdmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5MYXllcnMpIHRhcmdldFByb3AubWFzayA9IHZhbHVlLm1hc2s7XG4gICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IHNldCAuLi5cbiAgICAgICAgZWxzZSB0YXJnZXRQcm9wLnNldCh2YWx1ZSk7XG4gICAgICAgIC8vIEZvciB2ZXJzaW9ucyBvZiB0aHJlZSB3aGljaCBkb24ndCBzdXBwb3J0IFRIUkVFLkNvbG9yTWFuYWdlbWVudCxcbiAgICAgICAgLy8gQXV0by1jb252ZXJ0IHNSR0IgY29sb3JzXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzM0NFxuICAgICAgICBpZiAoIWdldENvbG9yTWFuYWdlbWVudCgpICYmICFyb290U3RhdGUubGluZWFyICYmIGlzQ29sb3IpIHRhcmdldFByb3AuY29udmVydFNSR0JUb0xpbmVhcigpO1xuICAgICAgfVxuICAgICAgLy8gRWxzZSwganVzdCBvdmVyd3JpdGUgdGhlIHZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRJbnN0YW5jZVtrZXldID0gdmFsdWU7XG5cbiAgICAgIC8vIEF1dG8tY29udmVydCBzUkdCIHRleHR1cmVzLCBmb3Igbm93IC4uLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzQ0XG4gICAgICBpZiAoY3VycmVudEluc3RhbmNlW2tleV0gaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICYmXG4gICAgICAvLyBzUkdCIHRleHR1cmVzIG11c3QgYmUgUkdCQTggc2luY2UgcjEzNyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjMxMjlcbiAgICAgIGN1cnJlbnRJbnN0YW5jZVtrZXldLmZvcm1hdCA9PT0gVEhSRUUuUkdCQUZvcm1hdCAmJiBjdXJyZW50SW5zdGFuY2Vba2V5XS50eXBlID09PSBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBjdXJyZW50SW5zdGFuY2Vba2V5XTtcbiAgICAgICAgaWYgKGhhc0NvbG9yU3BhY2UodGV4dHVyZSkgJiYgaGFzQ29sb3JTcGFjZShyb290U3RhdGUuZ2wpKSB0ZXh0dXJlLmNvbG9yU3BhY2UgPSByb290U3RhdGUuZ2wub3V0cHV0Q29sb3JTcGFjZTtlbHNlIHRleHR1cmUuZW5jb2RpbmcgPSByb290U3RhdGUuZ2wub3V0cHV0RW5jb2Rpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIH1cbiAgaWYgKGxvY2FsU3RhdGUucGFyZW50ICYmIGluc3RhbmNlLnJheWNhc3QgJiYgcHJldkhhbmRsZXJzICE9PSBsb2NhbFN0YXRlLmV2ZW50Q291bnQpIHtcbiAgICAvLyBHZXQgdGhlIGluaXRpYWwgcm9vdCBzdGF0ZSdzIGludGVybmFsc1xuICAgIGNvbnN0IGludGVybmFsID0gZmluZEluaXRpYWxSb290KGluc3RhbmNlKS5nZXRTdGF0ZSgpLmludGVybmFsO1xuICAgIC8vIFByZS1lbXB0aXZlbHkgcmVtb3ZlIHRoZSBpbnN0YW5jZSBmcm9tIHRoZSBpbnRlcmFjdGlvbiBtYW5hZ2VyXG4gICAgY29uc3QgaW5kZXggPSBpbnRlcm5hbC5pbnRlcmFjdGlvbi5pbmRleE9mKGluc3RhbmNlKTtcbiAgICBpZiAoaW5kZXggPiAtMSkgaW50ZXJuYWwuaW50ZXJhY3Rpb24uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAvLyBBZGQgdGhlIGluc3RhbmNlIHRvIHRoZSBpbnRlcmFjdGlvbiBtYW5hZ2VyIG9ubHkgd2hlbiBpdCBoYXMgaGFuZGxlcnNcbiAgICBpZiAobG9jYWxTdGF0ZS5ldmVudENvdW50KSBpbnRlcm5hbC5pbnRlcmFjdGlvbi5wdXNoKGluc3RhbmNlKTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIHVwZGF0ZSBsaWZlY3ljbGUgd2hlbiBpdCBpcyBiZWluZyB1cGRhdGVkLCBidXQgb25seSB3aGVuIGl0IGlzIHBhcnQgb2YgdGhlIHNjZW5lLlxuICAvLyBTa2lwIHVwZGF0ZXMgdG8gdGhlIGBvblVwZGF0ZWAgcHJvcCBpdHNlbGZcbiAgY29uc3QgaXNDaXJjdWxhciA9IGNoYW5nZXMubGVuZ3RoID09PSAxICYmIGNoYW5nZXNbMF1bMF0gPT09ICdvblVwZGF0ZSc7XG4gIGlmICghaXNDaXJjdWxhciAmJiBjaGFuZ2VzLmxlbmd0aCAmJiAoX2luc3RhbmNlJF9fcjNmNCA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsICYmIF9pbnN0YW5jZSRfX3IzZjQucGFyZW50KSB1cGRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICB2YXIgX2luc3RhbmNlJF9fcjNmNSwgX2luc3RhbmNlJF9fcjNmNSRyb290O1xuICBjb25zdCBzdGF0ZSA9IChfaW5zdGFuY2UkX19yM2Y1ID0gaW5zdGFuY2UuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiAoX2luc3RhbmNlJF9fcjNmNSRyb290ID0gX2luc3RhbmNlJF9fcjNmNS5yb290KSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJF9fcjNmNSRyb290LmdldFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2Y1JHJvb3QuZ2V0U3RhdGUoKTtcbiAgaWYgKHN0YXRlICYmIHN0YXRlLmludGVybmFsLmZyYW1lcyA9PT0gMCkgc3RhdGUuaW52YWxpZGF0ZSgpO1xufVxuZnVuY3Rpb24gdXBkYXRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2Uub25VcGRhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLm9uVXBkYXRlKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvOTJcbiAgLy8gRG8gbm90IG1lc3Mgd2l0aCB0aGUgY2FtZXJhIGlmIGl0IGJlbG9uZ3MgdG8gdGhlIHVzZXJcbiAgaWYgKCFjYW1lcmEubWFudWFsKSB7XG4gICAgaWYgKGlzT3J0aG9ncmFwaGljQ2FtZXJhKGNhbWVyYSkpIHtcbiAgICAgIGNhbWVyYS5sZWZ0ID0gc2l6ZS53aWR0aCAvIC0yO1xuICAgICAgY2FtZXJhLnJpZ2h0ID0gc2l6ZS53aWR0aCAvIDI7XG4gICAgICBjYW1lcmEudG9wID0gc2l6ZS5oZWlnaHQgLyAyO1xuICAgICAgY2FtZXJhLmJvdHRvbSA9IHNpemUuaGVpZ2h0IC8gLTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbWVyYS5hc3BlY3QgPSBzaXplLndpZHRoIC8gc2l6ZS5oZWlnaHQ7XG4gICAgfVxuICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMTc4XG4gICAgLy8gVXBkYXRlIG1hdHJpeCB3b3JsZCBzaW5jZSB0aGUgcmVuZGVyZXIgaXMgYSBmcmFtZSBsYXRlXG4gICAgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUlkKGV2ZW50KSB7XG4gIHJldHVybiAoZXZlbnQuZXZlbnRPYmplY3QgfHwgZXZlbnQub2JqZWN0KS51dWlkICsgJy8nICsgZXZlbnQuaW5kZXggKyBldmVudC5pbnN0YW5jZUlkO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvdHJlZS9tYWluL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIjZ2V0Y3VycmVudGV2ZW50cHJpb3JpdHlcbi8vIEdpdmVzIFJlYWN0IGEgY2x1ZSBhcyB0byBob3cgaW1wb3J0IHRoZSBjdXJyZW50IGludGVyYWN0aW9uIGlzXG5mdW5jdGlvbiBnZXRFdmVudFByaW9yaXR5KCkge1xuICB2YXIgX2dsb2JhbFNjb3BlJGV2ZW50O1xuICAvLyBHZXQgYSBoYW5kbGUgdG8gdGhlIGN1cnJlbnQgZ2xvYmFsIHNjb3BlIGluIHdpbmRvdyBhbmQgd29ya2VyIGNvbnRleHRzIGlmIGFibGVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzI0OTNcbiAgY29uc3QgZ2xvYmFsU2NvcGUgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiB8fCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3c7XG4gIGlmICghZ2xvYmFsU2NvcGUpIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgY29uc3QgbmFtZSA9IChfZ2xvYmFsU2NvcGUkZXZlbnQgPSBnbG9iYWxTY29wZS5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxTY29wZSRldmVudC50eXBlO1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdjbGljayc6XG4gICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgIGNhc2UgJ2RibGNsaWNrJzpcbiAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICBjYXNlICdwb2ludGVyZG93bic6XG4gICAgY2FzZSAncG9pbnRlcnVwJzpcbiAgICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gICAgY2FzZSAncG9pbnRlcm1vdmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVyZW50ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJsZWF2ZSc6XG4gICAgY2FzZSAnd2hlZWwnOlxuICAgICAgcmV0dXJuIENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIFJlbGVhc2UgcG9pbnRlciBjYXB0dXJlcy5cclxuICogVGhpcyBpcyBjYWxsZWQgYnkgcmVsZWFzZVBvaW50ZXJDYXB0dXJlIGluIHRoZSBBUEksIGFuZCB3aGVuIGFuIG9iamVjdCBpcyByZW1vdmVkLlxyXG4gKi9cbmZ1bmN0aW9uIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGNhcHR1cmVkTWFwLCBvYmosIGNhcHR1cmVzLCBwb2ludGVySWQpIHtcbiAgY29uc3QgY2FwdHVyZURhdGEgPSBjYXB0dXJlcy5nZXQob2JqKTtcbiAgaWYgKGNhcHR1cmVEYXRhKSB7XG4gICAgY2FwdHVyZXMuZGVsZXRlKG9iaik7XG4gICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3QgY2FwdHVyaW5nIG9iamVjdCBmb3IgdGhpcyBwb2ludGVyXG4gICAgaWYgKGNhcHR1cmVzLnNpemUgPT09IDApIHtcbiAgICAgIGNhcHR1cmVkTWFwLmRlbGV0ZShwb2ludGVySWQpO1xuICAgICAgY2FwdHVyZURhdGEudGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlSW50ZXJhY3Rpdml0eShzdG9yZSwgb2JqZWN0KSB7XG4gIGNvbnN0IHtcbiAgICBpbnRlcm5hbFxuICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgLy8gUmVtb3ZlcyBldmVyeSB0cmFjZSBvZiBhbiBvYmplY3QgZnJvbSB0aGUgZGF0YSBzdG9yZVxuICBpbnRlcm5hbC5pbnRlcmFjdGlvbiA9IGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvID0+IG8gIT09IG9iamVjdCk7XG4gIGludGVybmFsLmluaXRpYWxIaXRzID0gaW50ZXJuYWwuaW5pdGlhbEhpdHMuZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaG92ZXJlZC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKHZhbHVlLmV2ZW50T2JqZWN0ID09PSBvYmplY3QgfHwgdmFsdWUub2JqZWN0ID09PSBvYmplY3QpIHtcbiAgICAgIC8vIENsZWFyIG91dCBpbnRlcnNlY3RzLCB0aGV5IGFyZSBvdXRkYXRlZCBieSBub3dcbiAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9KTtcbiAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZm9yRWFjaCgoY2FwdHVyZXMsIHBvaW50ZXJJZCkgPT4ge1xuICAgIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGludGVybmFsLmNhcHR1cmVkTWFwLCBvYmplY3QsIGNhcHR1cmVzLCBwb2ludGVySWQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50cyhzdG9yZSkge1xuICAvKiogQ2FsY3VsYXRlcyBkZWx0YSAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZShldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZHggPSBldmVudC5vZmZzZXRYIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzBdO1xuICAgIGNvbnN0IGR5ID0gZXZlbnQub2Zmc2V0WSAtIGludGVybmFsLmluaXRpYWxDbGlja1sxXTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgYW4gaW5zdGFuY2UgaGFzIGEgdmFsaWQgcG9pbnRlci1ldmVudCByZWdpc3RlcmVkLCB0aGlzIGV4Y2x1ZGVzIHNjcm9sbCwgY2xpY2tzIGV0YyAqL1xuICBmdW5jdGlvbiBmaWx0ZXJQb2ludGVyRXZlbnRzKG9iamVjdHMpIHtcbiAgICByZXR1cm4gb2JqZWN0cy5maWx0ZXIob2JqID0+IFsnTW92ZScsICdPdmVyJywgJ0VudGVyJywgJ091dCcsICdMZWF2ZSddLnNvbWUobmFtZSA9PiB7XG4gICAgICB2YXIgX3IzZjtcbiAgICAgIHJldHVybiAoX3IzZiA9IG9iai5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9yM2YuaGFuZGxlcnNbJ29uUG9pbnRlcicgKyBuYW1lXTtcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJzZWN0KGV2ZW50LCBmaWx0ZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZHVwbGljYXRlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgLy8gQWxsb3cgY2FsbGVycyB0byBlbGltaW5hdGUgZXZlbnQgb2JqZWN0c1xuICAgIGNvbnN0IGV2ZW50c09iamVjdHMgPSBmaWx0ZXIgPyBmaWx0ZXIoc3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24pIDogc3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb247XG4gICAgLy8gUmVzZXQgYWxsIHJheWNhc3RlciBjYW1lcmFzIHRvIHVuZGVmaW5lZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzT2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUoZXZlbnRzT2JqZWN0c1tpXSk7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5wcmV2aW91c1Jvb3QpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSByb290LWxldmVsIHBvaW50ZXIgYW5kIHJheSBhcmUgc2V0IHVwXG4gICAgICBzdGF0ZS5ldmVudHMuY29tcHV0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbXB1dGUoZXZlbnQsIHN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlUmF5Y2FzdChvYmopIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0Um9vdFN0YXRlKG9iaik7XG4gICAgICAvLyBTa2lwIGV2ZW50IGhhbmRsaW5nIHdoZW4gbm9FdmVudHMgaXMgc2V0LCBvciB3aGVuIHRoZSByYXljYXN0ZXJzIGNhbWVyYSBpcyBudWxsXG4gICAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5ldmVudHMuZW5hYmxlZCB8fCBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSBudWxsKSByZXR1cm4gW107XG5cbiAgICAgIC8vIFdoZW4gdGhlIGNhbWVyYSBpcyB1bmRlZmluZWQgd2UgaGF2ZSB0byBjYWxsIHRoZSBldmVudCBsYXllcnMgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICBpZiAoc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfc3RhdGUkcHJldmlvdXNSb290O1xuICAgICAgICBzdGF0ZS5ldmVudHMuY29tcHV0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbXB1dGUoZXZlbnQsIHN0YXRlLCAoX3N0YXRlJHByZXZpb3VzUm9vdCA9IHN0YXRlLnByZXZpb3VzUm9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKSk7XG4gICAgICAgIC8vIElmIHRoZSBjYW1lcmEgaXMgc3RpbGwgdW5kZWZpbmVkIHdlIGhhdmUgdG8gc2tpcCB0aGlzIGxheWVyIGVudGlyZWx5XG4gICAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcnNlY3Qgb2JqZWN0IGJ5IG9iamVjdFxuICAgICAgcmV0dXJuIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPyBzdGF0ZS5yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KG9iaiwgdHJ1ZSkgOiBbXTtcbiAgICB9XG5cbiAgICAvLyBDb2xsZWN0IGV2ZW50c1xuICAgIGxldCBoaXRzID0gZXZlbnRzT2JqZWN0c1xuICAgIC8vIEludGVyc2VjdCBvYmplY3RzXG4gICAgLmZsYXRNYXAoaGFuZGxlUmF5Y2FzdClcbiAgICAvLyBTb3J0IGJ5IGV2ZW50IHByaW9yaXR5IGFuZCBkaXN0YW5jZVxuICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBhU3RhdGUgPSBnZXRSb290U3RhdGUoYS5vYmplY3QpO1xuICAgICAgY29uc3QgYlN0YXRlID0gZ2V0Um9vdFN0YXRlKGIub2JqZWN0KTtcbiAgICAgIGlmICghYVN0YXRlIHx8ICFiU3RhdGUpIHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcbiAgICAgIHJldHVybiBiU3RhdGUuZXZlbnRzLnByaW9yaXR5IC0gYVN0YXRlLmV2ZW50cy5wcmlvcml0eSB8fCBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcbiAgICB9KVxuICAgIC8vIEZpbHRlciBvdXQgZHVwbGljYXRlc1xuICAgIC5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICBjb25zdCBpZCA9IG1ha2VJZChpdGVtKTtcbiAgICAgIGlmIChkdXBsaWNhdGVzLmhhcyhpZCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGR1cGxpY2F0ZXMuYWRkKGlkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTYwMzFcbiAgICAvLyBBbGxvdyBjdXN0b20gdXNlcmxhbmQgaW50ZXJzZWN0IHNvcnQgb3JkZXIsIHRoaXMgbGlrZWx5IG9ubHkgbWFrZXMgc2Vuc2Ugb24gdGhlIHJvb3QgZmlsdGVyXG4gICAgaWYgKHN0YXRlLmV2ZW50cy5maWx0ZXIpIGhpdHMgPSBzdGF0ZS5ldmVudHMuZmlsdGVyKGhpdHMsIHN0YXRlKTtcblxuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZXZlbnRzLCBmaW5kIHRoZSBldmVudCBzb3VyY2UgKGV2ZW50T2JqZWN0KVxuICAgIGZvciAoY29uc3QgaGl0IG9mIGhpdHMpIHtcbiAgICAgIGxldCBldmVudE9iamVjdCA9IGhpdC5vYmplY3Q7XG4gICAgICAvLyBCdWJibGUgZXZlbnQgdXBcbiAgICAgIHdoaWxlIChldmVudE9iamVjdCkge1xuICAgICAgICB2YXIgX3IzZjI7XG4gICAgICAgIGlmICgoX3IzZjIgPSBldmVudE9iamVjdC5fX3IzZikgIT0gbnVsbCAmJiBfcjNmMi5ldmVudENvdW50KSBpbnRlcnNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICBldmVudE9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRPYmplY3QgPSBldmVudE9iamVjdC5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGludGVyYWN0aW9uIGlzIGNhcHR1cmVkLCBtYWtlIGFsbCBjYXB0dXJpbmcgdGFyZ2V0cyBwYXJ0IG9mIHRoZSBpbnRlcnNlY3QuXG4gICAgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50ICYmIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICBmb3IgKGxldCBjYXB0dXJlRGF0YSBvZiBzdGF0ZS5pbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoZXZlbnQucG9pbnRlcklkKS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoIWR1cGxpY2F0ZXMuaGFzKG1ha2VJZChjYXB0dXJlRGF0YS5pbnRlcnNlY3Rpb24pKSkgaW50ZXJzZWN0aW9ucy5wdXNoKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG5cbiAgLyoqICBIYW5kbGVzIGludGVyc2VjdGlvbnMgYnkgZm9yd2FyZGluZyB0aGVtIHRvIGhhbmRsZXJzICovXG4gIGZ1bmN0aW9uIGhhbmRsZUludGVyc2VjdHMoaW50ZXJzZWN0aW9ucywgZXZlbnQsIGRlbHRhLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb3RTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBJZiBhbnl0aGluZyBoYXMgYmVlbiBmb3VuZCwgZm9yd2FyZCBpdCB0byB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0ge1xuICAgICAgICBzdG9wcGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgaGl0IG9mIGludGVyc2VjdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUoaGl0Lm9iamVjdCkgfHwgcm9vdFN0YXRlO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmF5Y2FzdGVyLFxuICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgY2FtZXJhLFxuICAgICAgICAgIGludGVybmFsXG4gICAgICAgIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgdW5wcm9qZWN0ZWRQb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKHBvaW50ZXIueCwgcG9pbnRlci55LCAwKS51bnByb2plY3QoY2FtZXJhKTtcbiAgICAgICAgY29uc3QgaGFzUG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgdmFyIF9pbnRlcm5hbCRjYXB0dXJlZE1hcCwgX2ludGVybmFsJGNhcHR1cmVkTWFwMjtcbiAgICAgICAgICByZXR1cm4gKF9pbnRlcm5hbCRjYXB0dXJlZE1hcCA9IChfaW50ZXJuYWwkY2FwdHVyZWRNYXAyID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnRlcm5hbCRjYXB0dXJlZE1hcDIuaGFzKGhpdC5ldmVudE9iamVjdCkpICE9IG51bGwgPyBfaW50ZXJuYWwkY2FwdHVyZWRNYXAgOiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0UG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZURhdGEgPSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb246IGhpdCxcbiAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGlkKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50ZXJJZCB3YXMgcHJldmlvdXNseSBjYXB0dXJlZCwgd2UgYWRkIHRoZSBoaXQgdG8gdGhlXG4gICAgICAgICAgICAvLyBldmVudCBjYXB0dXJlZE1hcC5cbiAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCkuc2V0KGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBub3QgcHJldmlvdXNseSBjYXB0dXJlZCwgd2UgY3JlYXRlIGEgbWFwXG4gICAgICAgICAgICAvLyBjb250YWluaW5nIHRoZSBoaXRPYmplY3QsIGFuZCB0aGUgaGl0LiBoaXRPYmplY3QgaXMgdXNlZCBmb3JcbiAgICAgICAgICAgIC8vIGZhc3RlciBhY2Nlc3MuXG4gICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5zZXQoaWQsIG5ldyBNYXAoW1toaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVEYXRhXV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXZlbnQudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVsZWFzZVBvaW50ZXJDYXB0dXJlID0gaWQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhcHR1cmVzID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoY2FwdHVyZXMpIHtcbiAgICAgICAgICAgIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGludGVybmFsLmNhcHR1cmVkTWFwLCBoaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVzLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFkZCBuYXRpdmUgZXZlbnQgcHJvcHNcbiAgICAgICAgbGV0IGV4dHJhY3RFdmVudFByb3BzID0ge307XG4gICAgICAgIC8vIFRoaXMgaXRlcmF0ZXMgb3ZlciB0aGUgZXZlbnQncyBwcm9wZXJ0aWVzIGluY2x1ZGluZyB0aGUgaW5oZXJpdGVkIG9uZXMuIE5hdGl2ZSBQb2ludGVyRXZlbnRzIGhhdmUgbW9zdCBvZiB0aGVpciBwcm9wcyBhcyBnZXR0ZXJzIHdoaWNoIGFyZSBpbmhlcml0ZWQsIGJ1dCBwb2x5ZmlsbGVkIFBvaW50ZXJFdmVudHMgaGF2ZSB0aGVtIGFsbCBhcyB0aGVpciBvd24gcHJvcGVydGllcyAoaS5lLiBub3QgaW5oZXJpdGVkKS4gV2UgY2FuJ3QgdXNlIE9iamVjdC5rZXlzKCkgb3IgT2JqZWN0LmVudHJpZXMoKSBhcyB0aGV5IG9ubHkgcmV0dXJuIFwib3duXCIgcHJvcGVydGllczsgbm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkgYXMgdGhhdCAqZG9lc24ndCogcmV0dXJuIFwib3duXCIgcHJvcGVydGllcywgb25seSBpbmhlcml0ZWQgb25lcy5cbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBldmVudCkge1xuICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IGV2ZW50W3Byb3BdO1xuICAgICAgICAgIC8vIE9ubHkgY29weSBvdmVyIGF0b21pY3MsIGxlYXZlIGZ1bmN0aW9ucyBhbG9uZSBhcyB0aGVzZSBzaG91bGQgYmVcbiAgICAgICAgICAvLyBjYWxsZWQgYXMgZXZlbnQubmF0aXZlRXZlbnQuZm4oKVxuICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdmdW5jdGlvbicpIGV4dHJhY3RFdmVudFByb3BzW3Byb3BdID0gcHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJheWNhc3RFdmVudCA9IHtcbiAgICAgICAgICAuLi5oaXQsXG4gICAgICAgICAgLi4uZXh0cmFjdEV2ZW50UHJvcHMsXG4gICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zLFxuICAgICAgICAgIHN0b3BwZWQ6IGxvY2FsU3RhdGUuc3RvcHBlZCxcbiAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICB1bnByb2plY3RlZFBvaW50LFxuICAgICAgICAgIHJheTogcmF5Y2FzdGVyLnJheSxcbiAgICAgICAgICBjYW1lcmE6IGNhbWVyYSxcbiAgICAgICAgICAvLyBIaWphY2sgc3RvcFByb3BhZ2F0aW9uLCB3aGljaCBqdXN0IHNldHMgYSBmbGFnXG4gICAgICAgICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvNTk2XG4gICAgICAgICAgICAvLyBFdmVudHMgYXJlIG5vdCBhbGxvd2VkIHRvIHN0b3AgcHJvcGFnYXRpb24gaWYgdGhlIHBvaW50ZXIgaGFzIGJlZW4gY2FwdHVyZWRcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVzRm9yUG9pbnRlciA9ICdwb2ludGVySWQnIGluIGV2ZW50ICYmIGludGVybmFsLmNhcHR1cmVkTWFwLmdldChldmVudC5wb2ludGVySWQpO1xuXG4gICAgICAgICAgICAvLyBXZSBvbmx5IGF1dGhvcml6ZSBzdG9wUHJvcGFnYXRpb24uLi5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIC4uLmlmIHRoaXMgcG9pbnRlciBoYXNuJ3QgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgIWNhcHR1cmVzRm9yUG9pbnRlciB8fFxuICAgICAgICAgICAgLy8gLi4uIG9yIGlmIHRoZSBoaXQgb2JqZWN0IGlzIGNhcHR1cmluZyB0aGUgcG9pbnRlclxuICAgICAgICAgICAgY2FwdHVyZXNGb3JQb2ludGVyLmhhcyhoaXQuZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIHJheWNhc3RFdmVudC5zdG9wcGVkID0gbG9jYWxTdGF0ZS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gUHJvcGFnYXRpb24gaXMgc3RvcHBlZCwgcmVtb3ZlIGFsbCBvdGhlciBob3ZlciByZWNvcmRzXG4gICAgICAgICAgICAgIC8vIEFuIGV2ZW50IGhhbmRsZXIgaXMgb25seSBhbGxvd2VkIHRvIGZsdXNoIG90aGVyIGhhbmRsZXJzIGlmIGl0IGlzIGhvdmVyZWQgaXRzZWxmXG4gICAgICAgICAgICAgIGlmIChpbnRlcm5hbC5ob3ZlcmVkLnNpemUgJiYgQXJyYXkuZnJvbShpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKS5maW5kKGkgPT4gaS5ldmVudE9iamVjdCA9PT0gaGl0LmV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIC8vIE9iamVjdHMgY2Fubm90IGZsdXNoIG91dCBoaWdoZXIgdXAgb2JqZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBjYXVnaHQgdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgY29uc3QgaGlnaGVyID0gaW50ZXJzZWN0aW9ucy5zbGljZSgwLCBpbnRlcnNlY3Rpb25zLmluZGV4T2YoaGl0KSk7XG4gICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbLi4uaGlnaGVyLCBoaXRdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gdGhlcmUgc2hvdWxkIGJlIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB0YXJnZXQgYW5kIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgIGhhc1BvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICByZWxlYXNlUG9pbnRlckNhcHR1cmVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHtcbiAgICAgICAgICAgIGhhc1BvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICByZWxlYXNlUG9pbnRlckNhcHR1cmVcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhbGwgc3Vic2NyaWJlcnNcbiAgICAgICAgY2FsbGJhY2socmF5Y2FzdEV2ZW50KTtcbiAgICAgICAgLy8gRXZlbnQgYnViYmxpbmcgbWF5IGJlIGludGVycnVwdGVkIGJ5IHN0b3BQcm9wYWdhdGlvblxuICAgICAgICBpZiAobG9jYWxTdGF0ZS5zdG9wcGVkID09PSB0cnVlKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsUG9pbnRlcihpbnRlcnNlY3Rpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBmb3IgKGNvbnN0IGhvdmVyZWRPYmogb2YgaW50ZXJuYWwuaG92ZXJlZC52YWx1ZXMoKSkge1xuICAgICAgLy8gV2hlbiBubyBvYmplY3RzIHdlcmUgaGl0IG9yIHRoZSB0aGUgaG92ZXJlZCBvYmplY3Qgd2Fzbid0IGZvdW5kIHVuZGVybmVhdGggdGhlIGN1cnNvclxuICAgICAgLy8gd2UgY2FsbCBvblBvaW50ZXJPdXQgYW5kIGRlbGV0ZSB0aGUgb2JqZWN0IGZyb20gdGhlIGhvdmVyZWQtZWxlbWVudHMgbWFwXG4gICAgICBpZiAoIWludGVyc2VjdGlvbnMubGVuZ3RoIHx8ICFpbnRlcnNlY3Rpb25zLmZpbmQoaGl0ID0+IGhpdC5vYmplY3QgPT09IGhvdmVyZWRPYmoub2JqZWN0ICYmIGhpdC5pbmRleCA9PT0gaG92ZXJlZE9iai5pbmRleCAmJiBoaXQuaW5zdGFuY2VJZCA9PT0gaG92ZXJlZE9iai5pbnN0YW5jZUlkKSkge1xuICAgICAgICBjb25zdCBldmVudE9iamVjdCA9IGhvdmVyZWRPYmouZXZlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZXZlbnRPYmplY3QuX19yM2Y7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzO1xuICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLmRlbGV0ZShtYWtlSWQoaG92ZXJlZE9iaikpO1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5ldmVudENvdW50KSB7XG4gICAgICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAuLi5ob3ZlcmVkT2JqLFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uc1xuICAgICAgICAgIH07XG4gICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyT3V0ID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJPdXQoZGF0YSk7XG4gICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyTGVhdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlckxlYXZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJNaXNzZWQoZXZlbnQsIG9iamVjdHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gb2JqZWN0c1tpXS5fX3IzZjtcbiAgICAgIGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycy5vblBvaW50ZXJNaXNzZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzLm9uUG9pbnRlck1pc3NlZChldmVudCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXIobmFtZSkge1xuICAgIC8vIERlYWwgd2l0aCBjYW5jZWxhdGlvblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnb25Qb2ludGVyTGVhdmUnOlxuICAgICAgY2FzZSAnb25Qb2ludGVyQ2FuY2VsJzpcbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbFBvaW50ZXIoW10pO1xuICAgICAgY2FzZSAnb25Mb3N0UG9pbnRlckNhcHR1cmUnOlxuICAgICAgICByZXR1cm4gZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGludGVybmFsXG4gICAgICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50ICYmIGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGV2ZW50IGludGVyZmFjZSBoYWQgb25Mb3N0UG9pbnRlckNhcHR1cmUsIHdlJ2QgY2FsbCBpdCBoZXJlIG9uIGV2ZXJ5XG4gICAgICAgICAgICAvLyBvYmplY3QgdGhhdCdzIGdldHRpbmcgcmVtb3ZlZC4gV2UgY2FsbCBpdCBvbiB0aGUgbmV4dCBmcmFtZSBiZWNhdXNlIG9uTG9zdFBvaW50ZXJDYXB0dXJlXG4gICAgICAgICAgICAvLyBmaXJlcyBiZWZvcmUgb25Qb2ludGVyVXAuIE90aGVyd2lzZSBwb2ludGVyVXAgd291bGQgbmV2ZXIgYmUgY2FsbGVkIGlmIHRoZSBldmVudCBkaWRuJ3RcbiAgICAgICAgICAgIC8vIGhhcHBlbiBpbiB0aGUgb2JqZWN0IGl0IG9yaWdpbmF0ZWQgZnJvbSwgbGVhdmluZyBjb21wb25lbnRzIGluIGEgaW4tYmV0d2VlbiBzdGF0ZS5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgcmVsZWFzZSBpZiBwb2ludGVyLXVwIGRpZG4ndCBkbyBpdCBhbHJlYWR5XG4gICAgICAgICAgICAgIGlmIChpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLmRlbGV0ZShldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgICAgIGNhbmNlbFBvaW50ZXIoW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQW55IG90aGVyIHBvaW50ZXIgZ29lcyBoZXJlIC4uLlxuICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvblBvaW50ZXJNaXNzZWQsXG4gICAgICAgIGludGVybmFsXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgLy8gcHJlcGFyZVJheShldmVudClcbiAgICAgIGludGVybmFsLmxhc3RFdmVudC5jdXJyZW50ID0gZXZlbnQ7XG5cbiAgICAgIC8vIEdldCBmcmVzaCBpbnRlcnNlY3RzXG4gICAgICBjb25zdCBpc1BvaW50ZXJNb3ZlID0gbmFtZSA9PT0gJ29uUG9pbnRlck1vdmUnO1xuICAgICAgY29uc3QgaXNDbGlja0V2ZW50ID0gbmFtZSA9PT0gJ29uQ2xpY2snIHx8IG5hbWUgPT09ICdvbkNvbnRleHRNZW51JyB8fCBuYW1lID09PSAnb25Eb3VibGVDbGljayc7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBpc1BvaW50ZXJNb3ZlID8gZmlsdGVyUG9pbnRlckV2ZW50cyA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGhpdHMgPSBpbnRlcnNlY3QoZXZlbnQsIGZpbHRlcik7XG4gICAgICBjb25zdCBkZWx0YSA9IGlzQ2xpY2tFdmVudCA/IGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSA6IDA7XG5cbiAgICAgIC8vIFNhdmUgaW5pdGlhbCBjb29yZGluYXRlcyBvbiBwb2ludGVyLWRvd25cbiAgICAgIGlmIChuYW1lID09PSAnb25Qb2ludGVyRG93bicpIHtcbiAgICAgICAgaW50ZXJuYWwuaW5pdGlhbENsaWNrID0gW2V2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFldO1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsSGl0cyA9IGhpdHMubWFwKGhpdCA9PiBoaXQuZXZlbnRPYmplY3QpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhIGNsaWNrIHlpZWxkcyBubyByZXN1bHRzLCBwYXNzIGl0IGJhY2sgdG8gdGhlIHVzZXIgYXMgYSBtaXNzXG4gICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdCBpbiBvcmRlciB0byBlc3RhYmxpc2ggdXNlci1sYW5kIHNpZGUtZWZmZWN0IGNsZWFuIHVwXG4gICAgICBpZiAoaXNDbGlja0V2ZW50ICYmICFoaXRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoZGVsdGEgPD0gMikge1xuICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uKTtcbiAgICAgICAgICBpZiAob25Qb2ludGVyTWlzc2VkKSBvblBvaW50ZXJNaXNzZWQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBUYWtlIGNhcmUgb2YgdW5ob3ZlclxuICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIGNhbmNlbFBvaW50ZXIoaGl0cyk7XG4gICAgICBmdW5jdGlvbiBvbkludGVyc2VjdChkYXRhKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gZGF0YS5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBldmVudE9iamVjdC5fX3IzZjtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnM7XG5cbiAgICAgICAgLy8gQ2hlY2sgcHJlc2VuY2Ugb2YgaGFuZGxlcnNcbiAgICAgICAgaWYgKCEoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5ldmVudENvdW50KSkgcmV0dXJuO1xuXG4gICAgICAgIC8qXHJcbiAgICAgICAgTUFZQkUgVE9ETywgREVMRVRFIElGIE5PVDogXHJcbiAgICAgICAgICBDaGVjayBpZiB0aGUgb2JqZWN0IGlzIGNhcHR1cmVkLCBjYXB0dXJlZCBldmVudHMgc2hvdWxkIG5vdCBoYXZlIGludGVyc2VjdHMgcnVubmluZyBpbiBwYXJhbGxlbFxyXG4gICAgICAgICAgQnV0IHdvdWxkbid0IGl0IGJlIGJldHRlciB0byBqdXN0IHJlcGxhY2UgY2FwdHVyZWRNYXAgd2l0aCBhIHNpbmdsZSBlbnRyeT9cclxuICAgICAgICAgIEFsc28sIGFyZSB3ZSBPSyB3aXRoIHN0cmFpZ2h0IHVwIG1ha2luZyBwaWNraW5nIHVwIG11bHRpcGxlIG9iamVjdHMgaW1wb3NzaWJsZT9cclxuICAgICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHBvaW50ZXJJZCA9IChkYXRhIGFzIFRocmVlRXZlbnQ8UG9pbnRlckV2ZW50PikucG9pbnRlcklkICAgICAgICBcclxuICAgICAgICBpZiAocG9pbnRlcklkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGNhcHR1cmVkTWVzaFNldCA9IGludGVybmFsLmNhcHR1cmVkTWFwLmdldChwb2ludGVySWQpXHJcbiAgICAgICAgICBpZiAoY2FwdHVyZWRNZXNoU2V0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVkID0gY2FwdHVyZWRNZXNoU2V0LmdldChldmVudE9iamVjdClcclxuICAgICAgICAgICAgaWYgKGNhcHR1cmVkICYmIGNhcHR1cmVkLmxvY2FsU3RhdGUuc3RvcHBlZCkgcmV0dXJuXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIHtcbiAgICAgICAgICAvLyBNb3ZlIGV2ZW50IC4uLlxuICAgICAgICAgIGlmIChoYW5kbGVycy5vblBvaW50ZXJPdmVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlckVudGVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlck91dCB8fCBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSkge1xuICAgICAgICAgICAgLy8gV2hlbiBlbnRlciBvciBvdXQgaXMgcHJlc2VudCB0YWtlIGNhcmUgb2YgaG92ZXItc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZEl0ZW0gPSBpbnRlcm5hbC5ob3ZlcmVkLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoIWhvdmVyZWRJdGVtKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2Fzbid0IHByZXZpb3VzbHkgaG92ZXJlZCwgYm9vayBpdCBhbmQgY2FsbCBpdHMgaGFuZGxlclxuICAgICAgICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLnNldChpZCwgZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck92ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck92ZXIoZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlckVudGVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJFbnRlcihkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0uc3RvcHBlZCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhcyBwcmV2aW91c2x5IGhvdmVyZWQgYW5kIHN0b3BwZWQsIHdlIHNob3VsZG4ndCBhbGxvdyBvdGhlciBpdGVtcyB0byBwcm9jZWVkXG4gICAgICAgICAgICAgIGRhdGEuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhbGwgbW91c2UgbW92ZVxuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck1vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck1vdmUoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxsIG90aGVyIGV2ZW50cyAuLi5cbiAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIEZvcndhcmQgYWxsIGV2ZW50cyBiYWNrIHRvIHRoZWlyIHJlc3BlY3RpdmUgaGFuZGxlcnMgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGNsaWNrIGV2ZW50cyxcbiAgICAgICAgICAgIC8vIHdoaWNoIG11c3QgdXNlIHRoZSBpbml0aWFsIHRhcmdldFxuICAgICAgICAgICAgaWYgKCFpc0NsaWNrRXZlbnQgfHwgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgICAgLy8gTm93IGNhbGwgdGhlIGhhbmRsZXJcbiAgICAgICAgICAgICAgaGFuZGxlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJpZ2dlciBvblBvaW50ZXJNaXNzZWQgb24gYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBwb2ludGVyIG92ZXIvb3V0IGhhbmRsZXJzLCBidXQgbm90IGNsaWNrIGFuZCB3ZXJlbid0IGhpdFxuICAgICAgICAgICAgaWYgKGlzQ2xpY2tFdmVudCAmJiBpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG9iamVjdCA9PiAhaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMob2JqZWN0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFuZGxlSW50ZXJzZWN0cyhoaXRzLCBldmVudCwgZGVsdGEsIG9uSW50ZXJzZWN0KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGFuZGxlUG9pbnRlclxuICB9O1xufVxuXG4vLyBLZXlzIHRoYXQgc2hvdWxkbid0IGJlIGNvcGllZCBiZXR3ZWVuIFIzRiBzdG9yZXNcbmNvbnN0IHByaXZhdGVLZXlzID0gWydzZXQnLCAnZ2V0JywgJ3NldFNpemUnLCAnc2V0RnJhbWVsb29wJywgJ3NldERwcicsICdldmVudHMnLCAnaW52YWxpZGF0ZScsICdhZHZhbmNlJywgJ3NpemUnLCAndmlld3BvcnQnXTtcbmNvbnN0IGlzUmVuZGVyZXIgPSBkZWYgPT4gISEoZGVmICE9IG51bGwgJiYgZGVmLnJlbmRlcik7XG5jb25zdCBjb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBjcmVhdGVTdG9yZSA9IChpbnZhbGlkYXRlLCBhZHZhbmNlKSA9PiB7XG4gIGNvbnN0IHJvb3RTdGF0ZSA9IGNyZWF0ZSgoc2V0LCBnZXQpID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgZGVmYXVsdFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgdGVtcFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSA9IGdldCgpLmNhbWVyYSwgdGFyZ2V0ID0gZGVmYXVsdFRhcmdldCwgc2l6ZSA9IGdldCgpLnNpemUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdG9wLFxuICAgICAgICBsZWZ0XG4gICAgICB9ID0gc2l6ZTtcbiAgICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMpIHRlbXBUYXJnZXQuY29weSh0YXJnZXQpO2Vsc2UgdGVtcFRhcmdldC5zZXQoLi4udGFyZ2V0KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gY2FtZXJhLmdldFdvcmxkUG9zaXRpb24ocG9zaXRpb24pLmRpc3RhbmNlVG8odGVtcFRhcmdldCk7XG4gICAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIGNhbWVyYS56b29tLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC8gY2FtZXJhLnpvb20sXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgZmFjdG9yOiAxLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm92ID0gY2FtZXJhLmZvdiAqIE1hdGguUEkgLyAxODA7IC8vIGNvbnZlcnQgdmVydGljYWwgZm92IHRvIHJhZGlhbnNcbiAgICAgICAgY29uc3QgaCA9IDIgKiBNYXRoLnRhbihmb3YgLyAyKSAqIGRpc3RhbmNlOyAvLyB2aXNpYmxlIGhlaWdodFxuICAgICAgICBjb25zdCB3ID0gaCAqICh3aWR0aCAvIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIGZhY3Rvcjogd2lkdGggLyB3LFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcGVyZm9ybWFuY2VUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNldFBlcmZvcm1hbmNlQ3VycmVudCA9IGN1cnJlbnQgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgY3VycmVudFxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBwb2ludGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICBjb25zdCByb290U3RhdGUgPSB7XG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBNb2NrIG9iamVjdHMgdGhhdCBoYXZlIHRvIGJlIGNvbmZpZ3VyZWRcbiAgICAgIGdsOiBudWxsLFxuICAgICAgY2FtZXJhOiBudWxsLFxuICAgICAgcmF5Y2FzdGVyOiBudWxsLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIHByaW9yaXR5OiAxLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgeHI6IG51bGwsXG4gICAgICBzY2VuZTogbnVsbCxcbiAgICAgIGludmFsaWRhdGU6IChmcmFtZXMgPSAxKSA9PiBpbnZhbGlkYXRlKGdldCgpLCBmcmFtZXMpLFxuICAgICAgYWR2YW5jZTogKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cykgPT4gYWR2YW5jZSh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMsIGdldCgpKSxcbiAgICAgIGxlZ2FjeTogZmFsc2UsXG4gICAgICBsaW5lYXI6IGZhbHNlLFxuICAgICAgZmxhdDogZmFsc2UsXG4gICAgICBjb250cm9sczogbnVsbCxcbiAgICAgIGNsb2NrOiBuZXcgVEhSRUUuQ2xvY2soKSxcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIGZyYW1lbG9vcDogJ2Fsd2F5cycsXG4gICAgICBvblBvaW50ZXJNaXNzZWQ6IHVuZGVmaW5lZCxcbiAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgIGN1cnJlbnQ6IDEsXG4gICAgICAgIG1pbjogMC41LFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIGRlYm91bmNlOiAyMDAsXG4gICAgICAgIHJlZ3Jlc3M6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICAgIC8vIENsZWFyIHRpbWVvdXRcbiAgICAgICAgICBpZiAocGVyZm9ybWFuY2VUaW1lb3V0KSBjbGVhclRpbWVvdXQocGVyZm9ybWFuY2VUaW1lb3V0KTtcbiAgICAgICAgICAvLyBTZXQgbG93ZXIgYm91bmQgcGVyZm9ybWFuY2VcbiAgICAgICAgICBpZiAoc3RhdGUucGVyZm9ybWFuY2UuY3VycmVudCAhPT0gc3RhdGUucGVyZm9ybWFuY2UubWluKSBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoc3RhdGUucGVyZm9ybWFuY2UubWluKTtcbiAgICAgICAgICAvLyBHbyBiYWNrIHRvIHVwcGVyIGJvdW5kIHBlcmZvcm1hbmNlIGFmdGVyIGEgd2hpbGUgdW5sZXNzIHNvbWV0aGluZyByZWdyZXNzZXMgbWVhbndoaWxlXG4gICAgICAgICAgcGVyZm9ybWFuY2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoZ2V0KCkucGVyZm9ybWFuY2UubWF4KSwgc3RhdGUucGVyZm9ybWFuY2UuZGVib3VuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHVwZGF0ZVN0eWxlOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGluaXRpYWxEcHI6IDAsXG4gICAgICAgIGRwcjogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBhc3BlY3Q6IDAsXG4gICAgICAgIGRpc3RhbmNlOiAwLFxuICAgICAgICBmYWN0b3I6IDAsXG4gICAgICAgIGdldEN1cnJlbnRWaWV3cG9ydFxuICAgICAgfSxcbiAgICAgIHNldEV2ZW50czogZXZlbnRzID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIC4uLmV2ZW50c1xuICAgICAgICB9XG4gICAgICB9KSksXG4gICAgICBzZXRTaXplOiAod2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUsIHRvcCwgbGVmdCkgPT4ge1xuICAgICAgICBjb25zdCBjYW1lcmEgPSBnZXQoKS5jYW1lcmE7XG4gICAgICAgIGNvbnN0IHNpemUgPSB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIHRvcDogdG9wIHx8IDAsXG4gICAgICAgICAgbGVmdDogbGVmdCB8fCAwLFxuICAgICAgICAgIHVwZGF0ZVN0eWxlXG4gICAgICAgIH07XG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgICAgLi4uZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSwgZGVmYXVsdFRhcmdldCwgc2l6ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBzZXREcHI6IGRwciA9PiBzZXQoc3RhdGUgPT4ge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IGNhbGN1bGF0ZURwcihkcHIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAgIGRwcjogcmVzb2x2ZWQsXG4gICAgICAgICAgICBpbml0aWFsRHByOiBzdGF0ZS52aWV3cG9ydC5pbml0aWFsRHByIHx8IHJlc29sdmVkXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBzZXRGcmFtZWxvb3A6IChmcmFtZWxvb3AgPSAnYWx3YXlzJykgPT4ge1xuICAgICAgICBjb25zdCBjbG9jayA9IGdldCgpLmNsb2NrO1xuXG4gICAgICAgIC8vIGlmIGZyYW1lbG9vcCA9PT0gXCJuZXZlclwiIGNsb2NrLmVsYXBzZWRUaW1lIGlzIHVwZGF0ZWQgdXNpbmcgYWR2YW5jZSh0aW1lc3RhbXApXG4gICAgICAgIGNsb2NrLnN0b3AoKTtcbiAgICAgICAgY2xvY2suZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICBpZiAoZnJhbWVsb29wICE9PSAnbmV2ZXInKSB7XG4gICAgICAgICAgY2xvY2suc3RhcnQoKTtcbiAgICAgICAgICBjbG9jay5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KCgpID0+ICh7XG4gICAgICAgICAgZnJhbWVsb29wXG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBwcmV2aW91c1Jvb3Q6IHVuZGVmaW5lZCxcbiAgICAgIGludGVybmFsOiB7XG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICBmcmFtZXM6IDAsXG4gICAgICAgIGxhc3RFdmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpLFxuICAgICAgICBpbnRlcmFjdGlvbjogW10sXG4gICAgICAgIGhvdmVyZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgc3Vic2NyaWJlcnM6IFtdLFxuICAgICAgICBpbml0aWFsQ2xpY2s6IFswLCAwXSxcbiAgICAgICAgaW5pdGlhbEhpdHM6IFtdLFxuICAgICAgICBjYXB0dXJlZE1hcDogbmV3IE1hcCgpLFxuICAgICAgICBzdWJzY3JpYmU6IChyZWYsIHByaW9yaXR5LCBzdG9yZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGludGVybmFsID0gZ2V0KCkuaW50ZXJuYWw7XG4gICAgICAgICAgLy8gSWYgdGhpcyBzdWJzY3JpcHRpb24gd2FzIGdpdmVuIGEgcHJpb3JpdHksIGl0IHRha2VzIHJlbmRlcmluZyBpbnRvIGl0cyBvd24gaGFuZHNcbiAgICAgICAgICAvLyBGb3IgdGhhdCByZWFzb24gd2Ugc3dpdGNoIG9mZiBhdXRvbWF0aWMgcmVuZGVyaW5nIGFuZCBpbmNyZWFzZSB0aGUgbWFudWFsIGZsYWdcbiAgICAgICAgICAvLyBBcyBsb25nIGFzIHRoaXMgZmxhZyBpcyBwb3NpdGl2ZSB0aGVyZSBjYW4gYmUgbm8gaW50ZXJuYWwgcmVuZGVyaW5nIGF0IGFsbFxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgcmVuZGVyIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICBpbnRlcm5hbC5wcmlvcml0eSA9IGludGVybmFsLnByaW9yaXR5ICsgKHByaW9yaXR5ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycy5wdXNoKHtcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgc3RvcmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBSZWdpc3RlciBzdWJzY3JpYmVyIGFuZCBzb3J0IGxheWVycyBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LCBtZWFuaW5nLFxuICAgICAgICAgIC8vIGhpZ2hlc3QgcHJpb3JpdHkgcmVuZGVycyBsYXN0IChvbiB0b3Agb2YgdGhlIG90aGVyIGZyYW1lcylcbiAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycyA9IGludGVybmFsLnN1YnNjcmliZXJzLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJuYWwgPSBnZXQoKS5pbnRlcm5hbDtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbCAhPSBudWxsICYmIGludGVybmFsLnN1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICAgIC8vIERlY3JlYXNlIG1hbnVhbCBmbGFnIGlmIHRoaXMgc3Vic2NyaXB0aW9uIGhhZCBhIHByaW9yaXR5XG4gICAgICAgICAgICAgIGludGVybmFsLnByaW9yaXR5ID0gaW50ZXJuYWwucHJpb3JpdHkgLSAocHJpb3JpdHkgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlciBmcm9tIGxpc3RcbiAgICAgICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMgPSBpbnRlcm5hbC5zdWJzY3JpYmVycy5maWx0ZXIocyA9PiBzLnJlZiAhPT0gcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcm9vdFN0YXRlO1xuICB9KTtcbiAgY29uc3Qgc3RhdGUgPSByb290U3RhdGUuZ2V0U3RhdGUoKTtcbiAgbGV0IG9sZFNpemUgPSBzdGF0ZS5zaXplO1xuICBsZXQgb2xkRHByID0gc3RhdGUudmlld3BvcnQuZHByO1xuICBsZXQgb2xkQ2FtZXJhID0gc3RhdGUuY2FtZXJhO1xuICByb290U3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjYW1lcmEsXG4gICAgICBzaXplLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBnbCxcbiAgICAgIHNldFxuICAgIH0gPSByb290U3RhdGUuZ2V0U3RhdGUoKTtcblxuICAgIC8vIFJlc2l6ZSBjYW1lcmEgYW5kIHJlbmRlcmVyIG9uIGNoYW5nZXMgdG8gc2l6ZSBhbmQgcGl4ZWxyYXRpb1xuICAgIGlmIChzaXplLndpZHRoICE9PSBvbGRTaXplLndpZHRoIHx8IHNpemUuaGVpZ2h0ICE9PSBvbGRTaXplLmhlaWdodCB8fCB2aWV3cG9ydC5kcHIgIT09IG9sZERwcikge1xuICAgICAgdmFyIF9zaXplJHVwZGF0ZVN0eWxlO1xuICAgICAgb2xkU2l6ZSA9IHNpemU7XG4gICAgICBvbGREcHIgPSB2aWV3cG9ydC5kcHI7XG4gICAgICAvLyBVcGRhdGUgY2FtZXJhICYgcmVuZGVyZXJcbiAgICAgIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpO1xuICAgICAgZ2wuc2V0UGl4ZWxSYXRpbyh2aWV3cG9ydC5kcHIpO1xuICAgICAgY29uc3QgdXBkYXRlU3R5bGUgPSAoX3NpemUkdXBkYXRlU3R5bGUgPSBzaXplLnVwZGF0ZVN0eWxlKSAhPSBudWxsID8gX3NpemUkdXBkYXRlU3R5bGUgOiB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGdsLmRvbUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgIGdsLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHVwZGF0ZVN0eWxlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdmlld3BvcnQgb25jZSB0aGUgY2FtZXJhIGNoYW5nZXNcbiAgICBpZiAoY2FtZXJhICE9PSBvbGRDYW1lcmEpIHtcbiAgICAgIG9sZENhbWVyYSA9IGNhbWVyYTtcbiAgICAgIC8vIFVwZGF0ZSB2aWV3cG9ydFxuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQuZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSlcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW52YWxpZGF0ZSBvbiBhbnkgY2hhbmdlXG4gIHJvb3RTdGF0ZS5zdWJzY3JpYmUoc3RhdGUgPT4gaW52YWxpZGF0ZShzdGF0ZSkpO1xuXG4gIC8vIFJldHVybiByb290IHN0YXRlXG4gIHJldHVybiByb290U3RhdGU7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBzdWJzKSB7XG4gIGNvbnN0IHN1YiA9IHtcbiAgICBjYWxsYmFja1xuICB9O1xuICBzdWJzLmFkZChzdWIpO1xuICByZXR1cm4gKCkgPT4gdm9pZCBzdWJzLmRlbGV0ZShzdWIpO1xufVxubGV0IGk7XG5sZXQgZ2xvYmFsRWZmZWN0cyA9IG5ldyBTZXQoKTtcbmxldCBnbG9iYWxBZnRlckVmZmVjdHMgPSBuZXcgU2V0KCk7XG5sZXQgZ2xvYmFsVGFpbEVmZmVjdHMgPSBuZXcgU2V0KCk7XG5cbi8qKlxyXG4gKiBBZGRzIGEgZ2xvYmFsIHJlbmRlciBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgZWFjaCBmcmFtZS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZEVmZmVjdFxyXG4gKi9cbmNvbnN0IGFkZEVmZmVjdCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbEVmZmVjdHMpO1xuXG4vKipcclxuICogQWRkcyBhIGdsb2JhbCBhZnRlci1yZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRBZnRlckVmZmVjdFxyXG4gKi9cbmNvbnN0IGFkZEFmdGVyRWZmZWN0ID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsQWZ0ZXJFZmZlY3RzKTtcblxuLyoqXHJcbiAqIEFkZHMgYSBnbG9iYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gcmVuZGVyaW5nIHN0b3BzLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkVGFpbFxyXG4gKi9cbmNvbnN0IGFkZFRhaWwgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxUYWlsRWZmZWN0cyk7XG5mdW5jdGlvbiBydW4oZWZmZWN0cywgdGltZXN0YW1wKSB7XG4gIGlmICghZWZmZWN0cy5zaXplKSByZXR1cm47XG4gIGZvciAoY29uc3Qge1xuICAgIGNhbGxiYWNrXG4gIH0gb2YgZWZmZWN0cy52YWx1ZXMoKSkge1xuICAgIGNhbGxiYWNrKHRpbWVzdGFtcCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoR2xvYmFsRWZmZWN0cyh0eXBlLCB0aW1lc3RhbXApIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICdhZnRlcic6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbEFmdGVyRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICd0YWlsJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsVGFpbEVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gIH1cbn1cbmxldCBzdWJzY3JpYmVycztcbmxldCBzdWJzY3JpcHRpb247XG5mdW5jdGlvbiByZW5kZXIkMSh0aW1lc3RhbXAsIHN0YXRlLCBmcmFtZSkge1xuICAvLyBSdW4gbG9jYWwgZWZmZWN0c1xuICBsZXQgZGVsdGEgPSBzdGF0ZS5jbG9jay5nZXREZWx0YSgpO1xuICAvLyBJbiBmcmFtZWxvb3A9J25ldmVyJyBtb2RlLCBjbG9jayB0aW1lcyBhcmUgdXBkYXRlZCB1c2luZyB0aGUgcHJvdmlkZWQgdGltZXN0YW1wXG4gIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicgJiYgdHlwZW9mIHRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICBkZWx0YSA9IHRpbWVzdGFtcCAtIHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lO1xuICAgIHN0YXRlLmNsb2NrLm9sZFRpbWUgPSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZTtcbiAgICBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZSA9IHRpbWVzdGFtcDtcbiAgfVxuICAvLyBDYWxsIHN1YnNjcmliZXJzICh1c2VGcmFtZSlcbiAgc3Vic2NyaWJlcnMgPSBzdGF0ZS5pbnRlcm5hbC5zdWJzY3JpYmVycztcbiAgZm9yIChpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlcnNbaV07XG4gICAgc3Vic2NyaXB0aW9uLnJlZi5jdXJyZW50KHN1YnNjcmlwdGlvbi5zdG9yZS5nZXRTdGF0ZSgpLCBkZWx0YSwgZnJhbWUpO1xuICB9XG4gIC8vIFJlbmRlciBjb250ZW50XG4gIGlmICghc3RhdGUuaW50ZXJuYWwucHJpb3JpdHkgJiYgc3RhdGUuZ2wucmVuZGVyKSBzdGF0ZS5nbC5yZW5kZXIoc3RhdGUuc2NlbmUsIHN0YXRlLmNhbWVyYSk7XG4gIC8vIERlY3JlYXNlIGZyYW1lIGNvdW50XG4gIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IE1hdGgubWF4KDAsIHN0YXRlLmludGVybmFsLmZyYW1lcyAtIDEpO1xuICByZXR1cm4gc3RhdGUuZnJhbWVsb29wID09PSAnYWx3YXlzJyA/IDEgOiBzdGF0ZS5pbnRlcm5hbC5mcmFtZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVMb29wKHJvb3RzKSB7XG4gIGxldCBydW5uaW5nID0gZmFsc2U7XG4gIGxldCByZXBlYXQ7XG4gIGxldCBmcmFtZTtcbiAgbGV0IHN0YXRlO1xuICBmdW5jdGlvbiBsb29wKHRpbWVzdGFtcCkge1xuICAgIGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIHJlcGVhdCA9IDA7XG5cbiAgICAvLyBSdW4gZWZmZWN0c1xuICAgIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcblxuICAgIC8vIFJlbmRlciBhbGwgcm9vdHNcbiAgICBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMudmFsdWVzKCkpIHtcbiAgICAgIHZhciBfc3RhdGUkZ2wkeHI7XG4gICAgICBzdGF0ZSA9IHJvb3Quc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIC8vIElmIHRoZSBmcmFtZWxvb3AgaXMgaW52YWxpZGF0ZWQsIGRvIG5vdCBydW4gYW5vdGhlciBmcmFtZVxuICAgICAgaWYgKHN0YXRlLmludGVybmFsLmFjdGl2ZSAmJiAoc3RhdGUuZnJhbWVsb29wID09PSAnYWx3YXlzJyB8fCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPiAwKSAmJiAhKChfc3RhdGUkZ2wkeHIgPSBzdGF0ZS5nbC54cikgIT0gbnVsbCAmJiBfc3RhdGUkZ2wkeHIuaXNQcmVzZW50aW5nKSkge1xuICAgICAgICByZXBlYXQgKz0gcmVuZGVyJDEodGltZXN0YW1wLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUnVuIGFmdGVyLWVmZmVjdHNcbiAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2FmdGVyJywgdGltZXN0YW1wKTtcblxuICAgIC8vIFN0b3AgdGhlIGxvb3AgaWYgbm90aGluZyBpbnZhbGlkYXRlcyBpdFxuICAgIGlmIChyZXBlYXQgPT09IDApIHtcbiAgICAgIC8vIFRhaWwgY2FsbCBlZmZlY3RzLCB0aGV5IGFyZSBjYWxsZWQgd2hlbiByZW5kZXJpbmcgc3RvcHNcbiAgICAgIGZsdXNoR2xvYmFsRWZmZWN0cygndGFpbCcsIHRpbWVzdGFtcCk7XG5cbiAgICAgIC8vIEZsYWcgZW5kIG9mIG9wZXJhdGlvblxuICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZShzdGF0ZSwgZnJhbWVzID0gMSkge1xuICAgIHZhciBfc3RhdGUkZ2wkeHIyO1xuICAgIGlmICghc3RhdGUpIHJldHVybiByb290cy5mb3JFYWNoKHJvb3QgPT4gaW52YWxpZGF0ZShyb290LnN0b3JlLmdldFN0YXRlKCkpLCBmcmFtZXMpO1xuICAgIGlmICgoX3N0YXRlJGdsJHhyMiA9IHN0YXRlLmdsLnhyKSAhPSBudWxsICYmIF9zdGF0ZSRnbCR4cjIuaXNQcmVzZW50aW5nIHx8ICFzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgfHwgc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInKSByZXR1cm47XG4gICAgLy8gSW5jcmVhc2UgZnJhbWVzLCBkbyBub3QgZ28gaGlnaGVyIHRoYW4gNjBcbiAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1pbig2MCwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzICsgZnJhbWVzKTtcbiAgICAvLyBJZiB0aGUgcmVuZGVyLWxvb3AgaXNuJ3QgYWN0aXZlLCBzdGFydCBpdFxuICAgIGlmICghcnVubmluZykge1xuICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFkdmFuY2UodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzID0gdHJ1ZSwgc3RhdGUsIGZyYW1lKSB7XG4gICAgaWYgKHJ1bkdsb2JhbEVmZmVjdHMpIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcbiAgICBpZiAoIXN0YXRlKSBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMudmFsdWVzKCkpIHJlbmRlciQxKHRpbWVzdGFtcCwgcm9vdC5zdG9yZS5nZXRTdGF0ZSgpKTtlbHNlIHJlbmRlciQxKHRpbWVzdGFtcCwgc3RhdGUsIGZyYW1lKTtcbiAgICBpZiAocnVuR2xvYmFsRWZmZWN0cykgZmx1c2hHbG9iYWxFZmZlY3RzKCdhZnRlcicsIHRpbWVzdGFtcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsb29wLFxuICAgIC8qKlxyXG4gICAgICogSW52YWxpZGF0ZXMgdGhlIHZpZXcsIHJlcXVlc3RpbmcgYSBmcmFtZSB0byBiZSByZW5kZXJlZC4gV2lsbCBnbG9iYWxseSBpbnZhbGlkYXRlIHVubGVzcyBwYXNzZWQgYSByb290J3Mgc3RhdGUuXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjaW52YWxpZGF0ZVxyXG4gICAgICovXG4gICAgaW52YWxpZGF0ZSxcbiAgICAvKipcclxuICAgICAqIEFkdmFuY2VzIHRoZSBmcmFtZWxvb3AgYW5kIHJ1bnMgcmVuZGVyIGVmZmVjdHMsIHVzZWZ1bCBmb3Igd2hlbiBtYW51YWxseSByZW5kZXJpbmcgdmlhIGBmcmFtZWxvb3A9XCJuZXZlclwiYC5cclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZHZhbmNlXHJcbiAgICAgKi9cbiAgICBhZHZhbmNlXG4gIH07XG59XG5cbi8qKlxyXG4gKiBFeHBvc2VzIGFuIG9iamVjdCdzIHtAbGluayBMb2NhbFN0YXRlfS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI3VzZUluc3RhbmNlSGFuZGxlXHJcbiAqXHJcbiAqICoqTm90ZSoqOiB0aGlzIGlzIGFuIGVzY2FwZSBoYXRjaCB0byByZWFjdC1pbnRlcm5hbCBmaWVsZHMuIEV4cGVjdCB0aGlzIHRvIGNoYW5nZSBzaWduaWZpY2FudGx5IGJldHdlZW4gdmVyc2lvbnMuXHJcbiAqL1xuZnVuY3Rpb24gdXNlSW5zdGFuY2VIYW5kbGUocmVmKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKGluc3RhbmNlLmN1cnJlbnQgPSByZWYuY3VycmVudC5fX3IzZiksIFtyZWZdKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdXNlU3RvcmUoKSB7XG4gIGNvbnN0IHN0b3JlID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcbiAgaWYgKCFzdG9yZSkgdGhyb3cgbmV3IEVycm9yKCdSM0Y6IEhvb2tzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSBDYW52YXMgY29tcG9uZW50IScpO1xuICByZXR1cm4gc3RvcmU7XG59XG5cbi8qKlxyXG4gKiBBY2Nlc3NlcyBSM0YncyBpbnRlcm5hbCBzdGF0ZSwgY29udGFpbmluZyByZW5kZXJlciwgY2FudmFzLCBzY2VuZSwgZXRjLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2V0aHJlZVxyXG4gKi9cbmZ1bmN0aW9uIHVzZVRocmVlKHNlbGVjdG9yID0gc3RhdGUgPT4gc3RhdGUsIGVxdWFsaXR5Rm4pIHtcbiAgcmV0dXJuIHVzZVN0b3JlKCkoc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xufVxuXG4vKipcclxuICogRXhlY3V0ZXMgYSBjYWxsYmFjayBiZWZvcmUgcmVuZGVyIGluIGEgc2hhcmVkIGZyYW1lIGxvb3AuXHJcbiAqIENhbiBvcmRlciBlZmZlY3RzIHdpdGggcmVuZGVyIHByaW9yaXR5IG9yIG1hbnVhbGx5IHJlbmRlciB3aXRoIGEgcG9zaXRpdmUgcHJpb3JpdHkuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZWZyYW1lXHJcbiAqL1xuZnVuY3Rpb24gdXNlRnJhbWUoY2FsbGJhY2ssIHJlbmRlclByaW9yaXR5ID0gMCkge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHN0b3JlLmdldFN0YXRlKCkuaW50ZXJuYWwuc3Vic2NyaWJlO1xuICAvLyBNZW1vaXplIHJlZlxuICBjb25zdCByZWYgPSB1c2VNdXRhYmxlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAvLyBTdWJzY3JpYmUgb24gbW91bnQsIHVuc3Vic2NyaWJlIG9uIHVubW91bnRcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiBzdWJzY3JpYmUocmVmLCByZW5kZXJQcmlvcml0eSwgc3RvcmUpLCBbcmVuZGVyUHJpb3JpdHksIHN1YnNjcmliZSwgc3RvcmVdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGEgbm9kZSBncmFwaCBvZiBhbiBvYmplY3Qgd2l0aCBuYW1lZCBub2RlcyAmIG1hdGVyaWFscy5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlZ3JhcGhcclxuICovXG5mdW5jdGlvbiB1c2VHcmFwaChvYmplY3QpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gYnVpbGRHcmFwaChvYmplY3QpLCBbb2JqZWN0XSk7XG59XG5jb25zdCBtZW1vaXplZExvYWRlcnMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbG9hZGluZ0ZuKGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChQcm90bywgLi4uaW5wdXQpIHtcbiAgICAvLyBDb25zdHJ1Y3QgbmV3IGxvYWRlciBhbmQgcnVuIGV4dGVuc2lvbnNcbiAgICBsZXQgbG9hZGVyID0gbWVtb2l6ZWRMb2FkZXJzLmdldChQcm90byk7XG4gICAgaWYgKCFsb2FkZXIpIHtcbiAgICAgIGxvYWRlciA9IG5ldyBQcm90bygpO1xuICAgICAgbWVtb2l6ZWRMb2FkZXJzLnNldChQcm90bywgbG9hZGVyKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbnMpIGV4dGVuc2lvbnMobG9hZGVyKTtcbiAgICAvLyBHbyB0aHJvdWdoIHRoZSB1cmxzIGFuZCBsb2FkIHRoZW1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoaW5wdXQubWFwKGlucHV0ID0+IG5ldyBQcm9taXNlKChyZXMsIHJlamVjdCkgPT4gbG9hZGVyLmxvYWQoaW5wdXQsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEuc2NlbmUpIE9iamVjdC5hc3NpZ24oZGF0YSwgYnVpbGRHcmFwaChkYXRhLnNjZW5lKSk7XG4gICAgICByZXMoZGF0YSk7XG4gICAgfSwgb25Qcm9ncmVzcywgZXJyb3IgPT4gcmVqZWN0KG5ldyBFcnJvcihgQ291bGQgbm90IGxvYWQgJHtpbnB1dH06ICR7ZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2V9YCkpKSkpKS5maW5hbGx5KCgpID0+IGxvYWRlci5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBsb2FkZXIuZGlzcG9zZSgpKTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBTeW5jaHJvbm91c2x5IGxvYWRzIGFuZCBjYWNoZXMgYXNzZXRzIHdpdGggYSB0aHJlZSBsb2FkZXIuXHJcbiAqXHJcbiAqIE5vdGU6IHRoaXMgaG9vaydzIGNhbGxlciBtdXN0IGJlIHdyYXBwZWQgd2l0aCBgUmVhY3QuU3VzcGVuc2VgXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZWxvYWRlclxyXG4gKi9cbmZ1bmN0aW9uIHVzZUxvYWRlcihQcm90bywgaW5wdXQsIGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpIHtcbiAgLy8gVXNlIHN1c3BlbnNlIHRvIGxvYWQgYXN5bmMgYXNzZXRzXG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgY29uc3QgcmVzdWx0cyA9IHN1c3BlbmQobG9hZGluZ0ZuKGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpLCBbUHJvdG8sIC4uLmtleXNdLCB7XG4gICAgZXF1YWw6IGlzLmVxdVxuICB9KTtcbiAgLy8gUmV0dXJuIHRoZSBvYmplY3Qvc1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgPyByZXN1bHRzIDogcmVzdWx0c1swXTtcbn1cblxuLyoqXHJcbiAqIFByZWxvYWRzIGFuIGFzc2V0IGludG8gY2FjaGUgYXMgYSBzaWRlLWVmZmVjdC5cclxuICovXG51c2VMb2FkZXIucHJlbG9hZCA9IGZ1bmN0aW9uIChQcm90bywgaW5wdXQsIGV4dGVuc2lvbnMpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICByZXR1cm4gcHJlbG9hZChsb2FkaW5nRm4oZXh0ZW5zaW9ucyksIFtQcm90bywgLi4ua2V5c10pO1xufTtcblxuLyoqXHJcbiAqIFJlbW92ZXMgYSBsb2FkZWQgYXNzZXQgZnJvbSBjYWNoZS5cclxuICovXG51c2VMb2FkZXIuY2xlYXIgPSBmdW5jdGlvbiAoUHJvdG8sIGlucHV0KSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgcmV0dXJuIGNsZWFyKFtQcm90bywgLi4ua2V5c10pO1xufTtcblxuY29uc3Qgcm9vdHMgPSBuZXcgTWFwKCk7XG5jb25zdCB7XG4gIGludmFsaWRhdGUsXG4gIGFkdmFuY2Vcbn0gPSBjcmVhdGVMb29wKHJvb3RzKTtcbmNvbnN0IHtcbiAgcmVjb25jaWxlcixcbiAgYXBwbHlQcm9wc1xufSA9IGNyZWF0ZVJlbmRlcmVyKHJvb3RzLCBnZXRFdmVudFByaW9yaXR5KTtcbmNvbnN0IHNoYWxsb3dMb29zZSA9IHtcbiAgb2JqZWN0czogJ3NoYWxsb3cnLFxuICBzdHJpY3Q6IGZhbHNlXG59O1xuY29uc3QgY3JlYXRlUmVuZGVyZXJJbnN0YW5jZSA9IChnbCwgY2FudmFzKSA9PiB7XG4gIGNvbnN0IGN1c3RvbVJlbmRlcmVyID0gdHlwZW9mIGdsID09PSAnZnVuY3Rpb24nID8gZ2woY2FudmFzKSA6IGdsO1xuICBpZiAoaXNSZW5kZXJlcihjdXN0b21SZW5kZXJlcikpIHJldHVybiBjdXN0b21SZW5kZXJlcjtlbHNlIHJldHVybiBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgcG93ZXJQcmVmZXJlbmNlOiAnaGlnaC1wZXJmb3JtYW5jZScsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgYW50aWFsaWFzOiB0cnVlLFxuICAgIGFscGhhOiB0cnVlLFxuICAgIC4uLmdsXG4gIH0pO1xufTtcbmZ1bmN0aW9uIGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIGRlZmF1bHRTaXplKSB7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ7XG4gIGlmIChkZWZhdWx0U2l6ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHVwZGF0ZVN0eWxlID0gZGVmYXVsdFN0eWxlXG4gICAgfSA9IGRlZmF1bHRTaXplO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICB1cGRhdGVTdHlsZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCAmJiBjYW52YXMucGFyZW50RWxlbWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdFxuICAgIH0gPSBjYW52YXMucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgdXBkYXRlU3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdXBkYXRlU3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY2FudmFzKSB7XG4gIC8vIENoZWNrIGFnYWluc3QgbWlzdGFrZW4gdXNlIG9mIGNyZWF0ZVJvb3RcbiAgY29uc3QgcHJldlJvb3QgPSByb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgcHJldkZpYmVyID0gcHJldlJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZSb290LmZpYmVyO1xuICBjb25zdCBwcmV2U3RvcmUgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3Quc3RvcmU7XG4gIGlmIChwcmV2Um9vdCkgY29uc29sZS53YXJuKCdSM0YuY3JlYXRlUm9vdCBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSEnKTtcblxuICAvLyBSZXBvcnQgd2hlbiBhbiBlcnJvciB3YXMgZGV0ZWN0ZWQgaW4gYSBwcmV2aW91cyByZW5kZXJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIyNjFcbiAgY29uc3QgbG9nUmVjb3ZlcmFibGVFcnJvciA9IHR5cGVvZiByZXBvcnRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gIC8vIEluIG1vZGVybiBicm93c2VycywgcmVwb3J0RXJyb3Igd2lsbCBkaXNwYXRjaCBhbiBlcnJvciBldmVudCxcbiAgLy8gZW11bGF0aW5nIGFuIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3IuXG4gIHJlcG9ydEVycm9yIDpcbiAgLy8gSW4gb2xkZXIgYnJvd3NlcnMgYW5kIHRlc3QgZW52aXJvbm1lbnRzLCBmYWxsYmFjayB0byBjb25zb2xlLmVycm9yLlxuICBjb25zb2xlLmVycm9yO1xuXG4gIC8vIENyZWF0ZSBzdG9yZVxuICBjb25zdCBzdG9yZSA9IHByZXZTdG9yZSB8fCBjcmVhdGVTdG9yZShpbnZhbGlkYXRlLCBhZHZhbmNlKTtcbiAgLy8gQ3JlYXRlIHJlbmRlcmVyXG4gIGNvbnN0IGZpYmVyID0gcHJldkZpYmVyIHx8IHJlY29uY2lsZXIuY3JlYXRlQ29udGFpbmVyKHN0b3JlLCBDb25jdXJyZW50Um9vdCwgbnVsbCwgZmFsc2UsIG51bGwsICcnLCBsb2dSZWNvdmVyYWJsZUVycm9yLCBudWxsKTtcbiAgLy8gTWFwIGl0XG4gIGlmICghcHJldlJvb3QpIHJvb3RzLnNldChjYW52YXMsIHtcbiAgICBmaWJlcixcbiAgICBzdG9yZVxuICB9KTtcblxuICAvLyBMb2NhbHNcbiAgbGV0IG9uQ3JlYXRlZDtcbiAgbGV0IGNvbmZpZ3VyZWQgPSBmYWxzZTtcbiAgbGV0IGxhc3RDYW1lcmE7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJlKHByb3BzID0ge30pIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGdsOiBnbENvbmZpZyxcbiAgICAgICAgc2l6ZTogcHJvcHNTaXplLFxuICAgICAgICBzY2VuZTogc2NlbmVPcHRpb25zLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIG9uQ3JlYXRlZDogb25DcmVhdGVkQ2FsbGJhY2ssXG4gICAgICAgIHNoYWRvd3MgPSBmYWxzZSxcbiAgICAgICAgbGluZWFyID0gZmFsc2UsXG4gICAgICAgIGZsYXQgPSBmYWxzZSxcbiAgICAgICAgbGVnYWN5ID0gZmFsc2UsXG4gICAgICAgIG9ydGhvZ3JhcGhpYyA9IGZhbHNlLFxuICAgICAgICBmcmFtZWxvb3AgPSAnYWx3YXlzJyxcbiAgICAgICAgZHByID0gWzEsIDJdLFxuICAgICAgICBwZXJmb3JtYW5jZSxcbiAgICAgICAgcmF5Y2FzdGVyOiByYXljYXN0T3B0aW9ucyxcbiAgICAgICAgY2FtZXJhOiBjYW1lcmFPcHRpb25zLFxuICAgICAgICBvblBvaW50ZXJNaXNzZWRcbiAgICAgIH0gPSBwcm9wcztcbiAgICAgIGxldCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIC8vIFNldCB1cCByZW5kZXJlciAob25lIHRpbWUgb25seSEpXG4gICAgICBsZXQgZ2wgPSBzdGF0ZS5nbDtcbiAgICAgIGlmICghc3RhdGUuZ2wpIHN0YXRlLnNldCh7XG4gICAgICAgIGdsOiBnbCA9IGNyZWF0ZVJlbmRlcmVySW5zdGFuY2UoZ2xDb25maWcsIGNhbnZhcylcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgdXAgcmF5Y2FzdGVyIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGxldCByYXljYXN0ZXIgPSBzdGF0ZS5yYXljYXN0ZXI7XG4gICAgICBpZiAoIXJheWNhc3Rlcikgc3RhdGUuc2V0KHtcbiAgICAgICAgcmF5Y2FzdGVyOiByYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgcmF5Y2FzdGVyIG9wdGlvbnNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9ID0gcmF5Y2FzdE9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIWlzLmVxdShvcHRpb25zLCByYXljYXN0ZXIsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpcy5lcXUocGFyYW1zLCByYXljYXN0ZXIucGFyYW1zLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKHJheWNhc3Rlciwge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAuLi5yYXljYXN0ZXIucGFyYW1zLFxuICAgICAgICAgIC4uLnBhcmFtc1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgY2FtZXJhLCBkb24ndCBvdmVyd3JpdGUgYW55IHVzZXItc2V0IHN0YXRlXG4gICAgICBpZiAoIXN0YXRlLmNhbWVyYSB8fCBzdGF0ZS5jYW1lcmEgPT09IGxhc3RDYW1lcmEgJiYgIWlzLmVxdShsYXN0Q2FtZXJhLCBjYW1lcmFPcHRpb25zLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIGxhc3RDYW1lcmEgPSBjYW1lcmFPcHRpb25zO1xuICAgICAgICBjb25zdCBpc0NhbWVyYSA9IGNhbWVyYU9wdGlvbnMgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmE7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGlzQ2FtZXJhID8gY2FtZXJhT3B0aW9ucyA6IG9ydGhvZ3JhcGhpYyA/IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoMCwgMCwgMCwgMCwgMC4xLCAxMDAwKSA6IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgMCwgMC4xLCAxMDAwKTtcbiAgICAgICAgaWYgKCFpc0NhbWVyYSkge1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gNTtcbiAgICAgICAgICBpZiAoY2FtZXJhT3B0aW9ucykgYXBwbHlQcm9wcyhjYW1lcmEsIGNhbWVyYU9wdGlvbnMpO1xuICAgICAgICAgIC8vIEFsd2F5cyBsb29rIGF0IGNlbnRlciBieSBkZWZhdWx0XG4gICAgICAgICAgaWYgKCFzdGF0ZS5jYW1lcmEgJiYgIShjYW1lcmFPcHRpb25zICE9IG51bGwgJiYgY2FtZXJhT3B0aW9ucy5yb3RhdGlvbikpIGNhbWVyYS5sb29rQXQoMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBjYW1lcmFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJlIHJheWNhc3RlclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXhyL2lzc3Vlcy8zMDBcbiAgICAgICAgcmF5Y2FzdGVyLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIHNjZW5lIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGlmICghc3RhdGUuc2NlbmUpIHtcbiAgICAgICAgbGV0IHNjZW5lO1xuICAgICAgICBpZiAoc2NlbmVPcHRpb25zIGluc3RhbmNlb2YgVEhSRUUuU2NlbmUpIHtcbiAgICAgICAgICBzY2VuZSA9IHNjZW5lT3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgICAgIGlmIChzY2VuZU9wdGlvbnMpIGFwcGx5UHJvcHMoc2NlbmUsIHNjZW5lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBzY2VuZTogcHJlcGFyZShzY2VuZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBYUiAob25lIHRpbWUgb25seSEpXG4gICAgICBpZiAoIXN0YXRlLnhyKSB7XG4gICAgICAgIHZhciBfZ2wkeHI7XG4gICAgICAgIC8vIEhhbmRsZSBmcmFtZSBiZWhhdmlvciBpbiBXZWJYUlxuICAgICAgICBjb25zdCBoYW5kbGVYUkZyYW1lID0gKHRpbWVzdGFtcCwgZnJhbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJykgcmV0dXJuO1xuICAgICAgICAgIGFkdmFuY2UodGltZXN0YW1wLCB0cnVlLCBzdGF0ZSwgZnJhbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRvZ2dsZSByZW5kZXIgc3dpdGNoaW5nIG9uIHNlc3Npb25cbiAgICAgICAgY29uc3QgaGFuZGxlU2Vzc2lvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuZW5hYmxlZCA9IHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZztcbiAgICAgICAgICBzdGF0ZS5nbC54ci5zZXRBbmltYXRpb25Mb29wKHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZyA/IGhhbmRsZVhSRnJhbWUgOiBudWxsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmdsLnhyLmlzUHJlc2VudGluZykgaW52YWxpZGF0ZShzdGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gV2ViWFIgc2Vzc2lvbiBtYW5hZ2VyXG4gICAgICAgIGNvbnN0IHhyID0ge1xuICAgICAgICAgIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIFdlYlhSIHNlc3Npb24gZXZlbnRzXG4gICAgICAgIGlmICh0eXBlb2YgKChfZ2wkeHIgPSBnbC54cikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbCR4ci5hZGRFdmVudExpc3RlbmVyKSA9PT0gJ2Z1bmN0aW9uJykgeHIuY29ubmVjdCgpO1xuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIHhyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgc2hhZG93bWFwXG4gICAgICBpZiAoZ2wuc2hhZG93TWFwKSB7XG4gICAgICAgIGNvbnN0IG9sZEVuYWJsZWQgPSBnbC5zaGFkb3dNYXAuZW5hYmxlZDtcbiAgICAgICAgY29uc3Qgb2xkVHlwZSA9IGdsLnNoYWRvd01hcC50eXBlO1xuICAgICAgICBnbC5zaGFkb3dNYXAuZW5hYmxlZCA9ICEhc2hhZG93cztcbiAgICAgICAgaWYgKGlzLmJvbyhzaGFkb3dzKSkge1xuICAgICAgICAgIGdsLnNoYWRvd01hcC50eXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5zdHIoc2hhZG93cykpIHtcbiAgICAgICAgICB2YXIgX3R5cGVzJHNoYWRvd3M7XG4gICAgICAgICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAgICAgICBiYXNpYzogVEhSRUUuQmFzaWNTaGFkb3dNYXAsXG4gICAgICAgICAgICBwZXJjZW50YWdlOiBUSFJFRS5QQ0ZTaGFkb3dNYXAsXG4gICAgICAgICAgICBzb2Z0OiBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwLFxuICAgICAgICAgICAgdmFyaWFuY2U6IFRIUkVFLlZTTVNoYWRvd01hcFxuICAgICAgICAgIH07XG4gICAgICAgICAgZ2wuc2hhZG93TWFwLnR5cGUgPSAoX3R5cGVzJHNoYWRvd3MgPSB0eXBlc1tzaGFkb3dzXSkgIT0gbnVsbCA/IF90eXBlcyRzaGFkb3dzIDogVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5vYmooc2hhZG93cykpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGdsLnNoYWRvd01hcCwgc2hhZG93cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZEVuYWJsZWQgIT09IGdsLnNoYWRvd01hcC5lbmFibGVkIHx8IG9sZFR5cGUgIT09IGdsLnNoYWRvd01hcC50eXBlKSBnbC5zaGFkb3dNYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTYWZlbHkgc2V0IGNvbG9yIG1hbmFnZW1lbnQgaWYgYXZhaWxhYmxlLlxuICAgICAgLy8gQXZvaWQgYWNjZXNzaW5nIFRIUkVFLkNvbG9yTWFuYWdlbWVudCB0byBwbGF5IG5pY2Ugd2l0aCBvbGRlciB2ZXJzaW9uc1xuICAgICAgY29uc3QgQ29sb3JNYW5hZ2VtZW50ID0gZ2V0Q29sb3JNYW5hZ2VtZW50KCk7XG4gICAgICBpZiAoQ29sb3JNYW5hZ2VtZW50KSB7XG4gICAgICAgIGlmICgnZW5hYmxlZCcgaW4gQ29sb3JNYW5hZ2VtZW50KSBDb2xvck1hbmFnZW1lbnQuZW5hYmxlZCA9ICFsZWdhY3k7ZWxzZSBpZiAoJ2xlZ2FjeU1vZGUnIGluIENvbG9yTWFuYWdlbWVudCkgQ29sb3JNYW5hZ2VtZW50LmxlZ2FjeU1vZGUgPSBsZWdhY3k7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBjb2xvciBzcGFjZSBhbmQgdG9uZW1hcHBpbmcgcHJlZmVyZW5jZXNcbiAgICAgIGNvbnN0IExpbmVhckVuY29kaW5nID0gMzAwMDtcbiAgICAgIGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG4gICAgICBhcHBseVByb3BzKGdsLCB7XG4gICAgICAgIG91dHB1dEVuY29kaW5nOiBsaW5lYXIgPyBMaW5lYXJFbmNvZGluZyA6IHNSR0JFbmNvZGluZyxcbiAgICAgICAgdG9uZU1hcHBpbmc6IGZsYXQgPyBUSFJFRS5Ob1RvbmVNYXBwaW5nIDogVEhSRUUuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nXG4gICAgICB9KTtcblxuICAgICAgLy8gVXBkYXRlIGNvbG9yIG1hbmFnZW1lbnQgc3RhdGVcbiAgICAgIGlmIChzdGF0ZS5sZWdhY3kgIT09IGxlZ2FjeSkgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGxlZ2FjeVxuICAgICAgfSkpO1xuICAgICAgaWYgKHN0YXRlLmxpbmVhciAhPT0gbGluZWFyKSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgbGluZWFyXG4gICAgICB9KSk7XG4gICAgICBpZiAoc3RhdGUuZmxhdCAhPT0gZmxhdCkgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGZsYXRcbiAgICAgIH0pKTtcblxuICAgICAgLy8gU2V0IGdsIHByb3BzXG4gICAgICBpZiAoZ2xDb25maWcgJiYgIWlzLmZ1bihnbENvbmZpZykgJiYgIWlzUmVuZGVyZXIoZ2xDb25maWcpICYmICFpcy5lcXUoZ2xDb25maWcsIGdsLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKGdsLCBnbENvbmZpZyk7XG4gICAgICAvLyBTdG9yZSBldmVudHMgaW50ZXJuYWxseVxuICAgICAgaWYgKGV2ZW50cyAmJiAhc3RhdGUuZXZlbnRzLmhhbmRsZXJzKSBzdGF0ZS5zZXQoe1xuICAgICAgICBldmVudHM6IGV2ZW50cyhzdG9yZSlcbiAgICAgIH0pO1xuICAgICAgLy8gQ2hlY2sgc2l6ZSwgYWxsb3cgaXQgdG8gdGFrZSBvbiBjb250YWluZXIgYm91bmRzIGluaXRpYWxseVxuICAgICAgY29uc3Qgc2l6ZSA9IGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIHByb3BzU2l6ZSk7XG4gICAgICBpZiAoIWlzLmVxdShzaXplLCBzdGF0ZS5zaXplLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIHN0YXRlLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHNpemUudXBkYXRlU3R5bGUsIHNpemUudG9wLCBzaXplLmxlZnQpO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgcGl4ZWxyYXRpb1xuICAgICAgaWYgKGRwciAmJiBzdGF0ZS52aWV3cG9ydC5kcHIgIT09IGNhbGN1bGF0ZURwcihkcHIpKSBzdGF0ZS5zZXREcHIoZHByKTtcbiAgICAgIC8vIENoZWNrIGZyYW1lbG9vcFxuICAgICAgaWYgKHN0YXRlLmZyYW1lbG9vcCAhPT0gZnJhbWVsb29wKSBzdGF0ZS5zZXRGcmFtZWxvb3AoZnJhbWVsb29wKTtcbiAgICAgIC8vIENoZWNrIHBvaW50ZXIgbWlzc2VkXG4gICAgICBpZiAoIXN0YXRlLm9uUG9pbnRlck1pc3NlZCkgc3RhdGUuc2V0KHtcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkXG4gICAgICB9KTtcbiAgICAgIC8vIENoZWNrIHBlcmZvcm1hbmNlXG4gICAgICBpZiAocGVyZm9ybWFuY2UgJiYgIWlzLmVxdShwZXJmb3JtYW5jZSwgc3RhdGUucGVyZm9ybWFuY2UsIHNoYWxsb3dMb29zZSkpIHN0YXRlLnNldChzdGF0ZSA9PiAoe1xuICAgICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAgIC4uLnN0YXRlLnBlcmZvcm1hbmNlLFxuICAgICAgICAgIC4uLnBlcmZvcm1hbmNlXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgLy8gU2V0IGxvY2Fsc1xuICAgICAgb25DcmVhdGVkID0gb25DcmVhdGVkQ2FsbGJhY2s7XG4gICAgICBjb25maWd1cmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVuZGVyKGNoaWxkcmVuKSB7XG4gICAgICAvLyBUaGUgcm9vdCBoYXMgdG8gYmUgY29uZmlndXJlZCBiZWZvcmUgaXQgY2FuIGJlIHJlbmRlcmVkXG4gICAgICBpZiAoIWNvbmZpZ3VyZWQpIHRoaXMuY29uZmlndXJlKCk7XG4gICAgICByZWNvbmNpbGVyLnVwZGF0ZUNvbnRhaW5lciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUHJvdmlkZXIsIHtcbiAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIG9uQ3JlYXRlZDogb25DcmVhdGVkLFxuICAgICAgICByb290RWxlbWVudDogY2FudmFzXG4gICAgICB9KSwgZmliZXIsIG51bGwsICgpID0+IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gc3RvcmU7XG4gICAgfSxcbiAgICB1bm1vdW50KCkge1xuICAgICAgdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihjaGlsZHJlbiwgY2FudmFzLCBjb25maWcpIHtcbiAgY29uc29sZS53YXJuKCdSM0YucmVuZGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gUmVhY3QgMTguIFVzZSBjcmVhdGVSb290IGluc3RlYWQhJyk7XG4gIGNvbnN0IHJvb3QgPSBjcmVhdGVSb290KGNhbnZhcyk7XG4gIHJvb3QuY29uZmlndXJlKGNvbmZpZyk7XG4gIHJldHVybiByb290LnJlbmRlcihjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBQcm92aWRlcih7XG4gIHN0b3JlLFxuICBjaGlsZHJlbixcbiAgb25DcmVhdGVkLFxuICByb290RWxlbWVudFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gRmxhZyB0aGUgY2FudmFzIGFjdGl2ZSwgcmVuZGVyaW5nIHdpbGwgbm93IGJlZ2luXG4gICAgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcm5hbCxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSkpO1xuICAgIC8vIE5vdGlmaXkgdGhhdCBpbml0IGlzIGNvbXBsZXRlZCwgdGhlIHNjZW5lIGdyYXBoIGV4aXN0cywgYnV0IG5vdGhpbmcgaGFzIHlldCByZW5kZXJlZFxuICAgIGlmIChvbkNyZWF0ZWQpIG9uQ3JlYXRlZChzdGF0ZSk7XG4gICAgLy8gQ29ubmVjdCBldmVudHMgdG8gdGhlIHRhcmdldHMgcGFyZW50LCB0aGlzIGlzIGRvbmUgdG8gZW5zdXJlIGV2ZW50cyBhcmUgcmVnaXN0ZXJlZCBvblxuICAgIC8vIGEgc2hhcmVkIHRhcmdldCwgYW5kIG5vdCBvbiB0aGUgY2FudmFzIGl0c2VsZlxuICAgIGlmICghc3RvcmUuZ2V0U3RhdGUoKS5ldmVudHMuY29ubmVjdGVkKSBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3Qocm9vdEVsZW1lbnQpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdG9yZVxuICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcywgY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vdCA9IHJvb3RzLmdldChjYW52YXMpO1xuICBjb25zdCBmaWJlciA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZmliZXI7XG4gIGlmIChmaWJlcikge1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSkgc3RhdGUuaW50ZXJuYWwuYWN0aXZlID0gZmFsc2U7XG4gICAgcmVjb25jaWxlci51cGRhdGVDb250YWluZXIobnVsbCwgZmliZXIsIG51bGwsICgpID0+IHtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9zdGF0ZSRnbCwgX3N0YXRlJGdsJHJlbmRlckxpc3RzLCBfc3RhdGUkZ2wyLCBfc3RhdGUkZ2wzO1xuICAgICAgICAgICAgc3RhdGUuZXZlbnRzLmRpc2Nvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsID0gc3RhdGUuZ2wpID09IG51bGwgPyB2b2lkIDAgOiAoX3N0YXRlJGdsJHJlbmRlckxpc3RzID0gX3N0YXRlJGdsLnJlbmRlckxpc3RzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsJHJlbmRlckxpc3RzLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbCRyZW5kZXJMaXN0cy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsMiA9IHN0YXRlLmdsKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsMi5mb3JjZUNvbnRleHRMb3NzID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wyLmZvcmNlQ29udGV4dExvc3MoKTtcbiAgICAgICAgICAgIGlmICgoX3N0YXRlJGdsMyA9IHN0YXRlLmdsKSAhPSBudWxsICYmIF9zdGF0ZSRnbDMueHIpIHN0YXRlLnhyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGRpc3Bvc2Uoc3RhdGUpO1xuICAgICAgICAgICAgcm9vdHMuZGVsZXRlKGNhbnZhcyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGNhbnZhcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogLi4uICovXG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lciwgc3RhdGUpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbCwge1xuICAgIGtleTogY29udGFpbmVyLnV1aWQsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFBvcnRhbCh7XG4gIHN0YXRlID0ge30sXG4gIGNoaWxkcmVuLFxuICBjb250YWluZXJcbn0pIHtcbiAgLyoqIFRoaXMgaGFzIHRvIGJlIGEgY29tcG9uZW50IGJlY2F1c2UgaXQgd291bGQgbm90IGJlIGFibGUgdG8gY2FsbCB1c2VUaHJlZS91c2VTdG9yZSBvdGhlcndpc2Ugc2luY2VcclxuICAgKiAgaWYgdGhpcyBpcyBvdXIgZW52aXJvbm1lbnQsIHRoZW4gd2UgYXJlIG5vdCBpbiByM2YncyByZW5kZXJlciBidXQgaW4gcmVhY3QtZG9tLCBpdCB3b3VsZCB0cmlnZ2VyXHJcbiAgICogIHRoZSBcIlIzRiBob29rcyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgQ2FudmFzIGNvbXBvbmVudCFcIiB3YXJuaW5nOlxyXG4gICAqICA8Q2FudmFzPlxyXG4gICAqICAgIHtjcmVhdGVQb3J0YWwoLi4uKX0gKi9cbiAgY29uc3Qge1xuICAgIGV2ZW50cyxcbiAgICBzaXplLFxuICAgIC4uLnJlc3RcbiAgfSA9IHN0YXRlO1xuICBjb25zdCBwcmV2aW91c1Jvb3QgPSB1c2VTdG9yZSgpO1xuICBjb25zdCBbcmF5Y2FzdGVyXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBUSFJFRS5SYXljYXN0ZXIoKSk7XG4gIGNvbnN0IFtwb2ludGVyXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBUSFJFRS5WZWN0b3IyKCkpO1xuICBjb25zdCBpbmplY3QgPSBSZWFjdC51c2VDYWxsYmFjaygocm9vdFN0YXRlLCBpbmplY3RTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGludGVyc2VjdCA9IHtcbiAgICAgIC4uLnJvb3RTdGF0ZVxuICAgIH07IC8vIGFsbCBwcmV2IHN0YXRlIHByb3BzXG5cbiAgICAvLyBPbmx5IHRoZSBmaWVsZHMgb2YgXCJyb290U3RhdGVcIiB0aGF0IGRvIG5vdCBkaWZmZXIgZnJvbSBpbmplY3RTdGF0ZVxuICAgIC8vIFNvbWUgcHJvcHMgc2hvdWxkIGJlIG9mZi1saW1pdHNcbiAgICAvLyBPdGhlcndpc2UgZmlsdGVyIG91dCB0aGUgcHJvcHMgdGhhdCBhcmUgZGlmZmVyZW50IGFuZCBsZXQgdGhlIGluamVjdCBsYXllciB0YWtlIHByZWNlZGVuY2VcbiAgICBPYmplY3Qua2V5cyhyb290U3RhdGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChcbiAgICAgIC8vIFNvbWUgcHJvcHMgc2hvdWxkIGJlIG9mZi1saW1pdHNcbiAgICAgIHByaXZhdGVLZXlzLmluY2x1ZGVzKGtleSkgfHxcbiAgICAgIC8vIE90aGVyd2lzZSBmaWx0ZXIgb3V0IHRoZSBwcm9wcyB0aGF0IGFyZSBkaWZmZXJlbnQgYW5kIGxldCB0aGUgaW5qZWN0IGxheWVyIHRha2UgcHJlY2VkZW5jZVxuICAgICAgLy8gVW5sZXNzIHRoZSBpbmplY3QgbGF5ZXIgcHJvcHMgaXMgdW5kZWZpbmVkLCB0aGVuIHdlIGtlZXAgdGhlIHJvb3QgbGF5ZXJcbiAgICAgIHJvb3RTdGF0ZVtrZXldICE9PSBpbmplY3RTdGF0ZVtrZXldICYmIGluamVjdFN0YXRlW2tleV0pIHtcbiAgICAgICAgZGVsZXRlIGludGVyc2VjdFtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCB2aWV3cG9ydCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaW5qZWN0U3RhdGUgJiYgc2l6ZSkge1xuICAgICAgY29uc3QgY2FtZXJhID0gaW5qZWN0U3RhdGUuY2FtZXJhO1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBvdmVycmlkZSB2aWV3cG9ydCwgaWYgcHJlc2VudFxuICAgICAgdmlld3BvcnQgPSByb290U3RhdGUudmlld3BvcnQuZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgc2l6ZSk7XG4gICAgICAvLyBVcGRhdGUgdGhlIHBvcnRhbCBjYW1lcmEsIGlmIGl0IGRpZmZlcnMgZnJvbSB0aGUgcHJldmlvdXMgbGF5ZXJcbiAgICAgIGlmIChjYW1lcmEgIT09IHJvb3RTdGF0ZS5jYW1lcmEpIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLy8gVGhlIGludGVyc2VjdCBjb25zaXN0cyBvZiB0aGUgcHJldmlvdXMgcm9vdCBzdGF0ZVxuICAgICAgLi4uaW50ZXJzZWN0LFxuICAgICAgLy8gUG9ydGFscyBoYXZlIHRoZWlyIG93biBzY2VuZSwgd2hpY2ggZm9ybXMgdGhlIHJvb3QsIGEgcmF5Y2FzdGVyIGFuZCBhIHBvaW50ZXJcbiAgICAgIHNjZW5lOiBjb250YWluZXIsXG4gICAgICByYXljYXN0ZXIsXG4gICAgICBwb2ludGVyLFxuICAgICAgbW91c2U6IHBvaW50ZXIsXG4gICAgICAvLyBUaGVpciBwcmV2aW91cyByb290IGlzIHRoZSBsYXllciBiZWZvcmUgaXRcbiAgICAgIHByZXZpb3VzUm9vdCxcbiAgICAgIC8vIEV2ZW50cywgc2l6ZSBhbmQgdmlld3BvcnQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGluamVjdCBsYXllclxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS5ldmVudHMsXG4gICAgICAgIC4uLihpbmplY3RTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogaW5qZWN0U3RhdGUuZXZlbnRzKSxcbiAgICAgICAgLi4uZXZlbnRzXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICAuLi5yb290U3RhdGUuc2l6ZSxcbiAgICAgICAgLi4uc2l6ZVxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgLi4udmlld3BvcnRcbiAgICAgIH0sXG4gICAgICAuLi5yZXN0XG4gICAgfTtcbiAgfSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbc3RhdGVdKTtcbiAgY29uc3QgW3VzZVBvcnRhbFN0b3JlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICAvLyBDcmVhdGUgYSBtaXJyb3JlZCBzdG9yZSwgYmFzZWQgb24gdGhlIHByZXZpb3VzIHJvb3Qgd2l0aCBhIGZldyBvdmVycmlkZXMgLi4uXG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN0b3JlID0gY3JlYXRlKChzZXQsIGdldCkgPT4gKHtcbiAgICAgIC4uLnByZXZpb3VzU3RhdGUsXG4gICAgICBzY2VuZTogY29udGFpbmVyLFxuICAgICAgcmF5Y2FzdGVyLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgcHJldmlvdXNSb290LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIC4uLnByZXZpb3VzU3RhdGUuZXZlbnRzLFxuICAgICAgICAuLi5ldmVudHNcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIC4uLnByZXZpb3VzU3RhdGUuc2l6ZSxcbiAgICAgICAgLi4uc2l6ZVxuICAgICAgfSxcbiAgICAgIC4uLnJlc3QsXG4gICAgICAvLyBTZXQgYW5kIGdldCByZWZlciB0byB0aGlzIHJvb3Qtc3RhdGVcbiAgICAgIHNldCxcbiAgICAgIGdldCxcbiAgICAgIC8vIExheWVycyBhcmUgYWxsb3dlZCB0byBvdmVycmlkZSBldmVudHNcbiAgICAgIHNldEV2ZW50czogZXZlbnRzID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIC4uLmV2ZW50c1xuICAgICAgICB9XG4gICAgICB9KSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIHN0b3JlO1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTdWJzY3JpYmUgdG8gcHJldmlvdXMgcm9vdC1zdGF0ZSBhbmQgY29weSBjaGFuZ2VzIG92ZXIgdG8gdGhlIG1pcnJvcmVkIHBvcnRhbC1zdGF0ZVxuICAgIGNvbnN0IHVuc3ViID0gcHJldmlvdXNSb290LnN1YnNjcmliZShwcmV2ID0+IHVzZVBvcnRhbFN0b3JlLnNldFN0YXRlKHN0YXRlID0+IGluamVjdChwcmV2LCBzdGF0ZSkpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdW5zdWIoKTtcbiAgICAgIHVzZVBvcnRhbFN0b3JlLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHVzZVBvcnRhbFN0b3JlLnNldFN0YXRlKGluamVjdFN0YXRlID0+IGluamVjdChwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKSwgaW5qZWN0U3RhdGUpKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtpbmplY3RdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByZWNvbmNpbGVyLmNyZWF0ZVBvcnRhbCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB1c2VQb3J0YWxTdG9yZVxuICB9LCBjaGlsZHJlbiksIHVzZVBvcnRhbFN0b3JlLCBudWxsKSk7XG59XG5yZWNvbmNpbGVyLmluamVjdEludG9EZXZUb29scyh7XG4gIGJ1bmRsZVR5cGU6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyAwIDogMSxcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ0ByZWFjdC10aHJlZS9maWJlcicsXG4gIHZlcnNpb246IFJlYWN0LnZlcnNpb25cbn0pO1xuY29uc3QgYWN0ID0gUmVhY3QudW5zdGFibGVfYWN0O1xuXG5leHBvcnQgeyB1c2VUaHJlZSBhcyBBLCBCbG9jayBhcyBCLCB1c2VGcmFtZSBhcyBDLCB1c2VHcmFwaCBhcyBELCBFcnJvckJvdW5kYXJ5IGFzIEUsIHVzZUxvYWRlciBhcyBGLCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGFzIGEsIGNyZWF0ZVJvb3QgYXMgYiwgY3JlYXRlRXZlbnRzIGFzIGMsIHVubW91bnRDb21wb25lbnRBdE5vZGUgYXMgZCwgZXh0ZW5kIGFzIGUsIGNvbnRleHQgYXMgZiwgY3JlYXRlUG9ydGFsIGFzIGcsIHJlY29uY2lsZXIgYXMgaCwgaXNSZWYgYXMgaSwgYXBwbHlQcm9wcyBhcyBqLCBkaXNwb3NlIGFzIGssIGludmFsaWRhdGUgYXMgbCwgYWR2YW5jZSBhcyBtLCBhZGRFZmZlY3QgYXMgbiwgYWRkQWZ0ZXJFZmZlY3QgYXMgbywgYWRkVGFpbCBhcyBwLCBmbHVzaEdsb2JhbEVmZmVjdHMgYXMgcSwgcmVuZGVyIGFzIHIsIGdldFJvb3RTdGF0ZSBhcyBzLCB0aHJlZVR5cGVzIGFzIHQsIHVzZU11dGFibGVDYWxsYmFjayBhcyB1LCBhY3QgYXMgdiwgYnVpbGRHcmFwaCBhcyB3LCByb290cyBhcyB4LCB1c2VJbnN0YW5jZUhhbmRsZSBhcyB5LCB1c2VTdG9yZSBhcyB6IH07XG4iXSwibmFtZXMiOlsiVEhSRUUiLCJSZWFjdCIsIkRlZmF1bHRFdmVudFByaW9yaXR5IiwiQ29udGludW91c0V2ZW50UHJpb3JpdHkiLCJEaXNjcmV0ZUV2ZW50UHJpb3JpdHkiLCJDb25jdXJyZW50Um9vdCIsImNyZWF0ZSIsIlJlY29uY2lsZXIiLCJ1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIiwidW5zdGFibGVfSWRsZVByaW9yaXR5Iiwic3VzcGVuZCIsInByZWxvYWQiLCJjbGVhciIsInRocmVlVHlwZXMiLCJPYmplY3QiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJjYXRhbG9ndWUiLCJleHRlbmQiLCJvYmplY3RzIiwiYXNzaWduIiwiY3JlYXRlUmVuZGVyZXIiLCJfcm9vdHMiLCJfZ2V0RXZlbnRQcmlvcml0eSIsImNyZWF0ZUluc3RhbmNlIiwidHlwZSIsImFyZ3MiLCJhdHRhY2giLCJwcm9wcyIsInJvb3QiLCJuYW1lIiwidG9VcHBlckNhc2UiLCJzbGljZSIsImluc3RhbmNlIiwib2JqZWN0IiwidW5kZWZpbmVkIiwiRXJyb3IiLCJwcmVwYXJlIiwicHJpbWl0aXZlIiwidGFyZ2V0IiwiQXJyYXkiLCJpc0FycmF5IiwibWVtb2l6ZWRQcm9wcyIsIl9fcjNmIiwiQnVmZmVyR2VvbWV0cnkiLCJNYXRlcmlhbCIsImFwcGx5UHJvcHMkMSIsImFwcGVuZENoaWxkIiwicGFyZW50SW5zdGFuY2UiLCJjaGlsZCIsImFkZGVkIiwiX2NoaWxkJF9fcjNmIiwiX3BhcmVudEluc3RhbmNlJF9fcjNmIiwiaXNPYmplY3QzRCIsImFkZCIsInB1c2giLCJwYXJlbnQiLCJ1cGRhdGVJbnN0YW5jZSIsImludmFsaWRhdGVJbnN0YW5jZSIsImluc2VydEJlZm9yZSIsImJlZm9yZUNoaWxkIiwiX2NoaWxkJF9fcjNmMiIsIl9wYXJlbnRJbnN0YW5jZSRfX3IzZjIiLCJkaXNwYXRjaEV2ZW50IiwicmVzdFNpYmxpbmdzIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJzaWJsaW5nIiwiaW5kZXgiLCJpbmRleE9mIiwicmVtb3ZlUmVjdXJzaXZlIiwiYXJyYXkiLCJkaXNwb3NlIiwiZm9yRWFjaCIsInJlbW92ZUNoaWxkIiwiX3BhcmVudEluc3RhbmNlJF9fcjNmMyIsIl9jaGlsZCRfX3IzZjMiLCJfY2hpbGQkX19yM2Y1IiwieCIsImRldGFjaCIsIl9jaGlsZCRfX3IzZjQiLCJyZW1vdmUiLCJyZW1vdmVJbnRlcmFjdGl2aXR5IiwiZmluZEluaXRpYWxSb290IiwiaXNQcmltaXRpdmUiLCJzaG91bGREaXNwb3NlIiwiX2NoaWxkJF9fcjNmNiIsImNhbGxiYWNrIiwiZSIsIklTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCIsInN3aXRjaEluc3RhbmNlIiwibmV3UHJvcHMiLCJmaWJlciIsIl9pbnN0YW5jZSRfX3IzZiIsIm5ld0luc3RhbmNlIiwiYXV0b1JlbW92ZWRCZWZvcmVBcHBlbmQiLCJyYXljYXN0IiwiZXZlbnRDb3VudCIsInJvb3RTdGF0ZSIsImdldFN0YXRlIiwiaW50ZXJuYWwiLCJpbnRlcmFjdGlvbiIsImFsdGVybmF0ZSIsInN0YXRlTm9kZSIsInJlZiIsImN1cnJlbnQiLCJoYW5kbGVUZXh0SW5zdGFuY2UiLCJjb25zb2xlIiwid2FybiIsInJlY29uY2lsZXIiLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJzdXBwb3J0c011dGF0aW9uIiwiaXNQcmltYXJ5UmVuZGVyZXIiLCJzdXBwb3J0c1BlcnNpc3RlbmNlIiwic3VwcG9ydHNIeWRyYXRpb24iLCJub1RpbWVvdXQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiY29udGFpbmVyIiwic2NlbmUiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSIsImdldFJvb3RIb3N0Q29udGV4dCIsImdldENoaWxkSG9zdENvbnRleHQiLCJwYXJlbnRIb3N0Q29udGV4dCIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwiX2luc3RhbmNlJF9fcjNmMiIsImxvY2FsU3RhdGUiLCJCb29sZWFuIiwiaGFuZGxlcnMiLCJwcmVwYXJlVXBkYXRlIiwiX3R5cGUiLCJvbGRQcm9wcyIsIl9pbnN0YW5jZSRfX3IzZjMiLCJhcmdzTmV3IiwiY04iLCJyZXN0TmV3IiwiYXJnc09sZCIsImNPIiwicmVzdE9sZCIsInNvbWUiLCJ2YWx1ZSIsImRpZmYiLCJkaWZmUHJvcHMiLCJjaGFuZ2VzIiwibGVuZ3RoIiwiY29tbWl0VXBkYXRlIiwicmVjb25zdHJ1Y3QiLCJfb2xkUHJvcHMiLCJjb21taXRNb3VudCIsIl9wcm9wcyIsIl9pbnQiLCJfaW5zdGFuY2UkX19yM2Y0IiwiZ2V0UHVibGljSW5zdGFuY2UiLCJwcmVwYXJlRm9yQ29tbWl0IiwicHJlcGFyZVBvcnRhbE1vdW50IiwicmVzZXRBZnRlckNvbW1pdCIsInNob3VsZFNldFRleHRDb250ZW50IiwiY2xlYXJDb250YWluZXIiLCJoaWRlSW5zdGFuY2UiLCJfaW5zdGFuY2UkX19yM2Y1IiwidmlzaWJsZSIsInVuaGlkZUluc3RhbmNlIiwiX2luc3RhbmNlJF9fcjNmNiIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImhpZGVUZXh0SW5zdGFuY2UiLCJ1bmhpZGVUZXh0SW5zdGFuY2UiLCJnZXRDdXJyZW50RXZlbnRQcmlvcml0eSIsImJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ciIsImFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwiZGV0YWNoRGVsZXRlZEluc3RhbmNlIiwibm93IiwicGVyZm9ybWFuY2UiLCJpcyIsImZ1biIsIkRhdGUiLCJzY2hlZHVsZVRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2FuY2VsVGltZW91dCIsImNsZWFyVGltZW91dCIsImFwcGx5UHJvcHMiLCJfd2luZG93JGRvY3VtZW50IiwiX3dpbmRvdyRuYXZpZ2F0b3IiLCJoYXNDb2xvclNwYWNlIiwiZ2V0Q29sb3JNYW5hZ2VtZW50IiwiX0NvbG9yTWFuYWdlbWVudCIsIkNvbG9yTWFuYWdlbWVudCIsImlzT3J0aG9ncmFwaGljQ2FtZXJhIiwiZGVmIiwiaXNSZWYiLCJvYmoiLCJoYXNPd25Qcm9wZXJ0eSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlTXV0YWJsZUNhbGxiYWNrIiwiZm4iLCJ1c2VSZWYiLCJCbG9jayIsInNldCIsIlByb21pc2UiLCJFcnJvckJvdW5kYXJ5IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJzdGF0ZSIsImVycm9yIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJlcnIiLCJyZW5kZXIiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJERUZBVUxUIiwiREVGQVVMVFMiLCJNYXAiLCJpc0RpZmZTZXQiLCJtZW1vaXplZCIsImNhbGN1bGF0ZURwciIsImRwciIsIl93aW5kb3ckZGV2aWNlUGl4ZWxSYSIsImRldmljZVBpeGVsUmF0aW8iLCJNYXRoIiwibWluIiwibWF4IiwiZ2V0Um9vdFN0YXRlIiwiX3IzZiIsInByZXZpb3VzUm9vdCIsImEiLCJhcnIiLCJzdHIiLCJudW0iLCJib28iLCJ1bmQiLCJlcXUiLCJiIiwiYXJyYXlzIiwic3RyaWN0IiwiaXNPYmoiLCJpc0FyciIsImkiLCJrZXlzIiwiYnVpbGRHcmFwaCIsImRhdGEiLCJub2RlcyIsIm1hdGVyaWFscyIsInRyYXZlcnNlIiwibWF0ZXJpYWwiLCJwIiwicHJldmlvdXNBdHRhY2giLCJyZXNvbHZlIiwia2V5IiwiaW5jbHVkZXMiLCJlbnRyaWVzIiwic3BsaXQiLCJsYXN0IiwicG9wIiwicmVkdWNlIiwiYWNjIiwiSU5ERVhfUkVHRVgiLCJ0ZXN0IiwicmVwbGFjZSIsInByZXZpb3VzIiwia04iLCJyTiIsImNQIiwia1AiLCJyUCIsInByZXZpb3VzS2V5cyIsInVuc2hpZnQiLCJwcm9wIiwic3RhcnRzV2l0aCIsIl9fREVWX18iLCJwcm9jZXNzIiwiX3Jvb3QkZ2V0U3RhdGUiLCJwcmV2SGFuZGxlcnMiLCJpc0V2ZW50Iiwic1JHQkVuY29kaW5nIiwiU1JHQkNvbG9yU3BhY2UiLCJMaW5lYXJTUkdCQ29sb3JTcGFjZSIsImN1cnJlbnRJbnN0YW5jZSIsInRhcmdldFByb3AiLCJyZXZlcnNlRW50cmllcyIsInJldmVyc2UiLCJjdG9yIiwiZ2V0IiwiY29weSIsIkxheWVycyIsImZyb21BcnJheSIsImlzQ29sb3IiLCJDb2xvciIsInNldFNjYWxhciIsIm1hc2siLCJsaW5lYXIiLCJjb252ZXJ0U1JHQlRvTGluZWFyIiwiVGV4dHVyZSIsImZvcm1hdCIsIlJHQkFGb3JtYXQiLCJVbnNpZ25lZEJ5dGVUeXBlIiwidGV4dHVyZSIsImdsIiwiY29sb3JTcGFjZSIsIm91dHB1dENvbG9yU3BhY2UiLCJlbmNvZGluZyIsIm91dHB1dEVuY29kaW5nIiwic3BsaWNlIiwiaXNDaXJjdWxhciIsIl9pbnN0YW5jZSRfX3IzZjUkcm9vdCIsImZyYW1lcyIsImludmFsaWRhdGUiLCJvblVwZGF0ZSIsInVwZGF0ZUNhbWVyYSIsImNhbWVyYSIsInNpemUiLCJtYW51YWwiLCJsZWZ0Iiwid2lkdGgiLCJyaWdodCIsInRvcCIsImhlaWdodCIsImJvdHRvbSIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJ1cGRhdGVNYXRyaXhXb3JsZCIsIm1ha2VJZCIsImV2ZW50IiwiZXZlbnRPYmplY3QiLCJ1dWlkIiwiaW5zdGFuY2VJZCIsImdldEV2ZW50UHJpb3JpdHkiLCJfZ2xvYmFsU2NvcGUkZXZlbnQiLCJnbG9iYWxTY29wZSIsInNlbGYiLCJyZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZSIsImNhcHR1cmVkTWFwIiwiY2FwdHVyZXMiLCJwb2ludGVySWQiLCJjYXB0dXJlRGF0YSIsImRlbGV0ZSIsInJlbGVhc2VQb2ludGVyQ2FwdHVyZSIsInN0b3JlIiwibyIsImluaXRpYWxIaXRzIiwiaG92ZXJlZCIsImNyZWF0ZUV2ZW50cyIsImNhbGN1bGF0ZURpc3RhbmNlIiwiZHgiLCJvZmZzZXRYIiwiaW5pdGlhbENsaWNrIiwiZHkiLCJvZmZzZXRZIiwicm91bmQiLCJzcXJ0IiwiZmlsdGVyUG9pbnRlckV2ZW50cyIsImludGVyc2VjdCIsImR1cGxpY2F0ZXMiLCJTZXQiLCJpbnRlcnNlY3Rpb25zIiwiZXZlbnRzT2JqZWN0cyIsInJheWNhc3RlciIsImV2ZW50cyIsImNvbXB1dGUiLCJoYW5kbGVSYXljYXN0IiwiZW5hYmxlZCIsIl9zdGF0ZSRwcmV2aW91c1Jvb3QiLCJpbnRlcnNlY3RPYmplY3QiLCJoaXRzIiwiZmxhdE1hcCIsInNvcnQiLCJhU3RhdGUiLCJiU3RhdGUiLCJkaXN0YW5jZSIsInByaW9yaXR5IiwiaXRlbSIsImlkIiwiaGFzIiwiaGl0IiwiX3IzZjIiLCJ2YWx1ZXMiLCJpbnRlcnNlY3Rpb24iLCJoYW5kbGVJbnRlcnNlY3RzIiwiZGVsdGEiLCJzdG9wcGVkIiwicG9pbnRlciIsInVucHJvamVjdGVkUG9pbnQiLCJWZWN0b3IzIiwieSIsInVucHJvamVjdCIsImhhc1BvaW50ZXJDYXB0dXJlIiwiX2ludGVybmFsJGNhcHR1cmVkTWFwIiwiX2ludGVybmFsJGNhcHR1cmVkTWFwMiIsInNldFBvaW50ZXJDYXB0dXJlIiwiZXh0cmFjdEV2ZW50UHJvcHMiLCJwcm9wZXJ0eSIsInJheWNhc3RFdmVudCIsInJheSIsInN0b3BQcm9wYWdhdGlvbiIsImNhcHR1cmVzRm9yUG9pbnRlciIsImZyb20iLCJmaW5kIiwiaGlnaGVyIiwiY2FuY2VsUG9pbnRlciIsImN1cnJlbnRUYXJnZXQiLCJuYXRpdmVFdmVudCIsImhvdmVyZWRPYmoiLCJvblBvaW50ZXJPdXQiLCJvblBvaW50ZXJMZWF2ZSIsInBvaW50ZXJNaXNzZWQiLCJvblBvaW50ZXJNaXNzZWQiLCJoYW5kbGVQb2ludGVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaGFuZGxlRXZlbnQiLCJsYXN0RXZlbnQiLCJpc1BvaW50ZXJNb3ZlIiwiaXNDbGlja0V2ZW50IiwibWFwIiwib25JbnRlcnNlY3QiLCJvblBvaW50ZXJPdmVyIiwib25Qb2ludGVyRW50ZXIiLCJob3ZlcmVkSXRlbSIsIm9uUG9pbnRlck1vdmUiLCJoYW5kbGVyIiwicHJpdmF0ZUtleXMiLCJpc1JlbmRlcmVyIiwiY29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJjcmVhdGVTdG9yZSIsImFkdmFuY2UiLCJwb3NpdGlvbiIsImRlZmF1bHRUYXJnZXQiLCJ0ZW1wVGFyZ2V0IiwiZ2V0Q3VycmVudFZpZXdwb3J0IiwiZ2V0V29ybGRQb3NpdGlvbiIsImRpc3RhbmNlVG8iLCJ6b29tIiwiZmFjdG9yIiwiZm92IiwiUEkiLCJoIiwidGFuIiwidyIsInBlcmZvcm1hbmNlVGltZW91dCIsInNldFBlcmZvcm1hbmNlQ3VycmVudCIsIlZlY3RvcjIiLCJjb25uZWN0ZWQiLCJ4ciIsInRpbWVzdGFtcCIsInJ1bkdsb2JhbEVmZmVjdHMiLCJsZWdhY3kiLCJmbGF0IiwiY29udHJvbHMiLCJjbG9jayIsIkNsb2NrIiwibW91c2UiLCJmcmFtZWxvb3AiLCJkZWJvdW5jZSIsInJlZ3Jlc3MiLCJ1cGRhdGVTdHlsZSIsInZpZXdwb3J0IiwiaW5pdGlhbERwciIsInNldEV2ZW50cyIsInNldFNpemUiLCJzZXREcHIiLCJyZXNvbHZlZCIsInNldEZyYW1lbG9vcCIsInN0b3AiLCJlbGFwc2VkVGltZSIsInN0YXJ0IiwiYWN0aXZlIiwiY3JlYXRlUmVmIiwic3Vic2NyaWJlcnMiLCJzdWJzY3JpYmUiLCJzIiwib2xkU2l6ZSIsIm9sZERwciIsIm9sZENhbWVyYSIsIl9zaXplJHVwZGF0ZVN0eWxlIiwic2V0UGl4ZWxSYXRpbyIsIkhUTUxDYW52YXNFbGVtZW50IiwiZG9tRWxlbWVudCIsImNyZWF0ZVN1YnMiLCJzdWJzIiwic3ViIiwiZ2xvYmFsRWZmZWN0cyIsImdsb2JhbEFmdGVyRWZmZWN0cyIsImdsb2JhbFRhaWxFZmZlY3RzIiwiYWRkRWZmZWN0IiwiYWRkQWZ0ZXJFZmZlY3QiLCJhZGRUYWlsIiwicnVuIiwiZWZmZWN0cyIsImZsdXNoR2xvYmFsRWZmZWN0cyIsInN1YnNjcmlwdGlvbiIsInJlbmRlciQxIiwiZnJhbWUiLCJnZXREZWx0YSIsIm9sZFRpbWUiLCJjcmVhdGVMb29wIiwicm9vdHMiLCJydW5uaW5nIiwicmVwZWF0IiwibG9vcCIsIl9zdGF0ZSRnbCR4ciIsImlzUHJlc2VudGluZyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiX3N0YXRlJGdsJHhyMiIsInVzZUluc3RhbmNlSGFuZGxlIiwidXNlU3RvcmUiLCJ1c2VDb250ZXh0IiwidXNlVGhyZWUiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm4iLCJ1c2VGcmFtZSIsInJlbmRlclByaW9yaXR5IiwidXNlR3JhcGgiLCJ1c2VNZW1vIiwibWVtb2l6ZWRMb2FkZXJzIiwiV2Vha01hcCIsImxvYWRpbmdGbiIsImV4dGVuc2lvbnMiLCJvblByb2dyZXNzIiwiUHJvdG8iLCJpbnB1dCIsImxvYWRlciIsImFsbCIsInJlcyIsInJlamVjdCIsImxvYWQiLCJtZXNzYWdlIiwiZmluYWxseSIsInVzZUxvYWRlciIsInJlc3VsdHMiLCJlcXVhbCIsInNoYWxsb3dMb29zZSIsImNyZWF0ZVJlbmRlcmVySW5zdGFuY2UiLCJjYW52YXMiLCJjdXN0b21SZW5kZXJlciIsIldlYkdMUmVuZGVyZXIiLCJwb3dlclByZWZlcmVuY2UiLCJhbnRpYWxpYXMiLCJhbHBoYSIsImNvbXB1dGVJbml0aWFsU2l6ZSIsImRlZmF1bHRTaXplIiwiZGVmYXVsdFN0eWxlIiwicGFyZW50RWxlbWVudCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIk9mZnNjcmVlbkNhbnZhcyIsImNyZWF0ZVJvb3QiLCJwcmV2Um9vdCIsInByZXZGaWJlciIsInByZXZTdG9yZSIsImxvZ1JlY292ZXJhYmxlRXJyb3IiLCJyZXBvcnRFcnJvciIsImNyZWF0ZUNvbnRhaW5lciIsIm9uQ3JlYXRlZCIsImNvbmZpZ3VyZWQiLCJsYXN0Q2FtZXJhIiwiY29uZmlndXJlIiwiZ2xDb25maWciLCJwcm9wc1NpemUiLCJzY2VuZU9wdGlvbnMiLCJvbkNyZWF0ZWRDYWxsYmFjayIsInNoYWRvd3MiLCJvcnRob2dyYXBoaWMiLCJyYXljYXN0T3B0aW9ucyIsImNhbWVyYU9wdGlvbnMiLCJSYXljYXN0ZXIiLCJwYXJhbXMiLCJvcHRpb25zIiwiaXNDYW1lcmEiLCJDYW1lcmEiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsInoiLCJyb3RhdGlvbiIsImxvb2tBdCIsIlNjZW5lIiwiX2dsJHhyIiwiaGFuZGxlWFJGcmFtZSIsImhhbmRsZVNlc3Npb25DaGFuZ2UiLCJzZXRBbmltYXRpb25Mb29wIiwiY29ubmVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkaXNjb25uZWN0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNoYWRvd01hcCIsIm9sZEVuYWJsZWQiLCJvbGRUeXBlIiwiUENGU29mdFNoYWRvd01hcCIsIl90eXBlcyRzaGFkb3dzIiwidHlwZXMiLCJiYXNpYyIsIkJhc2ljU2hhZG93TWFwIiwicGVyY2VudGFnZSIsIlBDRlNoYWRvd01hcCIsInNvZnQiLCJ2YXJpYW5jZSIsIlZTTVNoYWRvd01hcCIsIm5lZWRzVXBkYXRlIiwibGVnYWN5TW9kZSIsIkxpbmVhckVuY29kaW5nIiwidG9uZU1hcHBpbmciLCJOb1RvbmVNYXBwaW5nIiwiQUNFU0ZpbG1pY1RvbmVNYXBwaW5nIiwidXBkYXRlQ29udGFpbmVyIiwiUHJvdmlkZXIiLCJyb290RWxlbWVudCIsInVubW91bnQiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwiY29uZmlnIiwiX3N0YXRlJGdsIiwiX3N0YXRlJGdsJHJlbmRlckxpc3RzIiwiX3N0YXRlJGdsMiIsIl9zdGF0ZSRnbDMiLCJyZW5kZXJMaXN0cyIsImZvcmNlQ29udGV4dExvc3MiLCJjcmVhdGVQb3J0YWwiLCJQb3J0YWwiLCJyZXN0IiwidXNlU3RhdGUiLCJpbmplY3QiLCJ1c2VDYWxsYmFjayIsImluamVjdFN0YXRlIiwidXNlUG9ydGFsU3RvcmUiLCJwcmV2aW91c1N0YXRlIiwidW5zdWIiLCJwcmV2Iiwic2V0U3RhdGUiLCJkZXN0cm95IiwiRnJhZ21lbnQiLCJpbmplY3RJbnRvRGV2VG9vbHMiLCJidW5kbGVUeXBlIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsInZlcnNpb24iLCJhY3QiLCJ1bnN0YWJsZV9hY3QiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJjIiwiZCIsImYiLCJnIiwiaiIsImsiLCJsIiwibSIsIm4iLCJxIiwiciIsInQiLCJ1IiwidiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   act: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   addEffect: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   addTail: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   advance: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   applyProps: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   buildGraph: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   context: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   createEvents: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createPortal: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createRoot: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   dispose: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   events: () => (/* binding */ createPointerEvents),\n/* harmony export */   extend: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   getRootState: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   invalidate: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   reconciler: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   render: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   useGraph: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   useLoader: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   useStore: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   useThree: () => (/* reexport safe */ _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)\n/* harmony export */ });\n/* harmony import */ var _index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-8afac004.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/index.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst DOM_EVENTS = {\n    onClick: [\n        \"click\",\n        false\n    ],\n    onContextMenu: [\n        \"contextmenu\",\n        false\n    ],\n    onDoubleClick: [\n        \"dblclick\",\n        false\n    ],\n    onWheel: [\n        \"wheel\",\n        true\n    ],\n    onPointerDown: [\n        \"pointerdown\",\n        true\n    ],\n    onPointerUp: [\n        \"pointerup\",\n        true\n    ],\n    onPointerLeave: [\n        \"pointerleave\",\n        true\n    ],\n    onPointerMove: [\n        \"pointermove\",\n        true\n    ],\n    onPointerCancel: [\n        \"pointercancel\",\n        true\n    ],\n    onLostPointerCapture: [\n        \"lostpointercapture\",\n        true\n    ]\n};\n/** Default R3F event manager for web */ function createPointerEvents(store) {\n    const { handlePointer } = (0,_index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(store);\n    return {\n        priority: 1,\n        enabled: true,\n        compute (event, state, previous) {\n            // https://github.com/pmndrs/react-three-fiber/pull/782\n            // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n            state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n            state.raycaster.setFromCamera(state.pointer, state.camera);\n        },\n        connected: undefined,\n        handlers: Object.keys(DOM_EVENTS).reduce((acc, key)=>({\n                ...acc,\n                [key]: handlePointer(key)\n            }), {}),\n        update: ()=>{\n            var _internal$lastEvent;\n            const { events, internal } = store.getState();\n            if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n        },\n        connect: (target)=>{\n            var _events$handlers;\n            const { set, events } = store.getState();\n            events.disconnect == null ? void 0 : events.disconnect();\n            set((state)=>({\n                    events: {\n                        ...state.events,\n                        connected: target\n                    }\n                }));\n            Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(([name, event])=>{\n                const [eventName, passive] = DOM_EVENTS[name];\n                target.addEventListener(eventName, event, {\n                    passive\n                });\n            });\n        },\n        disconnect: ()=>{\n            const { set, events } = store.getState();\n            if (events.connected) {\n                var _events$handlers2;\n                Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event])=>{\n                    if (events && events.connected instanceof HTMLElement) {\n                        const [eventName] = DOM_EVENTS[name];\n                        events.connected.removeEventListener(eventName, event);\n                    }\n                });\n                set((state)=>({\n                        events: {\n                            ...state.events,\n                            connected: undefined\n                        }\n                    }));\n            }\n        }\n    };\n}\nconst CanvasImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function Canvas({ children, fallback, resize, style, gl, events = createPointerEvents, eventSource, eventPrefix, shadows, linear, flat, legacy, orthographic, frameloop, dpr, performance, raycaster, camera, scene, onPointerMissed, onCreated, ...props }, forwardedRef) {\n    // Create a known catalogue of Threejs-native elements\n    // This will include the entire THREE namespace by default, users can extend\n    // their own elements by using the createRoot API instead\n    react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>(0,_index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__), []);\n    const Bridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_7__.useContextBridge)();\n    const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n        scroll: true,\n        debounce: {\n            scroll: 50,\n            resize: 0\n        },\n        ...resize\n    });\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    const divRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_2__.useImperativeHandle(forwardedRef, ()=>canvasRef.current);\n    const handlePointerMissed = (0,_index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(onPointerMissed);\n    const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);\n    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);\n    // Suspend this component if block is a promise (2nd run)\n    if (block) throw block;\n    // Throw exception outwards if anything within canvas throws\n    if (error) throw error;\n    const root = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    (0,_index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(()=>{\n        const canvas = canvasRef.current;\n        if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n            if (!root.current) root.current = (0,_index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(canvas);\n            root.current.configure({\n                gl,\n                events,\n                shadows,\n                linear,\n                flat,\n                legacy,\n                orthographic,\n                frameloop,\n                dpr,\n                performance,\n                raycaster,\n                camera,\n                scene,\n                size: containerRect,\n                // Pass mutable reference to onPointerMissed so it's free to update\n                onPointerMissed: (...args)=>handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n                onCreated: (state)=>{\n                    // Connect to event source\n                    state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n                    // Set up compute function\n                    if (eventPrefix) {\n                        state.setEvents({\n                            compute: (event, state)=>{\n                                const x = event[eventPrefix + \"X\"];\n                                const y = event[eventPrefix + \"Y\"];\n                                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                                state.raycaster.setFromCamera(state.pointer, state.camera);\n                            }\n                        });\n                    }\n                    // Call onCreated callback\n                    onCreated == null ? void 0 : onCreated(state);\n                }\n            });\n            root.current.render(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(Bridge, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(_index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n                set: setError\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Suspense, {\n                fallback: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(_index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                    set: setBlock\n                })\n            }, children))));\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_2__.useEffect(()=>{\n        const canvas = canvasRef.current;\n        if (canvas) return ()=>(0,_index_8afac004_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas);\n    }, []);\n    // When the event source is not this div, we need to set pointer-events to none\n    // Or else the canvas will block events from reaching the event source\n    const pointerEvents = eventSource ? \"none\" : \"auto\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        ref: divRef,\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            pointerEvents,\n            ...style\n        }\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", {\n        ref: containerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\"\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"canvas\", {\n        ref: canvasRef,\n        style: {\n            display: \"block\"\n        }\n    }, fallback)));\n});\n/**\r\n * A DOM canvas which accepts threejs elements as children.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\r\n */ const Canvas = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function CanvasWrapper(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(its_fine__WEBPACK_IMPORTED_MODULE_7__.FiberProvider, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(CanvasImpl, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({}, props, {\n        ref: ref\n    })));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNE47QUFDeVI7QUFDM2I7QUFDM0I7QUFDQTtBQUNZO0FBQ2dCO0FBQ3ZCO0FBQ25CO0FBQ1M7QUFDUDtBQUNJO0FBRXZCLE1BQU1zRSxhQUFhO0lBQ2pCQyxTQUFTO1FBQUM7UUFBUztLQUFNO0lBQ3pCQyxlQUFlO1FBQUM7UUFBZTtLQUFNO0lBQ3JDQyxlQUFlO1FBQUM7UUFBWTtLQUFNO0lBQ2xDQyxTQUFTO1FBQUM7UUFBUztLQUFLO0lBQ3hCQyxlQUFlO1FBQUM7UUFBZTtLQUFLO0lBQ3BDQyxhQUFhO1FBQUM7UUFBYTtLQUFLO0lBQ2hDQyxnQkFBZ0I7UUFBQztRQUFnQjtLQUFLO0lBQ3RDQyxlQUFlO1FBQUM7UUFBZTtLQUFLO0lBQ3BDQyxpQkFBaUI7UUFBQztRQUFpQjtLQUFLO0lBQ3hDQyxzQkFBc0I7UUFBQztRQUFzQjtLQUFLO0FBQ3BEO0FBRUEsc0NBQXNDLEdBQ3RDLFNBQVNDLG9CQUFvQkMsS0FBSztJQUNoQyxNQUFNLEVBQ0pDLGFBQWEsRUFDZCxHQUFHbEYseURBQVlBLENBQUNpRjtJQUNqQixPQUFPO1FBQ0xFLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxTQUFRQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsUUFBUTtZQUM1Qix1REFBdUQ7WUFDdkQsNEZBQTRGO1lBQzVGRCxNQUFNRSxPQUFPLENBQUNDLEdBQUcsQ0FBQ0osTUFBTUssT0FBTyxHQUFHSixNQUFNSyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJLEdBQUcsQ0FBRVAsQ0FBQUEsTUFBTVEsT0FBTyxHQUFHUCxNQUFNSyxJQUFJLENBQUNHLE1BQU0sSUFBSSxJQUFJO1lBQ3ZHUixNQUFNUyxTQUFTLENBQUNDLGFBQWEsQ0FBQ1YsTUFBTUUsT0FBTyxFQUFF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QUFPO1FBQ2hDLElBQUlzRCxRQUFRLE9BQU8sSUFBTXZKLHlEQUFzQkEsQ0FBQ3VKO0lBQ2xELEdBQUcsRUFBRTtJQUVMLCtFQUErRTtJQUMvRSxzRUFBc0U7SUFDdEUsTUFBTU8sZ0JBQWdCdkMsY0FBYyxTQUFTO0lBQzdDLE9BQU8sV0FBVyxHQUFFdkUsZ0RBQW1CLENBQUMsT0FBT0QsOEVBQVFBLENBQUM7UUFDdERnSCxLQUFLakI7UUFDTHpCLE9BQU87WUFDTDJDLFVBQVU7WUFDVm5GLE9BQU87WUFDUEUsUUFBUTtZQUNSa0YsVUFBVTtZQUNWSDtZQUNBLEdBQUd6QyxLQUFLO1FBQ1Y7SUFDRixHQUFHZSxRQUFRLFdBQVcsR0FBRXBGLGdEQUFtQixDQUFDLE9BQU87UUFDakQrRyxLQUFLdkI7UUFDTG5CLE9BQU87WUFDTHhDLE9BQU87WUFDUEUsUUFBUTtRQUNWO0lBQ0YsR0FBRyxXQUFXLEdBQUUvQixnREFBbUIsQ0FBQyxVQUFVO1FBQzVDK0csS0FBS25CO1FBQ0x2QixPQUFPO1lBQ0w2QyxTQUFTO1FBQ1g7SUFDRixHQUFHL0M7QUFDTDtBQUVBOzs7Q0FHQyxHQUNELE1BQU1GLFNBQVMsV0FBVyxHQUFFakUsNkNBQWdCLENBQUMsU0FBU21ILGNBQWMvQixLQUFLLEVBQUUyQixHQUFHO0lBQzVFLE9BQU8sV0FBVyxHQUFFL0csZ0RBQW1CLENBQUNHLG1EQUFhQSxFQUFFLE1BQU0sV0FBVyxHQUFFSCxnREFBbUIsQ0FBQytELFlBQVloRSw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdxRixPQUFPO1FBQzVIMkIsS0FBS0E7SUFDUDtBQUNGO0FBRWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm9ja2V0c2ltLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9kaXN0L3JlYWN0LXRocmVlLWZpYmVyLmVzbS5qcz83OWNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGMgYXMgY3JlYXRlRXZlbnRzLCBlIGFzIGV4dGVuZCwgdSBhcyB1c2VNdXRhYmxlQ2FsbGJhY2ssIGEgYXMgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCwgYiBhcyBjcmVhdGVSb290LCBpIGFzIGlzUmVmLCBFIGFzIEVycm9yQm91bmRhcnksIEIgYXMgQmxvY2ssIGQgYXMgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB9IGZyb20gJy4vaW5kZXgtOGFmYWMwMDQuZXNtLmpzJztcbmV4cG9ydCB7IHQgYXMgUmVhY3RUaHJlZUZpYmVyLCB4IGFzIF9yb290cywgdiBhcyBhY3QsIG8gYXMgYWRkQWZ0ZXJFZmZlY3QsIG4gYXMgYWRkRWZmZWN0LCBwIGFzIGFkZFRhaWwsIG0gYXMgYWR2YW5jZSwgaiBhcyBhcHBseVByb3BzLCB3IGFzIGJ1aWxkR3JhcGgsIGYgYXMgY29udGV4dCwgYyBhcyBjcmVhdGVFdmVudHMsIGcgYXMgY3JlYXRlUG9ydGFsLCBiIGFzIGNyZWF0ZVJvb3QsIGsgYXMgZGlzcG9zZSwgZSBhcyBleHRlbmQsIHEgYXMgZmx1c2hHbG9iYWxFZmZlY3RzLCBzIGFzIGdldFJvb3RTdGF0ZSwgbCBhcyBpbnZhbGlkYXRlLCBoIGFzIHJlY29uY2lsZXIsIHIgYXMgcmVuZGVyLCBkIGFzIHVubW91bnRDb21wb25lbnRBdE5vZGUsIEMgYXMgdXNlRnJhbWUsIEQgYXMgdXNlR3JhcGgsIHkgYXMgdXNlSW5zdGFuY2VIYW5kbGUsIEYgYXMgdXNlTG9hZGVyLCB6IGFzIHVzZVN0b3JlLCBBIGFzIHVzZVRocmVlIH0gZnJvbSAnLi9pbmRleC04YWZhYzAwNC5lc20uanMnO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHVzZU1lYXN1cmUgZnJvbSAncmVhY3QtdXNlLW1lYXN1cmUnO1xuaW1wb3J0IHsgRmliZXJQcm92aWRlciwgdXNlQ29udGV4dEJyaWRnZSB9IGZyb20gJ2l0cy1maW5lJztcbmltcG9ydCAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0ICd6dXN0YW5kJztcbmltcG9ydCAncmVhY3QtcmVjb25jaWxlcic7XG5pbXBvcnQgJ3NjaGVkdWxlcic7XG5pbXBvcnQgJ3N1c3BlbmQtcmVhY3QnO1xuXG5jb25zdCBET01fRVZFTlRTID0ge1xuICBvbkNsaWNrOiBbJ2NsaWNrJywgZmFsc2VdLFxuICBvbkNvbnRleHRNZW51OiBbJ2NvbnRleHRtZW51JywgZmFsc2VdLFxuICBvbkRvdWJsZUNsaWNrOiBbJ2RibGNsaWNrJywgZmFsc2VdLFxuICBvbldoZWVsOiBbJ3doZWVsJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckRvd246IFsncG9pbnRlcmRvd24nLCB0cnVlXSxcbiAgb25Qb2ludGVyVXA6IFsncG9pbnRlcnVwJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckxlYXZlOiBbJ3BvaW50ZXJsZWF2ZScsIHRydWVdLFxuICBvblBvaW50ZXJNb3ZlOiBbJ3BvaW50ZXJtb3ZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckNhbmNlbDogWydwb2ludGVyY2FuY2VsJywgdHJ1ZV0sXG4gIG9uTG9zdFBvaW50ZXJDYXB0dXJlOiBbJ2xvc3Rwb2ludGVyY2FwdHVyZScsIHRydWVdXG59O1xuXG4vKiogRGVmYXVsdCBSM0YgZXZlbnQgbWFuYWdlciBmb3Igd2ViICovXG5mdW5jdGlvbiBjcmVhdGVQb2ludGVyRXZlbnRzKHN0b3JlKSB7XG4gIGNvbnN0IHtcbiAgICBoYW5kbGVQb2ludGVyXG4gIH0gPSBjcmVhdGVFdmVudHMoc3RvcmUpO1xuICByZXR1cm4ge1xuICAgIHByaW9yaXR5OiAxLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgY29tcHV0ZShldmVudCwgc3RhdGUsIHByZXZpb3VzKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvNzgyXG4gICAgICAvLyBFdmVudHMgdHJpZ2dlciBvdXRzaWRlIG9mIGNhbnZhcyB3aGVuIG1vdmVkLCB1c2Ugb2Zmc2V0WC9ZIGJ5IGRlZmF1bHQgYW5kIGFsbG93IG92ZXJyaWRlc1xuICAgICAgc3RhdGUucG9pbnRlci5zZXQoZXZlbnQub2Zmc2V0WCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLShldmVudC5vZmZzZXRZIC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgc3RhdGUucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoc3RhdGUucG9pbnRlciwgc3RhdGUuY2FtZXJhKTtcbiAgICB9LFxuICAgIGNvbm5lY3RlZDogdW5kZWZpbmVkLFxuICAgIGhhbmRsZXJzOiBPYmplY3Qua2V5cyhET01fRVZFTlRTKS5yZWR1Y2UoKGFjYywga2V5KSA9PiAoe1xuICAgICAgLi4uYWNjLFxuICAgICAgW2tleV06IGhhbmRsZVBvaW50ZXIoa2V5KVxuICAgIH0pLCB7fSksXG4gICAgdXBkYXRlOiAoKSA9PiB7XG4gICAgICB2YXIgX2ludGVybmFsJGxhc3RFdmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBpbnRlcm5hbFxuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoKF9pbnRlcm5hbCRsYXN0RXZlbnQgPSBpbnRlcm5hbC5sYXN0RXZlbnQpICE9IG51bGwgJiYgX2ludGVybmFsJGxhc3RFdmVudC5jdXJyZW50ICYmIGV2ZW50cy5oYW5kbGVycykgZXZlbnRzLmhhbmRsZXJzLm9uUG9pbnRlck1vdmUoaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQpO1xuICAgIH0sXG4gICAgY29ubmVjdDogdGFyZ2V0ID0+IHtcbiAgICAgIHZhciBfZXZlbnRzJGhhbmRsZXJzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBldmVudHMuZGlzY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnRzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgY29ubmVjdGVkOiB0YXJnZXRcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgT2JqZWN0LmVudHJpZXMoKF9ldmVudHMkaGFuZGxlcnMgPSBldmVudHMuaGFuZGxlcnMpICE9IG51bGwgPyBfZXZlbnRzJGhhbmRsZXJzIDogW10pLmZvckVhY2goKFtuYW1lLCBldmVudF0pID0+IHtcbiAgICAgICAgY29uc3QgW2V2ZW50TmFtZSwgcGFzc2l2ZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50LCB7XG4gICAgICAgICAgcGFzc2l2ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoZXZlbnRzLmNvbm5lY3RlZCkge1xuICAgICAgICB2YXIgX2V2ZW50cyRoYW5kbGVyczI7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKChfZXZlbnRzJGhhbmRsZXJzMiA9IGV2ZW50cy5oYW5kbGVycykgIT0gbnVsbCA/IF9ldmVudHMkaGFuZGxlcnMyIDogW10pLmZvckVhY2goKFtuYW1lLCBldmVudF0pID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnRzICYmIGV2ZW50cy5jb25uZWN0ZWQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgW2V2ZW50TmFtZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICAgICAgZXZlbnRzLmNvbm5lY3RlZC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgICAgY29ubmVjdGVkOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IENhbnZhc0ltcGwgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDYW52YXMoe1xuICBjaGlsZHJlbixcbiAgZmFsbGJhY2ssXG4gIHJlc2l6ZSxcbiAgc3R5bGUsXG4gIGdsLFxuICBldmVudHMgPSBjcmVhdGVQb2ludGVyRXZlbnRzLFxuICBldmVudFNvdXJjZSxcbiAgZXZlbnRQcmVmaXgsXG4gIHNoYWRvd3MsXG4gIGxpbmVhcixcbiAgZmxhdCxcbiAgbGVnYWN5LFxuICBvcnRob2dyYXBoaWMsXG4gIGZyYW1lbG9vcCxcbiAgZHByLFxuICBwZXJmb3JtYW5jZSxcbiAgcmF5Y2FzdGVyLFxuICBjYW1lcmEsXG4gIHNjZW5lLFxuICBvblBvaW50ZXJNaXNzZWQsXG4gIG9uQ3JlYXRlZCxcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRlZFJlZikge1xuICAvLyBDcmVhdGUgYSBrbm93biBjYXRhbG9ndWUgb2YgVGhyZWVqcy1uYXRpdmUgZWxlbWVudHNcbiAgLy8gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIGVudGlyZSBUSFJFRSBuYW1lc3BhY2UgYnkgZGVmYXVsdCwgdXNlcnMgY2FuIGV4dGVuZFxuICAvLyB0aGVpciBvd24gZWxlbWVudHMgYnkgdXNpbmcgdGhlIGNyZWF0ZVJvb3QgQVBJIGluc3RlYWRcbiAgUmVhY3QudXNlTWVtbygoKSA9PiBleHRlbmQoVEhSRUUpLCBbXSk7XG4gIGNvbnN0IEJyaWRnZSA9IHVzZUNvbnRleHRCcmlkZ2UoKTtcbiAgY29uc3QgW2NvbnRhaW5lclJlZiwgY29udGFpbmVyUmVjdF0gPSB1c2VNZWFzdXJlKHtcbiAgICBzY3JvbGw6IHRydWUsXG4gICAgZGVib3VuY2U6IHtcbiAgICAgIHNjcm9sbDogNTAsXG4gICAgICByZXNpemU6IDBcbiAgICB9LFxuICAgIC4uLnJlc2l6ZVxuICB9KTtcbiAgY29uc3QgY2FudmFzUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBkaXZSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiBjYW52YXNSZWYuY3VycmVudCk7XG4gIGNvbnN0IGhhbmRsZVBvaW50ZXJNaXNzZWQgPSB1c2VNdXRhYmxlQ2FsbGJhY2sob25Qb2ludGVyTWlzc2VkKTtcbiAgY29uc3QgW2Jsb2NrLCBzZXRCbG9ja10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIFN1c3BlbmQgdGhpcyBjb21wb25lbnQgaWYgYmxvY2sgaXMgYSBwcm9taXNlICgybmQgcnVuKVxuICBpZiAoYmxvY2spIHRocm93IGJsb2NrO1xuICAvLyBUaHJvdyBleGNlcHRpb24gb3V0d2FyZHMgaWYgYW55dGhpbmcgd2l0aGluIGNhbnZhcyB0aHJvd3NcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgY29uc3Qgcm9vdCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNvbnRhaW5lclJlY3Qud2lkdGggPiAwICYmIGNvbnRhaW5lclJlY3QuaGVpZ2h0ID4gMCAmJiBjYW52YXMpIHtcbiAgICAgIGlmICghcm9vdC5jdXJyZW50KSByb290LmN1cnJlbnQgPSBjcmVhdGVSb290KGNhbnZhcyk7XG4gICAgICByb290LmN1cnJlbnQuY29uZmlndXJlKHtcbiAgICAgICAgZ2wsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgc2hhZG93cyxcbiAgICAgICAgbGluZWFyLFxuICAgICAgICBmbGF0LFxuICAgICAgICBsZWdhY3ksXG4gICAgICAgIG9ydGhvZ3JhcGhpYyxcbiAgICAgICAgZnJhbWVsb29wLFxuICAgICAgICBkcHIsXG4gICAgICAgIHBlcmZvcm1hbmNlLFxuICAgICAgICByYXljYXN0ZXIsXG4gICAgICAgIGNhbWVyYSxcbiAgICAgICAgc2NlbmUsXG4gICAgICAgIHNpemU6IGNvbnRhaW5lclJlY3QsXG4gICAgICAgIC8vIFBhc3MgbXV0YWJsZSByZWZlcmVuY2UgdG8gb25Qb2ludGVyTWlzc2VkIHNvIGl0J3MgZnJlZSB0byB1cGRhdGVcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkOiAoLi4uYXJncykgPT4gaGFuZGxlUG9pbnRlck1pc3NlZC5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVQb2ludGVyTWlzc2VkLmN1cnJlbnQoLi4uYXJncyksXG4gICAgICAgIG9uQ3JlYXRlZDogc3RhdGUgPT4ge1xuICAgICAgICAgIC8vIENvbm5lY3QgdG8gZXZlbnQgc291cmNlXG4gICAgICAgICAgc3RhdGUuZXZlbnRzLmNvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb25uZWN0KGV2ZW50U291cmNlID8gaXNSZWYoZXZlbnRTb3VyY2UpID8gZXZlbnRTb3VyY2UuY3VycmVudCA6IGV2ZW50U291cmNlIDogZGl2UmVmLmN1cnJlbnQpO1xuICAgICAgICAgIC8vIFNldCB1cCBjb21wdXRlIGZ1bmN0aW9uXG4gICAgICAgICAgaWYgKGV2ZW50UHJlZml4KSB7XG4gICAgICAgICAgICBzdGF0ZS5zZXRFdmVudHMoe1xuICAgICAgICAgICAgICBjb21wdXRlOiAoZXZlbnQsIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGV2ZW50W2V2ZW50UHJlZml4ICsgJ1gnXTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWSddO1xuICAgICAgICAgICAgICAgIHN0YXRlLnBvaW50ZXIuc2V0KHggLyBzdGF0ZS5zaXplLndpZHRoICogMiAtIDEsIC0oeSAvIHN0YXRlLnNpemUuaGVpZ2h0KSAqIDIgKyAxKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzdGF0ZS5wb2ludGVyLCBzdGF0ZS5jYW1lcmEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ2FsbCBvbkNyZWF0ZWQgY2FsbGJhY2tcbiAgICAgICAgICBvbkNyZWF0ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ3JlYXRlZChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcm9vdC5jdXJyZW50LnJlbmRlciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQnJpZGdlLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIHNldDogc2V0RXJyb3JcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LlN1c3BlbnNlLCB7XG4gICAgICAgIGZhbGxiYWNrOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChCbG9jaywge1xuICAgICAgICAgIHNldDogc2V0QmxvY2tcbiAgICAgICAgfSlcbiAgICAgIH0sIGNoaWxkcmVuKSkpKTtcbiAgICB9XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmIChjYW52YXMpIHJldHVybiAoKSA9PiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcyk7XG4gIH0sIFtdKTtcblxuICAvLyBXaGVuIHRoZSBldmVudCBzb3VyY2UgaXMgbm90IHRoaXMgZGl2LCB3ZSBuZWVkIHRvIHNldCBwb2ludGVyLWV2ZW50cyB0byBub25lXG4gIC8vIE9yIGVsc2UgdGhlIGNhbnZhcyB3aWxsIGJsb2NrIGV2ZW50cyBmcm9tIHJlYWNoaW5nIHRoZSBldmVudCBzb3VyY2VcbiAgY29uc3QgcG9pbnRlckV2ZW50cyA9IGV2ZW50U291cmNlID8gJ25vbmUnIDogJ2F1dG8nO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogZGl2UmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIHBvaW50ZXJFdmVudHMsXG4gICAgICAuLi5zdHlsZVxuICAgIH1cbiAgfSwgcHJvcHMpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgIH1cbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwge1xuICAgIHJlZjogY2FudmFzUmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfVxuICB9LCBmYWxsYmFjaykpKTtcbn0pO1xuXG4vKipcclxuICogQSBET00gY2FudmFzIHdoaWNoIGFjY2VwdHMgdGhyZWVqcyBlbGVtZW50cyBhcyBjaGlsZHJlbi5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvY2FudmFzXHJcbiAqL1xuY29uc3QgQ2FudmFzID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ2FudmFzV3JhcHBlcihwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGaWJlclByb3ZpZGVyLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDYW52YXNJbXBsLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZlxuICB9KSkpO1xufSk7XG5cbmV4cG9ydCB7IENhbnZhcywgY3JlYXRlUG9pbnRlckV2ZW50cyBhcyBldmVudHMgfTtcbiJdLCJuYW1lcyI6WyJjIiwiY3JlYXRlRXZlbnRzIiwiZSIsImV4dGVuZCIsInUiLCJ1c2VNdXRhYmxlQ2FsbGJhY2siLCJhIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImIiLCJjcmVhdGVSb290IiwiaSIsImlzUmVmIiwiRSIsIkVycm9yQm91bmRhcnkiLCJCIiwiQmxvY2siLCJkIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInQiLCJSZWFjdFRocmVlRmliZXIiLCJ4IiwiX3Jvb3RzIiwidiIsImFjdCIsIm8iLCJhZGRBZnRlckVmZmVjdCIsIm4iLCJhZGRFZmZlY3QiLCJwIiwiYWRkVGFpbCIsIm0iLCJhZHZhbmNlIiwiaiIsImFwcGx5UHJvcHMiLCJ3IiwiYnVpbGRHcmFwaCIsImYiLCJjb250ZXh0IiwiZyIsImNyZWF0ZVBvcnRhbCIsImsiLCJkaXNwb3NlIiwicSIsImZsdXNoR2xvYmFsRWZmZWN0cyIsInMiLCJnZXRSb290U3RhdGUiLCJsIiwiaW52YWxpZGF0ZSIsImgiLCJyZWNvbmNpbGVyIiwiciIsInJlbmRlciIsIkMiLCJ1c2VGcmFtZSIsIkQiLCJ1c2VHcmFwaCIsInkiLCJ1c2VJbnN0YW5jZUhhbmRsZSIsIkYiLCJ1c2VMb2FkZXIiLCJ6IiwidXNlU3RvcmUiLCJBIiwidXNlVGhyZWUiLCJfZXh0ZW5kcyIsIlJlYWN0IiwiVEhSRUUiLCJ1c2VNZWFzdXJlIiwiRmliZXJQcm92aWRlciIsInVzZUNvbnRleHRCcmlkZ2UiLCJET01fRVZFTlRTIiwib25DbGljayIsIm9uQ29udGV4dE1lbnUiLCJvbkRvdWJsZUNsaWNrIiwib25XaGVlbCIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJVcCIsIm9uUG9pbnRlckxlYXZlIiwib25Qb2ludGVyTW92ZSIsIm9uUG9pbnRlckNhbmNlbCIsIm9uTG9zdFBvaW50ZXJDYXB0dXJlIiwiY3JlYXRlUG9pbnRlckV2ZW50cyIsInN0b3JlIiwiaGFuZGxlUG9pbnRlciIsInByaW9yaXR5IiwiZW5hYmxlZCIsImNvbXB1dGUiLCJldmVudCIsInN0YXRlIiwicHJldmlvdXMiLCJwb2ludGVyIiwic2V0Iiwib2Zmc2V0WCIsInNpemUiLCJ3aWR0aCIsIm9mZnNldFkiLCJoZWlnaHQiLCJyYXljYXN0ZXIiLCJzZXRGcm9tQ2FtZXJhIiwiY2FtZXJhIiwiY29ubmVjdGVkIiwidW5kZWZpbmVkIiwiaGFuZGxlcnMiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwiYWNjIiwia2V5IiwidXBkYXRlIiwiX2ludGVybmFsJGxhc3RFdmVudCIsImV2ZW50cyIsImludGVybmFsIiwiZ2V0U3RhdGUiLCJsYXN0RXZlbnQiLCJjdXJyZW50IiwiY29ubmVjdCIsInRhcmdldCIsIl9ldmVudHMkaGFuZGxlcnMiLCJkaXNjb25uZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJuYW1lIiwiZXZlbnROYW1lIiwicGFzc2l2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJfZXZlbnRzJGhhbmRsZXJzMiIsIkhUTUxFbGVtZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkNhbnZhc0ltcGwiLCJmb3J3YXJkUmVmIiwiQ2FudmFzIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsInJlc2l6ZSIsInN0eWxlIiwiZ2wiLCJldmVudFNvdXJjZSIsImV2ZW50UHJlZml4Iiwic2hhZG93cyIsImxpbmVhciIsImZsYXQiLCJsZWdhY3kiLCJvcnRob2dyYXBoaWMiLCJmcmFtZWxvb3AiLCJkcHIiLCJwZXJmb3JtYW5jZSIsInNjZW5lIiwib25Qb2ludGVyTWlzc2VkIiwib25DcmVhdGVkIiwicHJvcHMiLCJmb3J3YXJkZWRSZWYiLCJ1c2VNZW1vIiwiQnJpZGdlIiwiY29udGFpbmVyUmVmIiwiY29udGFpbmVyUmVjdCIsInNjcm9sbCIsImRlYm91bmNlIiwiY2FudmFzUmVmIiwidXNlUmVmIiwiZGl2UmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImhhbmRsZVBvaW50ZXJNaXNzZWQiLCJibG9jayIsInNldEJsb2NrIiwidXNlU3RhdGUiLCJlcnJvciIsInNldEVycm9yIiwicm9vdCIsImNhbnZhcyIsImNvbmZpZ3VyZSIsImFyZ3MiLCJzZXRFdmVudHMiLCJjcmVhdGVFbGVtZW50IiwiU3VzcGVuc2UiLCJ1c2VFZmZlY3QiLCJwb2ludGVyRXZlbnRzIiwicmVmIiwicG9zaXRpb24iLCJvdmVyZmxvdyIsImRpc3BsYXkiLCJDYW52YXNXcmFwcGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/_polyfill/constants.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/_polyfill/constants.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst version = /* @__PURE__ */ (()=>parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")))();\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9fcG9seWZpbGwvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUVhLE1BQUFBLFVBQUEscUJBQWlDQyxTQUFTQywyQ0FBUUEsQ0FBQ0MsT0FBQSxDQUFRLFFBQVEsSUFBRyIsInNvdXJjZXMiOlsid2VicGFjazovL3JvY2tldHNpbS8uLi8uLi9zcmMvX3BvbHlmaWxsL2NvbnN0YW50cy50cz85YzY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJFVklTSU9OIH0gZnJvbSAndGhyZWUnXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBwYXJzZUludChSRVZJU0lPTi5yZXBsYWNlKC9cXEQrL2csICcnKSkpKClcbiJdLCJuYW1lcyI6WyJ2ZXJzaW9uIiwicGFyc2VJbnQiLCJSRVZJU0lPTiIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/_polyfill/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/controls/EventDispatcher.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/controls/EventDispatcher.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventDispatcher: () => (/* binding */ EventDispatcher)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>{\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass EventDispatcher {\n    constructor(){\n        // not defined in @types/three\n        __publicField(this, \"_listeners\");\n    }\n    /**\n   * Adds a listener to an event type.\n   * @param type The type of event to listen to.\n   * @param listener The function that gets called when the event is fired.\n   */ addEventListener(type, listener) {\n        if (this._listeners === void 0) this._listeners = {};\n        const listeners = this._listeners;\n        if (listeners[type] === void 0) {\n            listeners[type] = [];\n        }\n        if (listeners[type].indexOf(listener) === -1) {\n            listeners[type].push(listener);\n        }\n    }\n    /**\n      * Checks if listener is added to an event type.\n      * @param type The type of event to listen to.\n      * @param listener The function that gets called when the event is fired.\n      */ hasEventListener(type, listener) {\n        if (this._listeners === void 0) return false;\n        const listeners = this._listeners;\n        return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n    }\n    /**\n      * Removes a listener from an event type.\n      * @param type The type of the listener that gets removed.\n      * @param listener The listener function that gets removed.\n      */ removeEventListener(type, listener) {\n        if (this._listeners === void 0) return;\n        const listeners = this._listeners;\n        const listenerArray = listeners[type];\n        if (listenerArray !== void 0) {\n            const index = listenerArray.indexOf(listener);\n            if (index !== -1) {\n                listenerArray.splice(index, 1);\n            }\n        }\n    }\n    /**\n      * Fire an event type.\n      * @param event The event that gets fired.\n      */ dispatchEvent(event) {\n        if (this._listeners === void 0) return;\n        const listeners = this._listeners;\n        const listenerArray = listeners[event.type];\n        if (listenerArray !== void 0) {\n            event.target = this;\n            const array = listenerArray.slice(0);\n            for(let i = 0, l = array.length; i < l; i++){\n                array[i].call(this, event);\n            }\n            event.target = null;\n        }\n    }\n}\n //# sourceMappingURL=EventDispatcher.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9jb250cm9scy9FdmVudERpc3BhdGNoZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBNkJPLE1BQU1BO0lBQU5DLGFBQUE7UUFFSztRQUFBQyxjQUFBO0lBQUE7SUFBQTs7OztHQUFBLEdBT1hDLGlCQUNPQyxJQUFBLEVBQ0FDLFFBQUEsRUFDSTtRQUVWLElBQUssS0FBS0MsVUFBQSxLQUFlLFFBQVksS0FBS0EsVUFBQSxHQUFhO1FBRXZELE1BQU1DLFlBQVksS0FBS0QsVUFBQTtRQUVsQixJQUFBQyxTQUFBLENBQVdILEtBQUssS0FBTSxRQUFZO1lBRTNCRyxTQUFBLENBQUFILEtBQUssR0FBSTtRQUVyQjtRQUVBLElBQUtHLFNBQUEsQ0FBV0gsS0FBSyxDQUFFSSxPQUFBLENBQVNILGNBQWUsSUFBTTtZQUV6Q0UsU0FBQSxDQUFBSCxLQUFLLENBQUVLLElBQUEsQ0FBTUo7UUFFekI7SUFFRDtJQUFBOzs7O01BQUEsR0FPR0ssaUJBQ0lOLElBQUEsRUFDQUMsUUFBQSxFQUNPO1FBRWIsSUFBSyxLQUFLQyxVQUFBLEtBQWUsUUFBbUI7UUFFNUMsTUFBTUMsWUFBWSxLQUFLRCxVQUFBO1FBRWhCLE9BQUFDLFNBQUEsQ0FBV0gsS0FBSyxLQUFNLFVBQWFHLFNBQUEsQ0FBV0gsS0FBSyxDQUFFSSxPQUFBLENBQVNILGNBQWU7SUFFckY7SUFBQTs7OztNQUFBLEdBT0dNLG9CQUNJUCxJQUFBLEVBQ0FDLFFBQUEsRUFDSTtRQUVWLElBQUssS0FBS0MsVUFBQSxLQUFlLFFBQVk7UUFFckMsTUFBTUMsWUFBWSxLQUFLRCxVQUFBO1FBQ2pCLE1BQUFNLGdCQUFnQkwsU0FBQSxDQUFXSCxLQUFLO1FBRXRDLElBQUtRLGtCQUFrQixRQUFZO1lBRTVCLE1BQUFDLFFBQVFELGNBQWNKLE9BQUEsQ0FBU0g7WUFFckMsSUFBS1EsVUFBVSxJQUFNO2dCQUVORCxjQUFBRSxNQUFBLENBQVFELE9BQU87WUFFOUI7UUFFRDtJQUVEO0lBQUE7OztNQUFBLEdBTUdFLGNBQTBEQyxLQUFBLEVBQTBDO1FBRXRHLElBQUssS0FBS1YsVUFBQSxLQUFlLFFBQVk7UUFFckMsTUFBTUMsWUFBWSxLQUFLRCxVQUFBO1FBQ2pCLE1BQUFNLGdCQUFnQkwsU0FBQSxDQUFXUyxNQUFNWixJQUFLO1FBRTVDLElBQUtRLGtCQUFrQixRQUFZO1lBRWxDSSxNQUFNQyxNQUFBLEdBQVM7WUFHVCxNQUFBQyxRQUFRTixjQUFjTyxLQUFBLENBQU87WUFFbkMsUUFBVUMsSUFBSSxHQUFHQyxJQUFJSCxNQUFNSSxNQUFBLEVBQVFGLElBQUlDLEdBQUdELElBQU87Z0JBRWhERixLQUFBLENBQU9FLEVBQUUsQ0FBRUcsSUFBQSxDQUFNLE1BQU1QO1lBRXhCO1lBRUFBLE1BQU1DLE1BQUEsR0FBUztRQUVoQjtJQUVEO0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yb2NrZXRzaW0vLi4vLi4vc3JjL2NvbnRyb2xzL0V2ZW50RGlzcGF0Y2hlci50cz8zNDFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5EdWUgdG8gQHR5cGVzL3RocmVlIHIxNjggYnJlYWtpbmcgY2hhbmdlXG53ZSBoYXZlIHRvIG1hbnVhbGx5IGNvcHkgdGhlIEV2ZW50RGlzcGF0Y2hlciBjbGFzcyBmcm9tIHRocmVlLmpzLlxuU28gdGhpcyBmaWxlcyBtZXJnZXMgdGhlIGRlY2xhcmF0aW9ucyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9EZWZpbml0ZWx5VHlwZWQvRGVmaW5pdGVseVR5cGVkL2Jsb2IvbWFzdGVyL3R5cGVzL3RocmVlL3NyYy9jb3JlL0V2ZW50RGlzcGF0Y2hlci5kLnRzXG53aXRoIHRoZSBpbXBsZW1lbnRhdGlvbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9kZXYvc3JjL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzXG5Nb3JlIGluZm8gaW4gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy90aHJlZS1zdGRsaWIvaXNzdWVzLzM4N1xuKi9cblxuLyoqXG4gKiBUaGUgbWluaW1hbCBiYXNpYyBFdmVudCB0aGF0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IGEge0BsaW5rIEV2ZW50RGlzcGF0Y2hlcjw+fS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCYXNlRXZlbnQ8VEV2ZW50VHlwZSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAgIHJlYWRvbmx5IHR5cGU6IFRFdmVudFR5cGU7XG4gICAgLy8gbm90IGRlZmluZWQgaW4gQHR5cGVzL3RocmVlXG4gICAgdGFyZ2V0OiBhbnk7XG59XG5cbi8qKlxuICogVGhlIG1pbmltYWwgZXhwZWN0ZWQgY29udHJhY3Qgb2YgYSBmaXJlZCBFdmVudCB0aGF0IHdhcyBkaXNwYXRjaGVkIGJ5IGEge0BsaW5rIEV2ZW50RGlzcGF0Y2hlcjw+fS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFdmVudDxURXZlbnRUeXBlIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLCBUVGFyZ2V0ID0gdW5rbm93bj4ge1xuICAgIHJlYWRvbmx5IHR5cGU6IFRFdmVudFR5cGU7XG4gICAgcmVhZG9ubHkgdGFyZ2V0OiBUVGFyZ2V0O1xufVxuXG5leHBvcnQgdHlwZSBFdmVudExpc3RlbmVyPFRFdmVudERhdGEsIFRFdmVudFR5cGUgZXh0ZW5kcyBzdHJpbmcsIFRUYXJnZXQ+ID0gKFxuICAgIGV2ZW50OiBURXZlbnREYXRhICYgRXZlbnQ8VEV2ZW50VHlwZSwgVFRhcmdldD4sXG4pID0+IHZvaWQ7XG5cbmV4cG9ydCBjbGFzcyBFdmVudERpc3BhdGNoZXI8VEV2ZW50TWFwIGV4dGVuZHMge30gPSB7fT4ge1xuICAgIC8vIG5vdCBkZWZpbmVkIGluIEB0eXBlcy90aHJlZVxuICAgIHByaXZhdGUgX2xpc3RlbmVyczogYW55O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIGFuIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gbGlzdGVuIHRvLlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBmaXJlZC5cbiAgICAgKi9cblx0YWRkRXZlbnRMaXN0ZW5lcjxUIGV4dGVuZHMgRXh0cmFjdDxrZXlvZiBURXZlbnRNYXAsIHN0cmluZz4+KFxuICAgICAgICB0eXBlOiBULFxuICAgICAgICBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxURXZlbnRNYXBbVF0sIFQsIHRoaXM+LFxuICAgICk6IHZvaWQge1xuXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG5cdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XG5cblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuICAgICAqIENoZWNrcyBpZiBsaXN0ZW5lciBpcyBhZGRlZCB0byBhbiBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIGxpc3RlbiB0by5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gICAgICovXG4gICAgaGFzRXZlbnRMaXN0ZW5lcjxUIGV4dGVuZHMgRXh0cmFjdDxrZXlvZiBURXZlbnRNYXAsIHN0cmluZz4+KFxuICAgICAgICB0eXBlOiBULFxuICAgICAgICBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxURXZlbnRNYXBbVF0sIFQsIHRoaXM+LFxuICAgICk6IGJvb2xlYW4ge1xuXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcblxuXHRcdGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuXHRcdHJldHVybiBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMTtcblxuXHR9XG5cblx0LyoqXG4gICAgICogUmVtb3ZlcyBhIGxpc3RlbmVyIGZyb20gYW4gZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgbGlzdGVuZXIgdGhhdCBnZXRzIHJlbW92ZWQuXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0aGF0IGdldHMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBFeHRyYWN0PGtleW9mIFRFdmVudE1hcCwgc3RyaW5nPj4oXG4gICAgICAgIHR5cGU6IFQsXG4gICAgICAgIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyPFRFdmVudE1hcFtUXSwgVCwgdGhpcz4sXG4gICAgKTogdm9pZCB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdGNvbnN0IGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIHR5cGUgXTtcblxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBpbmRleCA9IGxpc3RlbmVyQXJyYXkuaW5kZXhPZiggbGlzdGVuZXIgKTtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRcdGxpc3RlbmVyQXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuICAgICAqIEZpcmUgYW4gZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRoYXQgZ2V0cyBmaXJlZC5cbiAgICAgKi9cbiAgICBkaXNwYXRjaEV2ZW50PFQgZXh0ZW5kcyBFeHRyYWN0PGtleW9mIFRFdmVudE1hcCwgc3RyaW5nPj4oZXZlbnQ6IEJhc2VFdmVudDxUPiAmIFRFdmVudE1hcFtUXSk6IHZvaWQge1xuXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHRjb25zdCBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF07XG5cblx0XHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcztcblxuXHRcdFx0Ly8gTWFrZSBhIGNvcHksIGluIGNhc2UgbGlzdGVuZXJzIGFyZSByZW1vdmVkIHdoaWxlIGl0ZXJhdGluZy5cblx0XHRcdGNvbnN0IGFycmF5ID0gbGlzdGVuZXJBcnJheS5zbGljZSggMCApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRldmVudC50YXJnZXQgPSBudWxsO1xuXG5cdFx0fVxuXG5cdH1cblxufSJdLCJuYW1lcyI6WyJFdmVudERpc3BhdGNoZXIiLCJjb25zdHJ1Y3RvciIsIl9fcHVibGljRmllbGQiLCJhZGRFdmVudExpc3RlbmVyIiwidHlwZSIsImxpc3RlbmVyIiwiX2xpc3RlbmVycyIsImxpc3RlbmVycyIsImluZGV4T2YiLCJwdXNoIiwiaGFzRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsaXN0ZW5lckFycmF5IiwiaW5kZXgiLCJzcGxpY2UiLCJkaXNwYXRjaEV2ZW50IiwiZXZlbnQiLCJ0YXJnZXQiLCJhcnJheSIsInNsaWNlIiwiaSIsImwiLCJsZW5ndGgiLCJjYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/controls/EventDispatcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/controls/OrbitControls.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/controls/OrbitControls.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MapControls: () => (/* binding */ MapControls),\n/* harmony export */   OrbitControls: () => (/* binding */ OrbitControls)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventDispatcher.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/controls/EventDispatcher.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>{\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\n\n\nconst _ray = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Ray();\nconst _plane = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Plane();\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180));\nconst moduloWrapAround = (offset, capacity)=>(offset % capacity + capacity) % capacity;\nclass OrbitControls extends _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher {\n    constructor(object, domElement){\n        super();\n        __publicField(this, \"object\");\n        __publicField(this, \"domElement\");\n        // Set to false to disable this control\n        __publicField(this, \"enabled\", true);\n        // \"target\" sets the location of focus, where the object orbits around\n        __publicField(this, \"target\", new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n        // How far you can dolly in and out ( PerspectiveCamera only )\n        __publicField(this, \"minDistance\", 0);\n        __publicField(this, \"maxDistance\", Infinity);\n        // How far you can zoom in and out ( OrthographicCamera only )\n        __publicField(this, \"minZoom\", 0);\n        __publicField(this, \"maxZoom\", Infinity);\n        // How far you can orbit vertically, upper and lower limits.\n        // Range is 0 to Math.PI radians.\n        __publicField(this, \"minPolarAngle\", 0);\n        // radians\n        __publicField(this, \"maxPolarAngle\", Math.PI);\n        // radians\n        // How far you can orbit horizontally, upper and lower limits.\n        // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n        __publicField(this, \"minAzimuthAngle\", -Infinity);\n        // radians\n        __publicField(this, \"maxAzimuthAngle\", Infinity);\n        // radians\n        // Set to true to enable damping (inertia)\n        // If damping is enabled, you must call controls.update() in your animation loop\n        __publicField(this, \"enableDamping\", false);\n        __publicField(this, \"dampingFactor\", 0.05);\n        // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n        // Set to false to disable zooming\n        __publicField(this, \"enableZoom\", true);\n        __publicField(this, \"zoomSpeed\", 1);\n        // Set to false to disable rotating\n        __publicField(this, \"enableRotate\", true);\n        __publicField(this, \"rotateSpeed\", 1);\n        // Set to false to disable panning\n        __publicField(this, \"enablePan\", true);\n        __publicField(this, \"panSpeed\", 1);\n        __publicField(this, \"screenSpacePanning\", true);\n        // if false, pan orthogonal to world-space direction camera.up\n        __publicField(this, \"keyPanSpeed\", 7);\n        // pixels moved per arrow key push\n        __publicField(this, \"zoomToCursor\", false);\n        // Set to true to automatically rotate around the target\n        // If auto-rotate is enabled, you must call controls.update() in your animation loop\n        __publicField(this, \"autoRotate\", false);\n        __publicField(this, \"autoRotateSpeed\", 2);\n        // 30 seconds per orbit when fps is 60\n        __publicField(this, \"reverseOrbit\", false);\n        // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n        __publicField(this, \"reverseHorizontalOrbit\", false);\n        // true if you want to reverse the horizontal orbit direction\n        __publicField(this, \"reverseVerticalOrbit\", false);\n        // true if you want to reverse the vertical orbit direction\n        // The four arrow keys\n        __publicField(this, \"keys\", {\n            LEFT: \"ArrowLeft\",\n            UP: \"ArrowUp\",\n            RIGHT: \"ArrowRight\",\n            BOTTOM: \"ArrowDown\"\n        });\n        // Mouse buttons\n        __publicField(this, \"mouseButtons\", {\n            LEFT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE,\n            MIDDLE: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY,\n            RIGHT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN\n        });\n        // Touch fingers\n        __publicField(this, \"touches\", {\n            ONE: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE,\n            TWO: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN\n        });\n        __publicField(this, \"target0\");\n        __publicField(this, \"position0\");\n        __publicField(this, \"zoom0\");\n        // the target DOM element for key events\n        __publicField(this, \"_domElementKeyEvents\", null);\n        __publicField(this, \"getPolarAngle\");\n        __publicField(this, \"getAzimuthalAngle\");\n        __publicField(this, \"setPolarAngle\");\n        __publicField(this, \"setAzimuthalAngle\");\n        __publicField(this, \"getDistance\");\n        // Not used in most scenarios, however they can be useful for specific use cases\n        __publicField(this, \"getZoomScale\");\n        __publicField(this, \"listenToKeyEvents\");\n        __publicField(this, \"stopListenToKeyEvents\");\n        __publicField(this, \"saveState\");\n        __publicField(this, \"reset\");\n        __publicField(this, \"update\");\n        __publicField(this, \"connect\");\n        __publicField(this, \"dispose\");\n        // Dolly in programmatically\n        __publicField(this, \"dollyIn\");\n        // Dolly out programmatically\n        __publicField(this, \"dollyOut\");\n        // Get the current scale\n        __publicField(this, \"getScale\");\n        // Set the current scale (these are not used in most scenarios, however they can be useful for specific use cases)\n        __publicField(this, \"setScale\");\n        this.object = object;\n        this.domElement = domElement;\n        this.target0 = this.target.clone();\n        this.position0 = this.object.position.clone();\n        this.zoom0 = this.object.zoom;\n        this.getPolarAngle = ()=>spherical.phi;\n        this.getAzimuthalAngle = ()=>spherical.theta;\n        this.setPolarAngle = (value)=>{\n            let phi = moduloWrapAround(value, 2 * Math.PI);\n            let currentPhi = spherical.phi;\n            if (currentPhi < 0) currentPhi += 2 * Math.PI;\n            if (phi < 0) phi += 2 * Math.PI;\n            let phiDist = Math.abs(phi - currentPhi);\n            if (2 * Math.PI - phiDist < phiDist) {\n                if (phi < currentPhi) {\n                    phi += 2 * Math.PI;\n                } else {\n                    currentPhi += 2 * Math.PI;\n                }\n            }\n            sphericalDelta.phi = phi - currentPhi;\n            scope.update();\n        };\n        this.setAzimuthalAngle = (value)=>{\n            let theta = moduloWrapAround(value, 2 * Math.PI);\n            let currentTheta = spherical.theta;\n            if (currentTheta < 0) currentTheta += 2 * Math.PI;\n            if (theta < 0) theta += 2 * Math.PI;\n            let thetaDist = Math.abs(theta - currentTheta);\n            if (2 * Math.PI - thetaDist < thetaDist) {\n                if (theta < currentTheta) {\n                    theta += 2 * Math.PI;\n                } else {\n                    currentTheta += 2 * Math.PI;\n                }\n            }\n            sphericalDelta.theta = theta - currentTheta;\n            scope.update();\n        };\n        this.getDistance = ()=>scope.object.position.distanceTo(scope.target);\n        this.listenToKeyEvents = (domElement2)=>{\n            domElement2.addEventListener(\"keydown\", onKeyDown);\n            this._domElementKeyEvents = domElement2;\n        };\n        this.stopListenToKeyEvents = ()=>{\n            this._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n            this._domElementKeyEvents = null;\n        };\n        this.saveState = ()=>{\n            scope.target0.copy(scope.target);\n            scope.position0.copy(scope.object.position);\n            scope.zoom0 = scope.object.zoom;\n        };\n        this.reset = ()=>{\n            scope.target.copy(scope.target0);\n            scope.object.position.copy(scope.position0);\n            scope.object.zoom = scope.zoom0;\n            scope.object.updateProjectionMatrix();\n            scope.dispatchEvent(changeEvent);\n            scope.update();\n            state = STATE.NONE;\n        };\n        this.update = (()=>{\n            const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            const up = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n            const quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion().setFromUnitVectors(object.up, up);\n            const quatInverse = quat.clone().invert();\n            const lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            const lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n            const twoPI = 2 * Math.PI;\n            return function update() {\n                const position = scope.object.position;\n                quat.setFromUnitVectors(object.up, up);\n                quatInverse.copy(quat).invert();\n                offset.copy(position).sub(scope.target);\n                offset.applyQuaternion(quat);\n                spherical.setFromVector3(offset);\n                if (scope.autoRotate && state === STATE.NONE) {\n                    rotateLeft(getAutoRotationAngle());\n                }\n                if (scope.enableDamping) {\n                    spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n                    spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n                } else {\n                    spherical.theta += sphericalDelta.theta;\n                    spherical.phi += sphericalDelta.phi;\n                }\n                let min = scope.minAzimuthAngle;\n                let max = scope.maxAzimuthAngle;\n                if (isFinite(min) && isFinite(max)) {\n                    if (min < -Math.PI) min += twoPI;\n                    else if (min > Math.PI) min -= twoPI;\n                    if (max < -Math.PI) max += twoPI;\n                    else if (max > Math.PI) max -= twoPI;\n                    if (min <= max) {\n                        spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n                    } else {\n                        spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);\n                    }\n                }\n                spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n                spherical.makeSafe();\n                if (scope.enableDamping === true) {\n                    scope.target.addScaledVector(panOffset, scope.dampingFactor);\n                } else {\n                    scope.target.add(panOffset);\n                }\n                if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) {\n                    spherical.radius = clampDistance(spherical.radius);\n                } else {\n                    spherical.radius = clampDistance(spherical.radius * scale);\n                }\n                offset.setFromSpherical(spherical);\n                offset.applyQuaternion(quatInverse);\n                position.copy(scope.target).add(offset);\n                if (!scope.object.matrixAutoUpdate) scope.object.updateMatrix();\n                scope.object.lookAt(scope.target);\n                if (scope.enableDamping === true) {\n                    sphericalDelta.theta *= 1 - scope.dampingFactor;\n                    sphericalDelta.phi *= 1 - scope.dampingFactor;\n                    panOffset.multiplyScalar(1 - scope.dampingFactor);\n                } else {\n                    sphericalDelta.set(0, 0, 0);\n                    panOffset.set(0, 0, 0);\n                }\n                let zoomChanged = false;\n                if (scope.zoomToCursor && performCursorZoom) {\n                    let newRadius = null;\n                    if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera) {\n                        const prevRadius = offset.length();\n                        newRadius = clampDistance(prevRadius * scale);\n                        const radiusDelta = prevRadius - newRadius;\n                        scope.object.position.addScaledVector(dollyDirection, radiusDelta);\n                        scope.object.updateMatrixWorld();\n                    } else if (scope.object.isOrthographicCamera) {\n                        const mouseBefore = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(mouse.x, mouse.y, 0);\n                        mouseBefore.unproject(scope.object);\n                        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n                        scope.object.updateProjectionMatrix();\n                        zoomChanged = true;\n                        const mouseAfter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(mouse.x, mouse.y, 0);\n                        mouseAfter.unproject(scope.object);\n                        scope.object.position.sub(mouseAfter).add(mouseBefore);\n                        scope.object.updateMatrixWorld();\n                        newRadius = offset.length();\n                    } else {\n                        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.\");\n                        scope.zoomToCursor = false;\n                    }\n                    if (newRadius !== null) {\n                        if (scope.screenSpacePanning) {\n                            scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);\n                        } else {\n                            _ray.origin.copy(scope.object.position);\n                            _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix);\n                            if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                                object.lookAt(scope.target);\n                            } else {\n                                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);\n                                _ray.intersectPlane(_plane, scope.target);\n                            }\n                        }\n                    }\n                } else if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n                    zoomChanged = scale !== 1;\n                    if (zoomChanged) {\n                        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n                        scope.object.updateProjectionMatrix();\n                    }\n                }\n                scale = 1;\n                performCursorZoom = false;\n                if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n                    scope.dispatchEvent(changeEvent);\n                    lastPosition.copy(scope.object.position);\n                    lastQuaternion.copy(scope.object.quaternion);\n                    zoomChanged = false;\n                    return true;\n                }\n                return false;\n            };\n        })();\n        this.connect = (domElement2)=>{\n            scope.domElement = domElement2;\n            scope.domElement.style.touchAction = \"none\";\n            scope.domElement.addEventListener(\"contextmenu\", onContextMenu);\n            scope.domElement.addEventListener(\"pointerdown\", onPointerDown);\n            scope.domElement.addEventListener(\"pointercancel\", onPointerUp);\n            scope.domElement.addEventListener(\"wheel\", onMouseWheel);\n        };\n        this.dispose = ()=>{\n            var _a, _b, _c, _d, _e, _f;\n            if (scope.domElement) {\n                scope.domElement.style.touchAction = \"auto\";\n            }\n            (_a = scope.domElement) == null ? void 0 : _a.removeEventListener(\"contextmenu\", onContextMenu);\n            (_b = scope.domElement) == null ? void 0 : _b.removeEventListener(\"pointerdown\", onPointerDown);\n            (_c = scope.domElement) == null ? void 0 : _c.removeEventListener(\"pointercancel\", onPointerUp);\n            (_d = scope.domElement) == null ? void 0 : _d.removeEventListener(\"wheel\", onMouseWheel);\n            (_e = scope.domElement) == null ? void 0 : _e.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n            (_f = scope.domElement) == null ? void 0 : _f.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n            if (scope._domElementKeyEvents !== null) {\n                scope._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n            }\n        };\n        const scope = this;\n        const changeEvent = {\n            type: \"change\"\n        };\n        const startEvent = {\n            type: \"start\"\n        };\n        const endEvent = {\n            type: \"end\"\n        };\n        const STATE = {\n            NONE: -1,\n            ROTATE: 0,\n            DOLLY: 1,\n            PAN: 2,\n            TOUCH_ROTATE: 3,\n            TOUCH_PAN: 4,\n            TOUCH_DOLLY_PAN: 5,\n            TOUCH_DOLLY_ROTATE: 6\n        };\n        let state = STATE.NONE;\n        const EPS = 1e-6;\n        const spherical = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n        const sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n        let scale = 1;\n        const panOffset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const panStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const panEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const panDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const dollyDirection = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const mouse = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        let performCursorZoom = false;\n        const pointers = [];\n        const pointerPositions = {};\n        function getAutoRotationAngle() {\n            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n        }\n        function getZoomScale() {\n            return Math.pow(0.95, scope.zoomSpeed);\n        }\n        function rotateLeft(angle) {\n            if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n                sphericalDelta.theta += angle;\n            } else {\n                sphericalDelta.theta -= angle;\n            }\n        }\n        function rotateUp(angle) {\n            if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n                sphericalDelta.phi += angle;\n            } else {\n                sphericalDelta.phi -= angle;\n            }\n        }\n        const panLeft = (()=>{\n            const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            return function panLeft2(distance, objectMatrix) {\n                v.setFromMatrixColumn(objectMatrix, 0);\n                v.multiplyScalar(-distance);\n                panOffset.add(v);\n            };\n        })();\n        const panUp = (()=>{\n            const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            return function panUp2(distance, objectMatrix) {\n                if (scope.screenSpacePanning === true) {\n                    v.setFromMatrixColumn(objectMatrix, 1);\n                } else {\n                    v.setFromMatrixColumn(objectMatrix, 0);\n                    v.crossVectors(scope.object.up, v);\n                }\n                v.multiplyScalar(distance);\n                panOffset.add(v);\n            };\n        })();\n        const pan = (()=>{\n            const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            return function pan2(deltaX, deltaY) {\n                const element = scope.domElement;\n                if (element && scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera) {\n                    const position = scope.object.position;\n                    offset.copy(position).sub(scope.target);\n                    let targetDistance = offset.length();\n                    targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);\n                    panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n                    panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n                } else if (element && scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n                    panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\n                    panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\n                } else {\n                    console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n                    scope.enablePan = false;\n                }\n            };\n        })();\n        function setScale(newScale) {\n            if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera || scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n                scale = newScale;\n            } else {\n                console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n                scope.enableZoom = false;\n            }\n        }\n        function dollyOut(dollyScale) {\n            setScale(scale / dollyScale);\n        }\n        function dollyIn(dollyScale) {\n            setScale(scale * dollyScale);\n        }\n        function updateMouseParameters(event) {\n            if (!scope.zoomToCursor || !scope.domElement) {\n                return;\n            }\n            performCursorZoom = true;\n            const rect = scope.domElement.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            const w = rect.width;\n            const h = rect.height;\n            mouse.x = x / w * 2 - 1;\n            mouse.y = -(y / h) * 2 + 1;\n            dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();\n        }\n        function clampDistance(dist) {\n            return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));\n        }\n        function handleMouseDownRotate(event) {\n            rotateStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseDownDolly(event) {\n            updateMouseParameters(event);\n            dollyStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseDownPan(event) {\n            panStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseMoveRotate(event) {\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n            const element = scope.domElement;\n            if (element) {\n                rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n                rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n            }\n            rotateStart.copy(rotateEnd);\n            scope.update();\n        }\n        function handleMouseMoveDolly(event) {\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n            if (dollyDelta.y > 0) {\n                dollyOut(getZoomScale());\n            } else if (dollyDelta.y < 0) {\n                dollyIn(getZoomScale());\n            }\n            dollyStart.copy(dollyEnd);\n            scope.update();\n        }\n        function handleMouseMovePan(event) {\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n            pan(panDelta.x, panDelta.y);\n            panStart.copy(panEnd);\n            scope.update();\n        }\n        function handleMouseWheel(event) {\n            updateMouseParameters(event);\n            if (event.deltaY < 0) {\n                dollyIn(getZoomScale());\n            } else if (event.deltaY > 0) {\n                dollyOut(getZoomScale());\n            }\n            scope.update();\n        }\n        function handleKeyDown(event) {\n            let needsUpdate = false;\n            switch(event.code){\n                case scope.keys.UP:\n                    pan(0, scope.keyPanSpeed);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.BOTTOM:\n                    pan(0, -scope.keyPanSpeed);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.LEFT:\n                    pan(scope.keyPanSpeed, 0);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.RIGHT:\n                    pan(-scope.keyPanSpeed, 0);\n                    needsUpdate = true;\n                    break;\n            }\n            if (needsUpdate) {\n                event.preventDefault();\n                scope.update();\n            }\n        }\n        function handleTouchStartRotate() {\n            if (pointers.length == 1) {\n                rotateStart.set(pointers[0].pageX, pointers[0].pageY);\n            } else {\n                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n                rotateStart.set(x, y);\n            }\n        }\n        function handleTouchStartPan() {\n            if (pointers.length == 1) {\n                panStart.set(pointers[0].pageX, pointers[0].pageY);\n            } else {\n                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n                panStart.set(x, y);\n            }\n        }\n        function handleTouchStartDolly() {\n            const dx = pointers[0].pageX - pointers[1].pageX;\n            const dy = pointers[0].pageY - pointers[1].pageY;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            dollyStart.set(0, distance);\n        }\n        function handleTouchStartDollyPan() {\n            if (scope.enableZoom) handleTouchStartDolly();\n            if (scope.enablePan) handleTouchStartPan();\n        }\n        function handleTouchStartDollyRotate() {\n            if (scope.enableZoom) handleTouchStartDolly();\n            if (scope.enableRotate) handleTouchStartRotate();\n        }\n        function handleTouchMoveRotate(event) {\n            if (pointers.length == 1) {\n                rotateEnd.set(event.pageX, event.pageY);\n            } else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                rotateEnd.set(x, y);\n            }\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n            const element = scope.domElement;\n            if (element) {\n                rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n                rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n            }\n            rotateStart.copy(rotateEnd);\n        }\n        function handleTouchMovePan(event) {\n            if (pointers.length == 1) {\n                panEnd.set(event.pageX, event.pageY);\n            } else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                panEnd.set(x, y);\n            }\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n            pan(panDelta.x, panDelta.y);\n            panStart.copy(panEnd);\n        }\n        function handleTouchMoveDolly(event) {\n            const position = getSecondPointerPosition(event);\n            const dx = event.pageX - position.x;\n            const dy = event.pageY - position.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            dollyEnd.set(0, distance);\n            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n            dollyOut(dollyDelta.y);\n            dollyStart.copy(dollyEnd);\n        }\n        function handleTouchMoveDollyPan(event) {\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n            if (scope.enablePan) handleTouchMovePan(event);\n        }\n        function handleTouchMoveDollyRotate(event) {\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n            if (scope.enableRotate) handleTouchMoveRotate(event);\n        }\n        function onPointerDown(event) {\n            var _a, _b;\n            if (scope.enabled === false) return;\n            if (pointers.length === 0) {\n                (_a = scope.domElement) == null ? void 0 : _a.ownerDocument.addEventListener(\"pointermove\", onPointerMove);\n                (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.addEventListener(\"pointerup\", onPointerUp);\n            }\n            addPointer(event);\n            if (event.pointerType === \"touch\") {\n                onTouchStart(event);\n            } else {\n                onMouseDown(event);\n            }\n        }\n        function onPointerMove(event) {\n            if (scope.enabled === false) return;\n            if (event.pointerType === \"touch\") {\n                onTouchMove(event);\n            } else {\n                onMouseMove(event);\n            }\n        }\n        function onPointerUp(event) {\n            var _a, _b, _c;\n            removePointer(event);\n            if (pointers.length === 0) {\n                (_a = scope.domElement) == null ? void 0 : _a.releasePointerCapture(event.pointerId);\n                (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n                (_c = scope.domElement) == null ? void 0 : _c.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n            }\n            scope.dispatchEvent(endEvent);\n            state = STATE.NONE;\n        }\n        function onMouseDown(event) {\n            let mouseAction;\n            switch(event.button){\n                case 0:\n                    mouseAction = scope.mouseButtons.LEFT;\n                    break;\n                case 1:\n                    mouseAction = scope.mouseButtons.MIDDLE;\n                    break;\n                case 2:\n                    mouseAction = scope.mouseButtons.RIGHT;\n                    break;\n                default:\n                    mouseAction = -1;\n            }\n            switch(mouseAction){\n                case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY:\n                    if (scope.enableZoom === false) return;\n                    handleMouseDownDolly(event);\n                    state = STATE.DOLLY;\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        if (scope.enablePan === false) return;\n                        handleMouseDownPan(event);\n                        state = STATE.PAN;\n                    } else {\n                        if (scope.enableRotate === false) return;\n                        handleMouseDownRotate(event);\n                        state = STATE.ROTATE;\n                    }\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        if (scope.enableRotate === false) return;\n                        handleMouseDownRotate(event);\n                        state = STATE.ROTATE;\n                    } else {\n                        if (scope.enablePan === false) return;\n                        handleMouseDownPan(event);\n                        state = STATE.PAN;\n                    }\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n            if (state !== STATE.NONE) {\n                scope.dispatchEvent(startEvent);\n            }\n        }\n        function onMouseMove(event) {\n            if (scope.enabled === false) return;\n            switch(state){\n                case STATE.ROTATE:\n                    if (scope.enableRotate === false) return;\n                    handleMouseMoveRotate(event);\n                    break;\n                case STATE.DOLLY:\n                    if (scope.enableZoom === false) return;\n                    handleMouseMoveDolly(event);\n                    break;\n                case STATE.PAN:\n                    if (scope.enablePan === false) return;\n                    handleMouseMovePan(event);\n                    break;\n            }\n        }\n        function onMouseWheel(event) {\n            if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) {\n                return;\n            }\n            event.preventDefault();\n            scope.dispatchEvent(startEvent);\n            handleMouseWheel(event);\n            scope.dispatchEvent(endEvent);\n        }\n        function onKeyDown(event) {\n            if (scope.enabled === false || scope.enablePan === false) return;\n            handleKeyDown(event);\n        }\n        function onTouchStart(event) {\n            trackPointer(event);\n            switch(pointers.length){\n                case 1:\n                    switch(scope.touches.ONE){\n                        case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE:\n                            if (scope.enableRotate === false) return;\n                            handleTouchStartRotate();\n                            state = STATE.TOUCH_ROTATE;\n                            break;\n                        case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN:\n                            if (scope.enablePan === false) return;\n                            handleTouchStartPan();\n                            state = STATE.TOUCH_PAN;\n                            break;\n                        default:\n                            state = STATE.NONE;\n                    }\n                    break;\n                case 2:\n                    switch(scope.touches.TWO){\n                        case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN:\n                            if (scope.enableZoom === false && scope.enablePan === false) return;\n                            handleTouchStartDollyPan();\n                            state = STATE.TOUCH_DOLLY_PAN;\n                            break;\n                        case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE:\n                            if (scope.enableZoom === false && scope.enableRotate === false) return;\n                            handleTouchStartDollyRotate();\n                            state = STATE.TOUCH_DOLLY_ROTATE;\n                            break;\n                        default:\n                            state = STATE.NONE;\n                    }\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n            if (state !== STATE.NONE) {\n                scope.dispatchEvent(startEvent);\n            }\n        }\n        function onTouchMove(event) {\n            trackPointer(event);\n            switch(state){\n                case STATE.TOUCH_ROTATE:\n                    if (scope.enableRotate === false) return;\n                    handleTouchMoveRotate(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_PAN:\n                    if (scope.enablePan === false) return;\n                    handleTouchMovePan(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_DOLLY_PAN:\n                    if (scope.enableZoom === false && scope.enablePan === false) return;\n                    handleTouchMoveDollyPan(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_DOLLY_ROTATE:\n                    if (scope.enableZoom === false && scope.enableRotate === false) return;\n                    handleTouchMoveDollyRotate(event);\n                    scope.update();\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n        }\n        function onContextMenu(event) {\n            if (scope.enabled === false) return;\n            event.preventDefault();\n        }\n        function addPointer(event) {\n            pointers.push(event);\n        }\n        function removePointer(event) {\n            delete pointerPositions[event.pointerId];\n            for(let i = 0; i < pointers.length; i++){\n                if (pointers[i].pointerId == event.pointerId) {\n                    pointers.splice(i, 1);\n                    return;\n                }\n            }\n        }\n        function trackPointer(event) {\n            let position = pointerPositions[event.pointerId];\n            if (position === void 0) {\n                position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n                pointerPositions[event.pointerId] = position;\n            }\n            position.set(event.pageX, event.pageY);\n        }\n        function getSecondPointerPosition(event) {\n            const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];\n            return pointerPositions[pointer.pointerId];\n        }\n        this.dollyIn = (dollyScale = getZoomScale())=>{\n            dollyIn(dollyScale);\n            scope.update();\n        };\n        this.dollyOut = (dollyScale = getZoomScale())=>{\n            dollyOut(dollyScale);\n            scope.update();\n        };\n        this.getScale = ()=>{\n            return scale;\n        };\n        this.setScale = (newScale)=>{\n            setScale(newScale);\n            scope.update();\n        };\n        this.getZoomScale = ()=>{\n            return getZoomScale();\n        };\n        if (domElement !== void 0) this.connect(domElement);\n        this.update();\n    }\n}\nclass MapControls extends OrbitControls {\n    constructor(object, domElement){\n        super(object, domElement);\n        this.screenSpacePanning = false;\n        this.mouseButtons.LEFT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN;\n        this.mouseButtons.RIGHT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE;\n        this.touches.ONE = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN;\n        this.touches.TWO = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE;\n    }\n}\n //# sourceMappingURL=OrbitControls.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9jb250cm9scy9PcmJpdENvbnRyb2xzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLE1BQU1BLE9BQUEsb0JBQTJCQyxzQ0FBR0E7QUFDcEMsTUFBTUMsU0FBQSxvQkFBNkJDLHdDQUFLQTtBQUN4QyxNQUFNQyxhQUFhQyxLQUFLQyxHQUFBLENBQUksS0FBTUQsQ0FBQUEsS0FBS0UsRUFBQSxHQUFLO0FBUzVDLE1BQU1DLG1CQUFtQixDQUFDQyxRQUFnQkMsV0FBQSxDQUF1QkQsU0FBU0MsV0FBWUEsUUFBQSxJQUFZQTtBQUVsRyxNQUFNQyxzQkFBc0JDLGdFQUFlQTtJQTZGekNDLFlBQVlDLE1BQUEsRUFBZ0RDLFVBQUEsQ0FBMEI7UUFDOUU7UUE3RlJDLGNBQUE7UUFDQUEsY0FBQTtRQUVBO1FBQUFBLGNBQUEsaUJBQVU7UUFFVjtRQUFBQSxjQUFBLGdCQUFTLElBQUlDLDBDQUFPQTtRQUVwQjtRQUFBRCxjQUFBLHFCQUFjO1FBQ2RBLGNBQUEscUJBQWNFO1FBRWQ7UUFBQUYsY0FBQSxpQkFBVTtRQUNWQSxjQUFBLGlCQUFVRTtRQUdWO1FBQUE7UUFBQUYsY0FBQSx1QkFBZ0I7UUFDaEI7UUFBQUEsY0FBQSx1QkFBZ0JYLEtBQUtFLEVBQUE7UUFHckI7UUFBQTtRQUFBO1FBQUFTLGNBQUEseUJBQWtCLENBQUFFO1FBQ2xCO1FBQUFGLGNBQUEseUJBQWtCRTtRQUdsQjtRQUFBO1FBQUE7UUFBQUYsY0FBQSx1QkFBZ0I7UUFDaEJBLGNBQUEsdUJBQWdCO1FBR2hCO1FBQUE7UUFBQUEsY0FBQSxvQkFBYTtRQUNiQSxjQUFBLG1CQUFZO1FBRVo7UUFBQUEsY0FBQSxzQkFBZTtRQUNmQSxjQUFBLHFCQUFjO1FBRWQ7UUFBQUEsY0FBQSxtQkFBWTtRQUNaQSxjQUFBLGtCQUFXO1FBQ1hBLGNBQUEsNEJBQXFCO1FBQ3JCO1FB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YixTQUFTO1FBQzNDO1FBSUEsS0FBS3pELE9BQUEsR0FBVSxDQUFDRCxhQUFhakMsY0FBQTtZQUMzQmtDLFFBQVFEO1lBQ1JuSyxNQUFNQyxNQUFBO1FBQU87UUFHZixLQUFLaUssUUFBQSxHQUFXLENBQUNDLGFBQWFqQyxjQUFBO1lBQzVCZ0MsU0FBU0M7WUFDVG5LLE1BQU1DLE1BQUE7UUFBTztRQUdmLEtBQUswTyxRQUFBLEdBQVc7WUFDUCxPQUFBcEw7UUFBQTtRQUdKLEtBQUF3RyxRQUFBLEdBQVcsQ0FBQ0M7WUFDZkQsU0FBU0M7WUFDVGhLLE1BQU1DLE1BQUE7UUFBTztRQUdmLEtBQUtpSSxZQUFBLEdBQWU7WUFDbEIsT0FBT0E7UUFBYTtRQUl0QixJQUFJckssZUFBZSxRQUFXLEtBQUtnSSxPQUFBLENBQVFoSTtRQUUzQyxLQUFLb0MsTUFBQTtJQUNQO0FBQ0Y7QUFVQSxNQUFNMk8sb0JBQW9CblI7SUFDeEJFLFlBQVlDLE1BQUEsRUFBZ0RDLFVBQUEsQ0FBMEI7UUFDcEYsTUFBTUQsUUFBUUM7UUFFZCxLQUFLb0gsa0JBQUEsR0FBcUI7UUFFckIsS0FBQStJLFlBQUEsQ0FBYS9QLElBQUEsR0FBT0ksd0NBQUtBLENBQUNJLEdBQUE7UUFDMUIsS0FBQXVQLFlBQUEsQ0FBYTdQLEtBQUEsR0FBUUUsd0NBQUtBLENBQUNDLE1BQUE7UUFFM0IsS0FBQStQLE9BQUEsQ0FBUTNQLEdBQUEsR0FBTUMsd0NBQUtBLENBQUNGLEdBQUE7UUFDcEIsS0FBQTRQLE9BQUEsQ0FBUXpQLEdBQUEsR0FBTUQsd0NBQUtBLENBQUMyUCxZQUFBO0lBQzNCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yb2NrZXRzaW0vLi4vLi4vc3JjL2NvbnRyb2xzL09yYml0Q29udHJvbHMudHM/N2VhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBNYXRyaXg0LFxuICBNT1VTRSxcbiAgT3J0aG9ncmFwaGljQ2FtZXJhLFxuICBQZXJzcGVjdGl2ZUNhbWVyYSxcbiAgUXVhdGVybmlvbixcbiAgU3BoZXJpY2FsLFxuICBUT1VDSCxcbiAgVmVjdG9yMixcbiAgVmVjdG9yMyxcbiAgUmF5LFxuICBQbGFuZSxcbn0gZnJvbSAndGhyZWUnXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlcidcbmltcG9ydCB7IFN0YW5kYXJkQ29udHJvbHNFdmVudE1hcCB9IGZyb20gJy4vU3RhbmRhcmRDb250cm9sc0V2ZW50TWFwJ1xuXG5jb25zdCBfcmF5ID0gLyogQF9fUFVSRV9fICovIG5ldyBSYXkoKVxuY29uc3QgX3BsYW5lID0gLyogQF9fUFVSRV9fICovIG5ldyBQbGFuZSgpXG5jb25zdCBUSUxUX0xJTUlUID0gTWF0aC5jb3MoNzAgKiAoTWF0aC5QSSAvIDE4MCkpXG5cbi8vIFRoaXMgc2V0IG9mIGNvbnRyb2xzIHBlcmZvcm1zIG9yYml0aW5nLCBkb2xseWluZyAoem9vbWluZyksIGFuZCBwYW5uaW5nLlxuLy8gVW5saWtlIFRyYWNrYmFsbENvbnRyb2xzLCBpdCBtYWludGFpbnMgdGhlIFwidXBcIiBkaXJlY3Rpb24gb2JqZWN0LnVwICgrWSBieSBkZWZhdWx0KS5cbi8vXG4vLyAgICBPcmJpdCAtIGxlZnQgbW91c2UgLyB0b3VjaDogb25lLWZpbmdlciBtb3ZlXG4vLyAgICBab29tIC0gbWlkZGxlIG1vdXNlLCBvciBtb3VzZXdoZWVsIC8gdG91Y2g6IHR3by1maW5nZXIgc3ByZWFkIG9yIHNxdWlzaFxuLy8gICAgUGFuIC0gcmlnaHQgbW91c2UsIG9yIGxlZnQgbW91c2UgKyBjdHJsL21ldGEvc2hpZnRLZXksIG9yIGFycm93IGtleXMgLyB0b3VjaDogdHdvLWZpbmdlciBtb3ZlXG5cbmNvbnN0IG1vZHVsb1dyYXBBcm91bmQgPSAob2Zmc2V0OiBudW1iZXIsIGNhcGFjaXR5OiBudW1iZXIpID0+ICgob2Zmc2V0ICUgY2FwYWNpdHkpICsgY2FwYWNpdHkpICUgY2FwYWNpdHlcblxuY2xhc3MgT3JiaXRDb250cm9scyBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcjxTdGFuZGFyZENvbnRyb2xzRXZlbnRNYXA+IHtcbiAgb2JqZWN0OiBQZXJzcGVjdGl2ZUNhbWVyYSB8IE9ydGhvZ3JhcGhpY0NhbWVyYVxuICBkb21FbGVtZW50OiBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZFxuICAvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcbiAgZW5hYmxlZCA9IHRydWVcbiAgLy8gXCJ0YXJnZXRcIiBzZXRzIHRoZSBsb2NhdGlvbiBvZiBmb2N1cywgd2hlcmUgdGhlIG9iamVjdCBvcmJpdHMgYXJvdW5kXG4gIHRhcmdldCA9IG5ldyBWZWN0b3IzKClcbiAgLy8gSG93IGZhciB5b3UgY2FuIGRvbGx5IGluIGFuZCBvdXQgKCBQZXJzcGVjdGl2ZUNhbWVyYSBvbmx5IClcbiAgbWluRGlzdGFuY2UgPSAwXG4gIG1heERpc3RhbmNlID0gSW5maW5pdHlcbiAgLy8gSG93IGZhciB5b3UgY2FuIHpvb20gaW4gYW5kIG91dCAoIE9ydGhvZ3JhcGhpY0NhbWVyYSBvbmx5IClcbiAgbWluWm9vbSA9IDBcbiAgbWF4Wm9vbSA9IEluZmluaXR5XG4gIC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCB2ZXJ0aWNhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuICAvLyBSYW5nZSBpcyAwIHRvIE1hdGguUEkgcmFkaWFucy5cbiAgbWluUG9sYXJBbmdsZSA9IDAgLy8gcmFkaWFuc1xuICBtYXhQb2xhckFuZ2xlID0gTWF0aC5QSSAvLyByYWRpYW5zXG4gIC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCBob3Jpem9udGFsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG4gIC8vIElmIHNldCwgdGhlIGludGVydmFsIFsgbWluLCBtYXggXSBtdXN0IGJlIGEgc3ViLWludGVydmFsIG9mIFsgLSAyIFBJLCAyIFBJIF0sIHdpdGggKCBtYXggLSBtaW4gPCAyIFBJIClcbiAgbWluQXppbXV0aEFuZ2xlID0gLUluZmluaXR5IC8vIHJhZGlhbnNcbiAgbWF4QXppbXV0aEFuZ2xlID0gSW5maW5pdHkgLy8gcmFkaWFuc1xuICAvLyBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgZGFtcGluZyAoaW5lcnRpYSlcbiAgLy8gSWYgZGFtcGluZyBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3BcbiAgZW5hYmxlRGFtcGluZyA9IGZhbHNlXG4gIGRhbXBpbmdGYWN0b3IgPSAwLjA1XG4gIC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHpvb21pbmdcbiAgZW5hYmxlWm9vbSA9IHRydWVcbiAgem9vbVNwZWVkID0gMS4wXG4gIC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHJvdGF0aW5nXG4gIGVuYWJsZVJvdGF0ZSA9IHRydWVcbiAgcm90YXRlU3BlZWQgPSAxLjBcbiAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcGFubmluZ1xuICBlbmFibGVQYW4gPSB0cnVlXG4gIHBhblNwZWVkID0gMS4wXG4gIHNjcmVlblNwYWNlUGFubmluZyA9IHRydWUgLy8gaWYgZmFsc2UsIHBhbiBvcnRob2dvbmFsIHRvIHdvcmxkLXNwYWNlIGRpcmVjdGlvbiBjYW1lcmEudXBcbiAga2V5UGFuU3BlZWQgPSA3LjAgLy8gcGl4ZWxzIG1vdmVkIHBlciBhcnJvdyBrZXkgcHVzaFxuICB6b29tVG9DdXJzb3IgPSBmYWxzZVxuICAvLyBTZXQgdG8gdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IHJvdGF0ZSBhcm91bmQgdGhlIHRhcmdldFxuICAvLyBJZiBhdXRvLXJvdGF0ZSBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3BcbiAgYXV0b1JvdGF0ZSA9IGZhbHNlXG4gIGF1dG9Sb3RhdGVTcGVlZCA9IDIuMCAvLyAzMCBzZWNvbmRzIHBlciBvcmJpdCB3aGVuIGZwcyBpcyA2MFxuICByZXZlcnNlT3JiaXQgPSBmYWxzZSAvLyB0cnVlIGlmIHlvdSB3YW50IHRvIHJldmVyc2UgdGhlIG9yYml0IHRvIG1vdXNlIGRyYWcgZnJvbSBsZWZ0IHRvIHJpZ2h0ID0gb3JiaXRzIGxlZnRcbiAgcmV2ZXJzZUhvcml6b250YWxPcmJpdCA9IGZhbHNlIC8vIHRydWUgaWYgeW91IHdhbnQgdG8gcmV2ZXJzZSB0aGUgaG9yaXpvbnRhbCBvcmJpdCBkaXJlY3Rpb25cbiAgcmV2ZXJzZVZlcnRpY2FsT3JiaXQgPSBmYWxzZSAvLyB0cnVlIGlmIHlvdSB3YW50IHRvIHJldmVyc2UgdGhlIHZlcnRpY2FsIG9yYml0IGRpcmVjdGlvblxuICAvLyBUaGUgZm91ciBhcnJvdyBrZXlzXG4gIGtleXMgPSB7IExFRlQ6ICdBcnJvd0xlZnQnLCBVUDogJ0Fycm93VXAnLCBSSUdIVDogJ0Fycm93UmlnaHQnLCBCT1RUT006ICdBcnJvd0Rvd24nIH1cbiAgLy8gTW91c2UgYnV0dG9uc1xuICBtb3VzZUJ1dHRvbnM6IFBhcnRpYWw8e1xuICAgIExFRlQ6IE1PVVNFXG4gICAgTUlERExFOiBNT1VTRVxuICAgIFJJR0hUOiBNT1VTRVxuICB9PiA9IHtcbiAgICBMRUZUOiBNT1VTRS5ST1RBVEUsXG4gICAgTUlERExFOiBNT1VTRS5ET0xMWSxcbiAgICBSSUdIVDogTU9VU0UuUEFOLFxuICB9XG4gIC8vIFRvdWNoIGZpbmdlcnNcbiAgdG91Y2hlczogUGFydGlhbDx7XG4gICAgT05FOiBUT1VDSFxuICAgIFRXTzogVE9VQ0hcbiAgfT4gPSB7IE9ORTogVE9VQ0guUk9UQVRFLCBUV086IFRPVUNILkRPTExZX1BBTiB9XG4gIHRhcmdldDA6IFZlY3RvcjNcbiAgcG9zaXRpb24wOiBWZWN0b3IzXG4gIHpvb20wOiBudW1iZXJcbiAgLy8gdGhlIHRhcmdldCBET00gZWxlbWVudCBmb3Iga2V5IGV2ZW50c1xuICBfZG9tRWxlbWVudEtleUV2ZW50czogYW55ID0gbnVsbFxuXG4gIGdldFBvbGFyQW5nbGU6ICgpID0+IG51bWJlclxuICBnZXRBemltdXRoYWxBbmdsZTogKCkgPT4gbnVtYmVyXG4gIHNldFBvbGFyQW5nbGU6ICh4OiBudW1iZXIpID0+IHZvaWRcbiAgc2V0QXppbXV0aGFsQW5nbGU6ICh4OiBudW1iZXIpID0+IHZvaWRcbiAgZ2V0RGlzdGFuY2U6ICgpID0+IG51bWJlclxuICAvLyBOb3QgdXNlZCBpbiBtb3N0IHNjZW5hcmlvcywgaG93ZXZlciB0aGV5IGNhbiBiZSB1c2VmdWwgZm9yIHNwZWNpZmljIHVzZSBjYXNlc1xuICBnZXRab29tU2NhbGU6ICgpID0+IG51bWJlclxuXG4gIGxpc3RlblRvS2V5RXZlbnRzOiAoZG9tRWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHZvaWRcbiAgc3RvcExpc3RlblRvS2V5RXZlbnRzOiAoKSA9PiB2b2lkXG4gIHNhdmVTdGF0ZTogKCkgPT4gdm9pZFxuICByZXNldDogKCkgPT4gdm9pZFxuICB1cGRhdGU6ICgpID0+IHZvaWRcbiAgY29ubmVjdDogKGRvbUVsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB2b2lkXG4gIGRpc3Bvc2U6ICgpID0+IHZvaWRcblxuICAvLyBEb2xseSBpbiBwcm9ncmFtbWF0aWNhbGx5XG4gIGRvbGx5SW46IChkb2xseVNjYWxlPzogbnVtYmVyKSA9PiB2b2lkXG4gIC8vIERvbGx5IG91dCBwcm9ncmFtbWF0aWNhbGx5XG4gIGRvbGx5T3V0OiAoZG9sbHlTY2FsZT86IG51bWJlcikgPT4gdm9pZFxuICAvLyBHZXQgdGhlIGN1cnJlbnQgc2NhbGVcbiAgZ2V0U2NhbGU6ICgpID0+IG51bWJlclxuICAvLyBTZXQgdGhlIGN1cnJlbnQgc2NhbGUgKHRoZXNlIGFyZSBub3QgdXNlZCBpbiBtb3N0IHNjZW5hcmlvcywgaG93ZXZlciB0aGV5IGNhbiBiZSB1c2VmdWwgZm9yIHNwZWNpZmljIHVzZSBjYXNlcylcbiAgc2V0U2NhbGU6IChuZXdTY2FsZTogbnVtYmVyKSA9PiB2b2lkXG5cbiAgY29uc3RydWN0b3Iob2JqZWN0OiBQZXJzcGVjdGl2ZUNhbWVyYSB8IE9ydGhvZ3JhcGhpY0NhbWVyYSwgZG9tRWxlbWVudD86IEhUTUxFbGVtZW50KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3RcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb21FbGVtZW50XG5cbiAgICAvLyBmb3IgcmVzZXRcbiAgICB0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpXG4gICAgdGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpXG4gICAgdGhpcy56b29tMCA9IHRoaXMub2JqZWN0Lnpvb21cblxuICAgIC8vXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICAvL1xuXG4gICAgdGhpcy5nZXRQb2xhckFuZ2xlID0gKCk6IG51bWJlciA9PiBzcGhlcmljYWwucGhpXG5cbiAgICB0aGlzLmdldEF6aW11dGhhbEFuZ2xlID0gKCk6IG51bWJlciA9PiBzcGhlcmljYWwudGhldGFcblxuICAgIHRoaXMuc2V0UG9sYXJBbmdsZSA9ICh2YWx1ZTogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAvLyB1c2UgbW9kdWxvIHdyYXBwaW5nIHRvIHNhZmVndWFyZCB2YWx1ZVxuICAgICAgbGV0IHBoaSA9IG1vZHVsb1dyYXBBcm91bmQodmFsdWUsIDIgKiBNYXRoLlBJKVxuICAgICAgbGV0IGN1cnJlbnRQaGkgPSBzcGhlcmljYWwucGhpXG5cbiAgICAgIC8vIGNvbnZlcnQgdG8gdGhlIGVxdWl2YWxlbnQgc2hvcnRlc3QgYW5nbGVcbiAgICAgIGlmIChjdXJyZW50UGhpIDwgMCkgY3VycmVudFBoaSArPSAyICogTWF0aC5QSVxuICAgICAgaWYgKHBoaSA8IDApIHBoaSArPSAyICogTWF0aC5QSVxuICAgICAgbGV0IHBoaURpc3QgPSBNYXRoLmFicyhwaGkgLSBjdXJyZW50UGhpKVxuICAgICAgaWYgKDIgKiBNYXRoLlBJIC0gcGhpRGlzdCA8IHBoaURpc3QpIHtcbiAgICAgICAgaWYgKHBoaSA8IGN1cnJlbnRQaGkpIHtcbiAgICAgICAgICBwaGkgKz0gMiAqIE1hdGguUElcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UGhpICs9IDIgKiBNYXRoLlBJXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNwaGVyaWNhbERlbHRhLnBoaSA9IHBoaSAtIGN1cnJlbnRQaGlcbiAgICAgIHNjb3BlLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgdGhpcy5zZXRBemltdXRoYWxBbmdsZSA9ICh2YWx1ZTogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAvLyB1c2UgbW9kdWxvIHdyYXBwaW5nIHRvIHNhZmVndWFyZCB2YWx1ZVxuICAgICAgbGV0IHRoZXRhID0gbW9kdWxvV3JhcEFyb3VuZCh2YWx1ZSwgMiAqIE1hdGguUEkpXG4gICAgICBsZXQgY3VycmVudFRoZXRhID0gc3BoZXJpY2FsLnRoZXRhXG5cbiAgICAgIC8vIGNvbnZlcnQgdG8gdGhlIGVxdWl2YWxlbnQgc2hvcnRlc3QgYW5nbGVcbiAgICAgIGlmIChjdXJyZW50VGhldGEgPCAwKSBjdXJyZW50VGhldGEgKz0gMiAqIE1hdGguUElcbiAgICAgIGlmICh0aGV0YSA8IDApIHRoZXRhICs9IDIgKiBNYXRoLlBJXG4gICAgICBsZXQgdGhldGFEaXN0ID0gTWF0aC5hYnModGhldGEgLSBjdXJyZW50VGhldGEpXG4gICAgICBpZiAoMiAqIE1hdGguUEkgLSB0aGV0YURpc3QgPCB0aGV0YURpc3QpIHtcbiAgICAgICAgaWYgKHRoZXRhIDwgY3VycmVudFRoZXRhKSB7XG4gICAgICAgICAgdGhldGEgKz0gMiAqIE1hdGguUElcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50VGhldGEgKz0gMiAqIE1hdGguUElcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3BoZXJpY2FsRGVsdGEudGhldGEgPSB0aGV0YSAtIGN1cnJlbnRUaGV0YVxuICAgICAgc2NvcGUudXBkYXRlKClcbiAgICB9XG5cbiAgICB0aGlzLmdldERpc3RhbmNlID0gKCk6IG51bWJlciA9PiBzY29wZS5vYmplY3QucG9zaXRpb24uZGlzdGFuY2VUbyhzY29wZS50YXJnZXQpXG5cbiAgICB0aGlzLmxpc3RlblRvS2V5RXZlbnRzID0gKGRvbUVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCA9PiB7XG4gICAgICBkb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24pXG4gICAgICB0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzID0gZG9tRWxlbWVudFxuICAgIH1cblxuICAgIHRoaXMuc3RvcExpc3RlblRvS2V5RXZlbnRzID0gKCk6IHZvaWQgPT4ge1xuICAgICAgdGhpcy5fZG9tRWxlbWVudEtleUV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duKVxuICAgICAgdGhpcy5fZG9tRWxlbWVudEtleUV2ZW50cyA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLnNhdmVTdGF0ZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgIHNjb3BlLnRhcmdldDAuY29weShzY29wZS50YXJnZXQpXG4gICAgICBzY29wZS5wb3NpdGlvbjAuY29weShzY29wZS5vYmplY3QucG9zaXRpb24pXG4gICAgICBzY29wZS56b29tMCA9IHNjb3BlLm9iamVjdC56b29tXG4gICAgfVxuXG4gICAgdGhpcy5yZXNldCA9ICgpOiB2b2lkID0+IHtcbiAgICAgIHNjb3BlLnRhcmdldC5jb3B5KHNjb3BlLnRhcmdldDApXG4gICAgICBzY29wZS5vYmplY3QucG9zaXRpb24uY29weShzY29wZS5wb3NpdGlvbjApXG4gICAgICBzY29wZS5vYmplY3Quem9vbSA9IHNjb3BlLnpvb20wXG4gICAgICBzY29wZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpXG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpXG5cbiAgICAgIHNjb3BlLnVwZGF0ZSgpXG5cbiAgICAgIHN0YXRlID0gU1RBVEUuTk9ORVxuICAgIH1cblxuICAgIC8vIHRoaXMgbWV0aG9kIGlzIGV4cG9zZWQsIGJ1dCBwZXJoYXBzIGl0IHdvdWxkIGJlIGJldHRlciBpZiB3ZSBjYW4gbWFrZSBpdCBwcml2YXRlLi4uXG4gICAgdGhpcy51cGRhdGUgPSAoKCk6ICgoKSA9PiB2b2lkKSA9PiB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBuZXcgVmVjdG9yMygpXG4gICAgICBjb25zdCB1cCA9IG5ldyBWZWN0b3IzKDAsIDEsIDApXG5cbiAgICAgIC8vIHNvIGNhbWVyYS51cCBpcyB0aGUgb3JiaXQgYXhpc1xuICAgICAgY29uc3QgcXVhdCA9IG5ldyBRdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKG9iamVjdC51cCwgdXApXG4gICAgICBjb25zdCBxdWF0SW52ZXJzZSA9IHF1YXQuY2xvbmUoKS5pbnZlcnQoKVxuXG4gICAgICBjb25zdCBsYXN0UG9zaXRpb24gPSBuZXcgVmVjdG9yMygpXG4gICAgICBjb25zdCBsYXN0UXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKClcblxuICAgICAgY29uc3QgdHdvUEkgPSAyICogTWF0aC5QSVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHNjb3BlLm9iamVjdC5wb3NpdGlvblxuXG4gICAgICAgIC8vIHVwZGF0ZSBuZXcgdXAgZGlyZWN0aW9uXG4gICAgICAgIHF1YXQuc2V0RnJvbVVuaXRWZWN0b3JzKG9iamVjdC51cCwgdXApXG4gICAgICAgIHF1YXRJbnZlcnNlLmNvcHkocXVhdCkuaW52ZXJ0KClcblxuICAgICAgICBvZmZzZXQuY29weShwb3NpdGlvbikuc3ViKHNjb3BlLnRhcmdldClcblxuICAgICAgICAvLyByb3RhdGUgb2Zmc2V0IHRvIFwieS1heGlzLWlzLXVwXCIgc3BhY2VcbiAgICAgICAgb2Zmc2V0LmFwcGx5UXVhdGVybmlvbihxdWF0KVxuXG4gICAgICAgIC8vIGFuZ2xlIGZyb20gei1heGlzIGFyb3VuZCB5LWF4aXNcbiAgICAgICAgc3BoZXJpY2FsLnNldEZyb21WZWN0b3IzKG9mZnNldClcblxuICAgICAgICBpZiAoc2NvcGUuYXV0b1JvdGF0ZSAmJiBzdGF0ZSA9PT0gU1RBVEUuTk9ORSkge1xuICAgICAgICAgIHJvdGF0ZUxlZnQoZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY29wZS5lbmFibGVEYW1waW5nKSB7XG4gICAgICAgICAgc3BoZXJpY2FsLnRoZXRhICs9IHNwaGVyaWNhbERlbHRhLnRoZXRhICogc2NvcGUuZGFtcGluZ0ZhY3RvclxuICAgICAgICAgIHNwaGVyaWNhbC5waGkgKz0gc3BoZXJpY2FsRGVsdGEucGhpICogc2NvcGUuZGFtcGluZ0ZhY3RvclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwaGVyaWNhbC50aGV0YSArPSBzcGhlcmljYWxEZWx0YS50aGV0YVxuICAgICAgICAgIHNwaGVyaWNhbC5waGkgKz0gc3BoZXJpY2FsRGVsdGEucGhpXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0cmljdCB0aGV0YSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG5cbiAgICAgICAgbGV0IG1pbiA9IHNjb3BlLm1pbkF6aW11dGhBbmdsZVxuICAgICAgICBsZXQgbWF4ID0gc2NvcGUubWF4QXppbXV0aEFuZ2xlXG5cbiAgICAgICAgaWYgKGlzRmluaXRlKG1pbikgJiYgaXNGaW5pdGUobWF4KSkge1xuICAgICAgICAgIGlmIChtaW4gPCAtTWF0aC5QSSkgbWluICs9IHR3b1BJXG4gICAgICAgICAgZWxzZSBpZiAobWluID4gTWF0aC5QSSkgbWluIC09IHR3b1BJXG5cbiAgICAgICAgICBpZiAobWF4IDwgLU1hdGguUEkpIG1heCArPSB0d29QSVxuICAgICAgICAgIGVsc2UgaWYgKG1heCA+IE1hdGguUEkpIG1heCAtPSB0d29QSVxuXG4gICAgICAgICAgaWYgKG1pbiA8PSBtYXgpIHtcbiAgICAgICAgICAgIHNwaGVyaWNhbC50aGV0YSA9IE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCBzcGhlcmljYWwudGhldGEpKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGhlcmljYWwudGhldGEgPVxuICAgICAgICAgICAgICBzcGhlcmljYWwudGhldGEgPiAobWluICsgbWF4KSAvIDIgPyBNYXRoLm1heChtaW4sIHNwaGVyaWNhbC50aGV0YSkgOiBNYXRoLm1pbihtYXgsIHNwaGVyaWNhbC50aGV0YSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXN0cmljdCBwaGkgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuICAgICAgICBzcGhlcmljYWwucGhpID0gTWF0aC5tYXgoc2NvcGUubWluUG9sYXJBbmdsZSwgTWF0aC5taW4oc2NvcGUubWF4UG9sYXJBbmdsZSwgc3BoZXJpY2FsLnBoaSkpXG4gICAgICAgIHNwaGVyaWNhbC5tYWtlU2FmZSgpXG5cbiAgICAgICAgLy8gbW92ZSB0YXJnZXQgdG8gcGFubmVkIGxvY2F0aW9uXG5cbiAgICAgICAgaWYgKHNjb3BlLmVuYWJsZURhbXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICBzY29wZS50YXJnZXQuYWRkU2NhbGVkVmVjdG9yKHBhbk9mZnNldCwgc2NvcGUuZGFtcGluZ0ZhY3RvcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY29wZS50YXJnZXQuYWRkKHBhbk9mZnNldClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCB0aGUgY2FtZXJhIHBvc2l0aW9uIGJhc2VkIG9uIHpvb20gb25seSBpZiB3ZSdyZSBub3Qgem9vbWluZyB0byB0aGUgY3Vyc29yIG9yIGlmIGl0J3MgYW4gb3J0aG8gY2FtZXJhXG4gICAgICAgIC8vIHdlIGFkanVzdCB6b29tIGxhdGVyIGluIHRoZXNlIGNhc2VzXG4gICAgICAgIGlmICgoc2NvcGUuem9vbVRvQ3Vyc29yICYmIHBlcmZvcm1DdXJzb3Jab29tKSB8fCAoc2NvcGUub2JqZWN0IGFzIE9ydGhvZ3JhcGhpY0NhbWVyYSkuaXNPcnRob2dyYXBoaWNDYW1lcmEpIHtcbiAgICAgICAgICBzcGhlcmljYWwucmFkaXVzID0gY2xhbXBEaXN0YW5jZShzcGhlcmljYWwucmFkaXVzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwaGVyaWNhbC5yYWRpdXMgPSBjbGFtcERpc3RhbmNlKHNwaGVyaWNhbC5yYWRpdXMgKiBzY2FsZSlcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldC5zZXRGcm9tU3BoZXJpY2FsKHNwaGVyaWNhbClcblxuICAgICAgICAvLyByb3RhdGUgb2Zmc2V0IGJhY2sgdG8gXCJjYW1lcmEtdXAtdmVjdG9yLWlzLXVwXCIgc3BhY2VcbiAgICAgICAgb2Zmc2V0LmFwcGx5UXVhdGVybmlvbihxdWF0SW52ZXJzZSlcblxuICAgICAgICBwb3NpdGlvbi5jb3B5KHNjb3BlLnRhcmdldCkuYWRkKG9mZnNldClcblxuICAgICAgICBpZiAoIXNjb3BlLm9iamVjdC5tYXRyaXhBdXRvVXBkYXRlKSBzY29wZS5vYmplY3QudXBkYXRlTWF0cml4KClcbiAgICAgICAgc2NvcGUub2JqZWN0Lmxvb2tBdChzY29wZS50YXJnZXQpXG5cbiAgICAgICAgaWYgKHNjb3BlLmVuYWJsZURhbXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICBzcGhlcmljYWxEZWx0YS50aGV0YSAqPSAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvclxuICAgICAgICAgIHNwaGVyaWNhbERlbHRhLnBoaSAqPSAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvclxuXG4gICAgICAgICAgcGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKDEgLSBzY29wZS5kYW1waW5nRmFjdG9yKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwaGVyaWNhbERlbHRhLnNldCgwLCAwLCAwKVxuXG4gICAgICAgICAgcGFuT2Zmc2V0LnNldCgwLCAwLCAwKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRqdXN0IGNhbWVyYSBwb3NpdGlvblxuICAgICAgICBsZXQgem9vbUNoYW5nZWQgPSBmYWxzZVxuICAgICAgICBpZiAoc2NvcGUuem9vbVRvQ3Vyc29yICYmIHBlcmZvcm1DdXJzb3Jab29tKSB7XG4gICAgICAgICAgbGV0IG5ld1JhZGl1cyA9IG51bGxcbiAgICAgICAgICBpZiAoc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgUGVyc3BlY3RpdmVDYW1lcmEgJiYgc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEpIHtcbiAgICAgICAgICAgIC8vIG1vdmUgdGhlIGNhbWVyYSBkb3duIHRoZSBwb2ludGVyIHJheVxuICAgICAgICAgICAgLy8gdGhpcyBtZXRob2QgYXZvaWRzIGZsb2F0aW5nIHBvaW50IGVycm9yXG4gICAgICAgICAgICBjb25zdCBwcmV2UmFkaXVzID0gb2Zmc2V0Lmxlbmd0aCgpXG4gICAgICAgICAgICBuZXdSYWRpdXMgPSBjbGFtcERpc3RhbmNlKHByZXZSYWRpdXMgKiBzY2FsZSlcblxuICAgICAgICAgICAgY29uc3QgcmFkaXVzRGVsdGEgPSBwcmV2UmFkaXVzIC0gbmV3UmFkaXVzXG4gICAgICAgICAgICBzY29wZS5vYmplY3QucG9zaXRpb24uYWRkU2NhbGVkVmVjdG9yKGRvbGx5RGlyZWN0aW9uLCByYWRpdXNEZWx0YSlcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCgpXG4gICAgICAgICAgfSBlbHNlIGlmICgoc2NvcGUub2JqZWN0IGFzIE9ydGhvZ3JhcGhpY0NhbWVyYSkuaXNPcnRob2dyYXBoaWNDYW1lcmEpIHtcbiAgICAgICAgICAgIC8vIGFkanVzdCB0aGUgb3J0aG8gY2FtZXJhIHBvc2l0aW9uIGJhc2VkIG9uIHpvb20gY2hhbmdlc1xuICAgICAgICAgICAgY29uc3QgbW91c2VCZWZvcmUgPSBuZXcgVmVjdG9yMyhtb3VzZS54LCBtb3VzZS55LCAwKVxuICAgICAgICAgICAgbW91c2VCZWZvcmUudW5wcm9qZWN0KHNjb3BlLm9iamVjdClcblxuICAgICAgICAgICAgc2NvcGUub2JqZWN0Lnpvb20gPSBNYXRoLm1heChzY29wZS5taW5ab29tLCBNYXRoLm1pbihzY29wZS5tYXhab29tLCBzY29wZS5vYmplY3Quem9vbSAvIHNjYWxlKSlcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KClcbiAgICAgICAgICAgIHpvb21DaGFuZ2VkID0gdHJ1ZVxuXG4gICAgICAgICAgICBjb25zdCBtb3VzZUFmdGVyID0gbmV3IFZlY3RvcjMobW91c2UueCwgbW91c2UueSwgMClcbiAgICAgICAgICAgIG1vdXNlQWZ0ZXIudW5wcm9qZWN0KHNjb3BlLm9iamVjdClcblxuICAgICAgICAgICAgc2NvcGUub2JqZWN0LnBvc2l0aW9uLnN1Yihtb3VzZUFmdGVyKS5hZGQobW91c2VCZWZvcmUpXG4gICAgICAgICAgICBzY29wZS5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoKVxuXG4gICAgICAgICAgICBuZXdSYWRpdXMgPSBvZmZzZXQubGVuZ3RoKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSB6b29tIHRvIGN1cnNvciBkaXNhYmxlZC4nKVxuICAgICAgICAgICAgc2NvcGUuem9vbVRvQ3Vyc29yID0gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBoYW5kbGUgdGhlIHBsYWNlbWVudCBvZiB0aGUgdGFyZ2V0XG4gICAgICAgICAgaWYgKG5ld1JhZGl1cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHNjb3BlLnNjcmVlblNwYWNlUGFubmluZykge1xuICAgICAgICAgICAgICAvLyBwb3NpdGlvbiB0aGUgb3JiaXQgdGFyZ2V0IGluIGZyb250IG9mIHRoZSBuZXcgY2FtZXJhIHBvc2l0aW9uXG4gICAgICAgICAgICAgIHNjb3BlLnRhcmdldFxuICAgICAgICAgICAgICAgIC5zZXQoMCwgMCwgLTEpXG4gICAgICAgICAgICAgICAgLnRyYW5zZm9ybURpcmVjdGlvbihzY29wZS5vYmplY3QubWF0cml4KVxuICAgICAgICAgICAgICAgIC5tdWx0aXBseVNjYWxhcihuZXdSYWRpdXMpXG4gICAgICAgICAgICAgICAgLmFkZChzY29wZS5vYmplY3QucG9zaXRpb24pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBnZXQgdGhlIHJheSBhbmQgdHJhbnNsYXRpb24gcGxhbmUgdG8gY29tcHV0ZSB0YXJnZXRcbiAgICAgICAgICAgICAgX3JheS5vcmlnaW4uY29weShzY29wZS5vYmplY3QucG9zaXRpb24pXG4gICAgICAgICAgICAgIF9yYXkuZGlyZWN0aW9uLnNldCgwLCAwLCAtMSkudHJhbnNmb3JtRGlyZWN0aW9uKHNjb3BlLm9iamVjdC5tYXRyaXgpXG5cbiAgICAgICAgICAgICAgLy8gaWYgdGhlIGNhbWVyYSBpcyAyMCBkZWdyZWVzIGFib3ZlIHRoZSBob3Jpem9uIHRoZW4gZG9uJ3QgYWRqdXN0IHRoZSBmb2N1cyB0YXJnZXQgdG8gYXZvaWRcbiAgICAgICAgICAgICAgLy8gZXh0cmVtZWx5IGxhcmdlIHZhbHVlc1xuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoc2NvcGUub2JqZWN0LnVwLmRvdChfcmF5LmRpcmVjdGlvbikpIDwgVElMVF9MSU1JVCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5sb29rQXQoc2NvcGUudGFyZ2V0KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wbGFuZS5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludChzY29wZS5vYmplY3QudXAsIHNjb3BlLnRhcmdldClcbiAgICAgICAgICAgICAgICBfcmF5LmludGVyc2VjdFBsYW5lKF9wbGFuZSwgc2NvcGUudGFyZ2V0KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIE9ydGhvZ3JhcGhpY0NhbWVyYSAmJiBzY29wZS5vYmplY3QuaXNPcnRob2dyYXBoaWNDYW1lcmEpIHtcbiAgICAgICAgICB6b29tQ2hhbmdlZCA9IHNjYWxlICE9PSAxXG5cbiAgICAgICAgICBpZiAoem9vbUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC56b29tID0gTWF0aC5tYXgoc2NvcGUubWluWm9vbSwgTWF0aC5taW4oc2NvcGUubWF4Wm9vbSwgc2NvcGUub2JqZWN0Lnpvb20gLyBzY2FsZSkpXG4gICAgICAgICAgICBzY29wZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2NhbGUgPSAxXG4gICAgICAgIHBlcmZvcm1DdXJzb3Jab29tID0gZmFsc2VcblxuICAgICAgICAvLyB1cGRhdGUgY29uZGl0aW9uIGlzOlxuICAgICAgICAvLyBtaW4oY2FtZXJhIGRpc3BsYWNlbWVudCwgY2FtZXJhIHJvdGF0aW9uIGluIHJhZGlhbnMpXjIgPiBFUFNcbiAgICAgICAgLy8gdXNpbmcgc21hbGwtYW5nbGUgYXBwcm94aW1hdGlvbiBjb3MoeC8yKSA9IDEgLSB4XjIgLyA4XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHpvb21DaGFuZ2VkIHx8XG4gICAgICAgICAgbGFzdFBvc2l0aW9uLmRpc3RhbmNlVG9TcXVhcmVkKHNjb3BlLm9iamVjdC5wb3NpdGlvbikgPiBFUFMgfHxcbiAgICAgICAgICA4ICogKDEgLSBsYXN0UXVhdGVybmlvbi5kb3Qoc2NvcGUub2JqZWN0LnF1YXRlcm5pb24pKSA+IEVQU1xuICAgICAgICApIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChjaGFuZ2VFdmVudClcblxuICAgICAgICAgIGxhc3RQb3NpdGlvbi5jb3B5KHNjb3BlLm9iamVjdC5wb3NpdGlvbilcbiAgICAgICAgICBsYXN0UXVhdGVybmlvbi5jb3B5KHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uKVxuICAgICAgICAgIHpvb21DaGFuZ2VkID0gZmFsc2VcblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpXG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8yMDU3NVxuICAgIHRoaXMuY29ubmVjdCA9IChkb21FbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQgPT4ge1xuICAgICAgc2NvcGUuZG9tRWxlbWVudCA9IGRvbUVsZW1lbnRcbiAgICAgIC8vIGRpc2FibGVzIHRvdWNoIHNjcm9sbFxuICAgICAgLy8gdG91Y2gtYWN0aW9uIG5lZWRzIHRvIGJlIGRlZmluZWQgZm9yIHBvaW50ZXIgZXZlbnRzIHRvIHdvcmsgb24gbW9iaWxlXG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDgyNTQ1NzhcbiAgICAgIHNjb3BlLmRvbUVsZW1lbnQuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSdcbiAgICAgIHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51KVxuICAgICAgc2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIG9uUG9pbnRlckRvd24pXG4gICAgICBzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJjYW5jZWwnLCBvblBvaW50ZXJVcClcbiAgICAgIHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBvbk1vdXNlV2hlZWwpXG4gICAgfVxuXG4gICAgdGhpcy5kaXNwb3NlID0gKCk6IHZvaWQgPT4ge1xuICAgICAgLy8gRW5hYmxpbmcgdG91Y2ggc2Nyb2xsXG4gICAgICBpZiAoc2NvcGUuZG9tRWxlbWVudCkge1xuICAgICAgICBzY29wZS5kb21FbGVtZW50LnN0eWxlLnRvdWNoQWN0aW9uID0gJ2F1dG8nXG4gICAgICB9XG4gICAgICBzY29wZS5kb21FbGVtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUpXG4gICAgICBzY29wZS5kb21FbGVtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIG9uUG9pbnRlckRvd24pXG4gICAgICBzY29wZS5kb21FbGVtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgb25Qb2ludGVyVXApXG4gICAgICBzY29wZS5kb21FbGVtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIG9uTW91c2VXaGVlbClcbiAgICAgIHNjb3BlLmRvbUVsZW1lbnQ/Lm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBvblBvaW50ZXJNb3ZlKVxuICAgICAgc2NvcGUuZG9tRWxlbWVudD8ub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBvblBvaW50ZXJVcClcbiAgICAgIGlmIChzY29wZS5fZG9tRWxlbWVudEtleUV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICBzY29wZS5fZG9tRWxlbWVudEtleUV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duKVxuICAgICAgfVxuICAgICAgLy9zY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7IC8vIHNob3VsZCB0aGlzIGJlIGFkZGVkIGhlcmU/XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBpbnRlcm5hbHNcbiAgICAvL1xuXG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzXG5cbiAgICBjb25zdCBjaGFuZ2VFdmVudCA9IHsgdHlwZTogJ2NoYW5nZScgfVxuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSB7IHR5cGU6ICdzdGFydCcgfVxuICAgIGNvbnN0IGVuZEV2ZW50ID0geyB0eXBlOiAnZW5kJyB9XG5cbiAgICBjb25zdCBTVEFURSA9IHtcbiAgICAgIE5PTkU6IC0xLFxuICAgICAgUk9UQVRFOiAwLFxuICAgICAgRE9MTFk6IDEsXG4gICAgICBQQU46IDIsXG4gICAgICBUT1VDSF9ST1RBVEU6IDMsXG4gICAgICBUT1VDSF9QQU46IDQsXG4gICAgICBUT1VDSF9ET0xMWV9QQU46IDUsXG4gICAgICBUT1VDSF9ET0xMWV9ST1RBVEU6IDYsXG4gICAgfVxuXG4gICAgbGV0IHN0YXRlID0gU1RBVEUuTk9ORVxuXG4gICAgY29uc3QgRVBTID0gMC4wMDAwMDFcblxuICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaW4gc3BoZXJpY2FsIGNvb3JkaW5hdGVzXG4gICAgY29uc3Qgc3BoZXJpY2FsID0gbmV3IFNwaGVyaWNhbCgpXG4gICAgY29uc3Qgc3BoZXJpY2FsRGVsdGEgPSBuZXcgU3BoZXJpY2FsKClcblxuICAgIGxldCBzY2FsZSA9IDFcbiAgICBjb25zdCBwYW5PZmZzZXQgPSBuZXcgVmVjdG9yMygpXG5cbiAgICBjb25zdCByb3RhdGVTdGFydCA9IG5ldyBWZWN0b3IyKClcbiAgICBjb25zdCByb3RhdGVFbmQgPSBuZXcgVmVjdG9yMigpXG4gICAgY29uc3Qgcm90YXRlRGVsdGEgPSBuZXcgVmVjdG9yMigpXG5cbiAgICBjb25zdCBwYW5TdGFydCA9IG5ldyBWZWN0b3IyKClcbiAgICBjb25zdCBwYW5FbmQgPSBuZXcgVmVjdG9yMigpXG4gICAgY29uc3QgcGFuRGVsdGEgPSBuZXcgVmVjdG9yMigpXG5cbiAgICBjb25zdCBkb2xseVN0YXJ0ID0gbmV3IFZlY3RvcjIoKVxuICAgIGNvbnN0IGRvbGx5RW5kID0gbmV3IFZlY3RvcjIoKVxuICAgIGNvbnN0IGRvbGx5RGVsdGEgPSBuZXcgVmVjdG9yMigpXG5cbiAgICBjb25zdCBkb2xseURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKClcbiAgICBjb25zdCBtb3VzZSA9IG5ldyBWZWN0b3IyKClcbiAgICBsZXQgcGVyZm9ybUN1cnNvclpvb20gPSBmYWxzZVxuXG4gICAgY29uc3QgcG9pbnRlcnM6IFBvaW50ZXJFdmVudFtdID0gW11cbiAgICBjb25zdCBwb2ludGVyUG9zaXRpb25zOiB7IFtrZXk6IHN0cmluZ106IFZlY3RvcjIgfSA9IHt9XG5cbiAgICBmdW5jdGlvbiBnZXRBdXRvUm90YXRpb25BbmdsZSgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuICgoMiAqIE1hdGguUEkpIC8gNjAgLyA2MCkgKiBzY29wZS5hdXRvUm90YXRlU3BlZWRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab29tU2NhbGUoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdygwLjk1LCBzY29wZS56b29tU3BlZWQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlTGVmdChhbmdsZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICBpZiAoc2NvcGUucmV2ZXJzZU9yYml0IHx8IHNjb3BlLnJldmVyc2VIb3Jpem9udGFsT3JiaXQpIHtcbiAgICAgICAgc3BoZXJpY2FsRGVsdGEudGhldGEgKz0gYW5nbGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwaGVyaWNhbERlbHRhLnRoZXRhIC09IGFuZ2xlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlVXAoYW5nbGU6IG51bWJlcik6IHZvaWQge1xuICAgICAgaWYgKHNjb3BlLnJldmVyc2VPcmJpdCB8fCBzY29wZS5yZXZlcnNlVmVydGljYWxPcmJpdCkge1xuICAgICAgICBzcGhlcmljYWxEZWx0YS5waGkgKz0gYW5nbGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwaGVyaWNhbERlbHRhLnBoaSAtPSBhbmdsZVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhbkxlZnQgPSAoKCkgPT4ge1xuICAgICAgY29uc3QgdiA9IG5ldyBWZWN0b3IzKClcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBhbkxlZnQoZGlzdGFuY2U6IG51bWJlciwgb2JqZWN0TWF0cml4OiBNYXRyaXg0KSB7XG4gICAgICAgIHYuc2V0RnJvbU1hdHJpeENvbHVtbihvYmplY3RNYXRyaXgsIDApIC8vIGdldCBYIGNvbHVtbiBvZiBvYmplY3RNYXRyaXhcbiAgICAgICAgdi5tdWx0aXBseVNjYWxhcigtZGlzdGFuY2UpXG5cbiAgICAgICAgcGFuT2Zmc2V0LmFkZCh2KVxuICAgICAgfVxuICAgIH0pKClcblxuICAgIGNvbnN0IHBhblVwID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IHYgPSBuZXcgVmVjdG9yMygpXG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBwYW5VcChkaXN0YW5jZTogbnVtYmVyLCBvYmplY3RNYXRyaXg6IE1hdHJpeDQpIHtcbiAgICAgICAgaWYgKHNjb3BlLnNjcmVlblNwYWNlUGFubmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHYuc2V0RnJvbU1hdHJpeENvbHVtbihvYmplY3RNYXRyaXgsIDEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdi5zZXRGcm9tTWF0cml4Q29sdW1uKG9iamVjdE1hdHJpeCwgMClcbiAgICAgICAgICB2LmNyb3NzVmVjdG9ycyhzY29wZS5vYmplY3QudXAsIHYpXG4gICAgICAgIH1cblxuICAgICAgICB2Lm11bHRpcGx5U2NhbGFyKGRpc3RhbmNlKVxuXG4gICAgICAgIHBhbk9mZnNldC5hZGQodilcbiAgICAgIH1cbiAgICB9KSgpXG5cbiAgICAvLyBkZWx0YVggYW5kIGRlbHRhWSBhcmUgaW4gcGl4ZWxzOyByaWdodCBhbmQgZG93biBhcmUgcG9zaXRpdmVcbiAgICBjb25zdCBwYW4gPSAoKCkgPT4ge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbmV3IFZlY3RvcjMoKVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gcGFuKGRlbHRhWDogbnVtYmVyLCBkZWx0YVk6IG51bWJlcikge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudFxuXG4gICAgICAgIGlmIChlbGVtZW50ICYmIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhICYmIHNjb3BlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhKSB7XG4gICAgICAgICAgLy8gcGVyc3BlY3RpdmVcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHNjb3BlLm9iamVjdC5wb3NpdGlvblxuICAgICAgICAgIG9mZnNldC5jb3B5KHBvc2l0aW9uKS5zdWIoc2NvcGUudGFyZ2V0KVxuICAgICAgICAgIGxldCB0YXJnZXREaXN0YW5jZSA9IG9mZnNldC5sZW5ndGgoKVxuXG4gICAgICAgICAgLy8gaGFsZiBvZiB0aGUgZm92IGlzIGNlbnRlciB0byB0b3Agb2Ygc2NyZWVuXG4gICAgICAgICAgdGFyZ2V0RGlzdGFuY2UgKj0gTWF0aC50YW4oKChzY29wZS5vYmplY3QuZm92IC8gMikgKiBNYXRoLlBJKSAvIDE4MC4wKVxuXG4gICAgICAgICAgLy8gd2UgdXNlIG9ubHkgY2xpZW50SGVpZ2h0IGhlcmUgc28gYXNwZWN0IHJhdGlvIGRvZXMgbm90IGRpc3RvcnQgc3BlZWRcbiAgICAgICAgICBwYW5MZWZ0KCgyICogZGVsdGFYICogdGFyZ2V0RGlzdGFuY2UpIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHNjb3BlLm9iamVjdC5tYXRyaXgpXG4gICAgICAgICAgcGFuVXAoKDIgKiBkZWx0YVkgKiB0YXJnZXREaXN0YW5jZSkgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeClcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ICYmIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIE9ydGhvZ3JhcGhpY0NhbWVyYSAmJiBzY29wZS5vYmplY3QuaXNPcnRob2dyYXBoaWNDYW1lcmEpIHtcbiAgICAgICAgICAvLyBvcnRob2dyYXBoaWNcbiAgICAgICAgICBwYW5MZWZ0KFxuICAgICAgICAgICAgKGRlbHRhWCAqIChzY29wZS5vYmplY3QucmlnaHQgLSBzY29wZS5vYmplY3QubGVmdCkpIC8gc2NvcGUub2JqZWN0Lnpvb20gLyBlbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgc2NvcGUub2JqZWN0Lm1hdHJpeCxcbiAgICAgICAgICApXG4gICAgICAgICAgcGFuVXAoXG4gICAgICAgICAgICAoZGVsdGFZICogKHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tKSkgLyBzY29wZS5vYmplY3Quem9vbSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgc2NvcGUub2JqZWN0Lm1hdHJpeCxcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2FtZXJhIG5laXRoZXIgb3J0aG9ncmFwaGljIG5vciBwZXJzcGVjdGl2ZVxuICAgICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gcGFuIGRpc2FibGVkLicpXG4gICAgICAgICAgc2NvcGUuZW5hYmxlUGFuID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKClcblxuICAgIGZ1bmN0aW9uIHNldFNjYWxlKG5ld1NjYWxlOiBudW1iZXIpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhICYmIHNjb3BlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhKSB8fFxuICAgICAgICAoc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgT3J0aG9ncmFwaGljQ2FtZXJhICYmIHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSlcbiAgICAgICkge1xuICAgICAgICBzY2FsZSA9IG5ld1NjYWxlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJylcbiAgICAgICAgc2NvcGUuZW5hYmxlWm9vbSA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9sbHlPdXQoZG9sbHlTY2FsZTogbnVtYmVyKSB7XG4gICAgICBzZXRTY2FsZShzY2FsZSAvIGRvbGx5U2NhbGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9sbHlJbihkb2xseVNjYWxlOiBudW1iZXIpIHtcbiAgICAgIHNldFNjYWxlKHNjYWxlICogZG9sbHlTY2FsZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNb3VzZVBhcmFtZXRlcnMoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgIGlmICghc2NvcGUuem9vbVRvQ3Vyc29yIHx8ICFzY29wZS5kb21FbGVtZW50KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBwZXJmb3JtQ3Vyc29yWm9vbSA9IHRydWVcblxuICAgICAgY29uc3QgcmVjdCA9IHNjb3BlLmRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0XG4gICAgICBjb25zdCB5ID0gZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgICBjb25zdCB3ID0gcmVjdC53aWR0aFxuICAgICAgY29uc3QgaCA9IHJlY3QuaGVpZ2h0XG5cbiAgICAgIG1vdXNlLnggPSAoeCAvIHcpICogMiAtIDFcbiAgICAgIG1vdXNlLnkgPSAtKHkgLyBoKSAqIDIgKyAxXG5cbiAgICAgIGRvbGx5RGlyZWN0aW9uLnNldChtb3VzZS54LCBtb3VzZS55LCAxKS51bnByb2plY3Qoc2NvcGUub2JqZWN0KS5zdWIoc2NvcGUub2JqZWN0LnBvc2l0aW9uKS5ub3JtYWxpemUoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsYW1wRGlzdGFuY2UoZGlzdDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChzY29wZS5taW5EaXN0YW5jZSwgTWF0aC5taW4oc2NvcGUubWF4RGlzdGFuY2UsIGRpc3QpKVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gZXZlbnQgY2FsbGJhY2tzIC0gdXBkYXRlIHRoZSBvYmplY3Qgc3RhdGVcbiAgICAvL1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duUm90YXRlKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICByb3RhdGVTdGFydC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25Eb2xseShldmVudDogTW91c2VFdmVudCkge1xuICAgICAgdXBkYXRlTW91c2VQYXJhbWV0ZXJzKGV2ZW50KVxuICAgICAgZG9sbHlTdGFydC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25QYW4oZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAgIHBhblN0YXJ0LnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZVJvdGF0ZShldmVudDogTW91c2VFdmVudCkge1xuICAgICAgcm90YXRlRW5kLnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKVxuICAgICAgcm90YXRlRGVsdGEuc3ViVmVjdG9ycyhyb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0KS5tdWx0aXBseVNjYWxhcihzY29wZS5yb3RhdGVTcGVlZClcblxuICAgICAgY29uc3QgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnRcblxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgcm90YXRlTGVmdCgoMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54KSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0KSAvLyB5ZXMsIGhlaWdodFxuICAgICAgICByb3RhdGVVcCgoMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55KSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0KVxuICAgICAgfVxuICAgICAgcm90YXRlU3RhcnQuY29weShyb3RhdGVFbmQpXG4gICAgICBzY29wZS51cGRhdGUoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZURvbGx5KGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICBkb2xseUVuZC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSlcbiAgICAgIGRvbGx5RGVsdGEuc3ViVmVjdG9ycyhkb2xseUVuZCwgZG9sbHlTdGFydClcblxuICAgICAgaWYgKGRvbGx5RGVsdGEueSA+IDApIHtcbiAgICAgICAgZG9sbHlPdXQoZ2V0Wm9vbVNjYWxlKCkpXG4gICAgICB9IGVsc2UgaWYgKGRvbGx5RGVsdGEueSA8IDApIHtcbiAgICAgICAgZG9sbHlJbihnZXRab29tU2NhbGUoKSlcbiAgICAgIH1cblxuICAgICAgZG9sbHlTdGFydC5jb3B5KGRvbGx5RW5kKVxuICAgICAgc2NvcGUudXBkYXRlKClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVQYW4oZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAgIHBhbkVuZC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSlcbiAgICAgIHBhbkRlbHRhLnN1YlZlY3RvcnMocGFuRW5kLCBwYW5TdGFydCkubXVsdGlwbHlTY2FsYXIoc2NvcGUucGFuU3BlZWQpXG4gICAgICBwYW4ocGFuRGVsdGEueCwgcGFuRGVsdGEueSlcbiAgICAgIHBhblN0YXJ0LmNvcHkocGFuRW5kKVxuICAgICAgc2NvcGUudXBkYXRlKClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZVdoZWVsKGV2ZW50OiBXaGVlbEV2ZW50KSB7XG4gICAgICB1cGRhdGVNb3VzZVBhcmFtZXRlcnMoZXZlbnQpXG5cbiAgICAgIGlmIChldmVudC5kZWx0YVkgPCAwKSB7XG4gICAgICAgIGRvbGx5SW4oZ2V0Wm9vbVNjYWxlKCkpXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmRlbHRhWSA+IDApIHtcbiAgICAgICAgZG9sbHlPdXQoZ2V0Wm9vbVNjYWxlKCkpXG4gICAgICB9XG5cbiAgICAgIHNjb3BlLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgbGV0IG5lZWRzVXBkYXRlID0gZmFsc2VcblxuICAgICAgc3dpdGNoIChldmVudC5jb2RlKSB7XG4gICAgICAgIGNhc2Ugc2NvcGUua2V5cy5VUDpcbiAgICAgICAgICBwYW4oMCwgc2NvcGUua2V5UGFuU3BlZWQpXG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIHNjb3BlLmtleXMuQk9UVE9NOlxuICAgICAgICAgIHBhbigwLCAtc2NvcGUua2V5UGFuU3BlZWQpXG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIHNjb3BlLmtleXMuTEVGVDpcbiAgICAgICAgICBwYW4oc2NvcGUua2V5UGFuU3BlZWQsIDApXG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIHNjb3BlLmtleXMuUklHSFQ6XG4gICAgICAgICAgcGFuKC1zY29wZS5rZXlQYW5TcGVlZCwgMClcbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICAgICAgLy8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIHNjcm9sbGluZyBvbiBjdXJzb3Iga2V5c1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHNjb3BlLnVwZGF0ZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydFJvdGF0ZSgpIHtcbiAgICAgIGlmIChwb2ludGVycy5sZW5ndGggPT0gMSkge1xuICAgICAgICByb3RhdGVTdGFydC5zZXQocG9pbnRlcnNbMF0ucGFnZVgsIHBvaW50ZXJzWzBdLnBhZ2VZKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeCA9IDAuNSAqIChwb2ludGVyc1swXS5wYWdlWCArIHBvaW50ZXJzWzFdLnBhZ2VYKVxuICAgICAgICBjb25zdCB5ID0gMC41ICogKHBvaW50ZXJzWzBdLnBhZ2VZICsgcG9pbnRlcnNbMV0ucGFnZVkpXG5cbiAgICAgICAgcm90YXRlU3RhcnQuc2V0KHgsIHkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydFBhbigpIHtcbiAgICAgIGlmIChwb2ludGVycy5sZW5ndGggPT0gMSkge1xuICAgICAgICBwYW5TdGFydC5zZXQocG9pbnRlcnNbMF0ucGFnZVgsIHBvaW50ZXJzWzBdLnBhZ2VZKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeCA9IDAuNSAqIChwb2ludGVyc1swXS5wYWdlWCArIHBvaW50ZXJzWzFdLnBhZ2VYKVxuICAgICAgICBjb25zdCB5ID0gMC41ICogKHBvaW50ZXJzWzBdLnBhZ2VZICsgcG9pbnRlcnNbMV0ucGFnZVkpXG5cbiAgICAgICAgcGFuU3RhcnQuc2V0KHgsIHkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5KCkge1xuICAgICAgY29uc3QgZHggPSBwb2ludGVyc1swXS5wYWdlWCAtIHBvaW50ZXJzWzFdLnBhZ2VYXG4gICAgICBjb25zdCBkeSA9IHBvaW50ZXJzWzBdLnBhZ2VZIC0gcG9pbnRlcnNbMV0ucGFnZVlcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KVxuXG4gICAgICBkb2xseVN0YXJ0LnNldCgwLCBkaXN0YW5jZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0RG9sbHlQYW4oKSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSkgaGFuZGxlVG91Y2hTdGFydERvbGx5KClcbiAgICAgIGlmIChzY29wZS5lbmFibGVQYW4pIGhhbmRsZVRvdWNoU3RhcnRQYW4oKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnREb2xseVJvdGF0ZSgpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVab29tKSBoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoKVxuICAgICAgaWYgKHNjb3BlLmVuYWJsZVJvdGF0ZSkgaGFuZGxlVG91Y2hTdGFydFJvdGF0ZSgpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlUm90YXRlKGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICAgIGlmIChwb2ludGVycy5sZW5ndGggPT0gMSkge1xuICAgICAgICByb3RhdGVFbmQuc2V0KGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKGV2ZW50KVxuICAgICAgICBjb25zdCB4ID0gMC41ICogKGV2ZW50LnBhZ2VYICsgcG9zaXRpb24ueClcbiAgICAgICAgY29uc3QgeSA9IDAuNSAqIChldmVudC5wYWdlWSArIHBvc2l0aW9uLnkpXG4gICAgICAgIHJvdGF0ZUVuZC5zZXQoeCwgeSlcbiAgICAgIH1cblxuICAgICAgcm90YXRlRGVsdGEuc3ViVmVjdG9ycyhyb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0KS5tdWx0aXBseVNjYWxhcihzY29wZS5yb3RhdGVTcGVlZClcblxuICAgICAgY29uc3QgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnRcblxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgcm90YXRlTGVmdCgoMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54KSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0KSAvLyB5ZXMsIGhlaWdodFxuICAgICAgICByb3RhdGVVcCgoMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55KSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0KVxuICAgICAgfVxuICAgICAgcm90YXRlU3RhcnQuY29weShyb3RhdGVFbmQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlUGFuKGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICAgIGlmIChwb2ludGVycy5sZW5ndGggPT0gMSkge1xuICAgICAgICBwYW5FbmQuc2V0KGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKGV2ZW50KVxuICAgICAgICBjb25zdCB4ID0gMC41ICogKGV2ZW50LnBhZ2VYICsgcG9zaXRpb24ueClcbiAgICAgICAgY29uc3QgeSA9IDAuNSAqIChldmVudC5wYWdlWSArIHBvc2l0aW9uLnkpXG4gICAgICAgIHBhbkVuZC5zZXQoeCwgeSlcbiAgICAgIH1cblxuICAgICAgcGFuRGVsdGEuc3ViVmVjdG9ycyhwYW5FbmQsIHBhblN0YXJ0KS5tdWx0aXBseVNjYWxhcihzY29wZS5wYW5TcGVlZClcbiAgICAgIHBhbihwYW5EZWx0YS54LCBwYW5EZWx0YS55KVxuICAgICAgcGFuU3RhcnQuY29weShwYW5FbmQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlRG9sbHkoZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRTZWNvbmRQb2ludGVyUG9zaXRpb24oZXZlbnQpXG4gICAgICBjb25zdCBkeCA9IGV2ZW50LnBhZ2VYIC0gcG9zaXRpb24ueFxuICAgICAgY29uc3QgZHkgPSBldmVudC5wYWdlWSAtIHBvc2l0aW9uLnlcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KVxuXG4gICAgICBkb2xseUVuZC5zZXQoMCwgZGlzdGFuY2UpXG4gICAgICBkb2xseURlbHRhLnNldCgwLCBNYXRoLnBvdyhkb2xseUVuZC55IC8gZG9sbHlTdGFydC55LCBzY29wZS56b29tU3BlZWQpKVxuICAgICAgZG9sbHlPdXQoZG9sbHlEZWx0YS55KVxuICAgICAgZG9sbHlTdGFydC5jb3B5KGRvbGx5RW5kKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZURvbGx5UGFuKGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVab29tKSBoYW5kbGVUb3VjaE1vdmVEb2xseShldmVudClcbiAgICAgIGlmIChzY29wZS5lbmFibGVQYW4pIGhhbmRsZVRvdWNoTW92ZVBhbihldmVudClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVEb2xseVJvdGF0ZShldmVudDogUG9pbnRlckV2ZW50KSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSkgaGFuZGxlVG91Y2hNb3ZlRG9sbHkoZXZlbnQpXG4gICAgICBpZiAoc2NvcGUuZW5hYmxlUm90YXRlKSBoYW5kbGVUb3VjaE1vdmVSb3RhdGUoZXZlbnQpXG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBldmVudCBoYW5kbGVycyAtIEZTTTogbGlzdGVuIGZvciBldmVudHMgYW5kIHJlc2V0IHN0YXRlXG4gICAgLy9cblxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm5cblxuICAgICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzY29wZS5kb21FbGVtZW50Py5vd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSlcbiAgICAgICAgc2NvcGUuZG9tRWxlbWVudD8ub3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBvblBvaW50ZXJVcClcbiAgICAgIH1cblxuICAgICAgYWRkUG9pbnRlcihldmVudClcblxuICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgIG9uVG91Y2hTdGFydChldmVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uTW91c2VEb3duKGV2ZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm5cblxuICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgIG9uVG91Y2hNb3ZlKGV2ZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25Nb3VzZU1vdmUoZXZlbnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Qb2ludGVyVXAoZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgICAgcmVtb3ZlUG9pbnRlcihldmVudClcblxuICAgICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzY29wZS5kb21FbGVtZW50Py5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKVxuXG4gICAgICAgIHNjb3BlLmRvbUVsZW1lbnQ/Lm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBvblBvaW50ZXJNb3ZlKVxuICAgICAgICBzY29wZS5kb21FbGVtZW50Py5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIG9uUG9pbnRlclVwKVxuICAgICAgfVxuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KVxuXG4gICAgICBzdGF0ZSA9IFNUQVRFLk5PTkVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihldmVudDogTW91c2VFdmVudCkge1xuICAgICAgbGV0IG1vdXNlQWN0aW9uXG5cbiAgICAgIHN3aXRjaCAoZXZlbnQuYnV0dG9uKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBtb3VzZUFjdGlvbiA9IHNjb3BlLm1vdXNlQnV0dG9ucy5MRUZUXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbW91c2VBY3Rpb24gPSBzY29wZS5tb3VzZUJ1dHRvbnMuTUlERExFXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbW91c2VBY3Rpb24gPSBzY29wZS5tb3VzZUJ1dHRvbnMuUklHSFRcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbW91c2VBY3Rpb24gPSAtMVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKG1vdXNlQWN0aW9uKSB7XG4gICAgICAgIGNhc2UgTU9VU0UuRE9MTFk6XG4gICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgICBoYW5kbGVNb3VzZURvd25Eb2xseShldmVudClcbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFLkRPTExZXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIE1PVVNFLlJPVEFURTpcbiAgICAgICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSkgcmV0dXJuXG4gICAgICAgICAgICBoYW5kbGVNb3VzZURvd25QYW4oZXZlbnQpXG4gICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlBBTlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSkgcmV0dXJuXG4gICAgICAgICAgICBoYW5kbGVNb3VzZURvd25Sb3RhdGUoZXZlbnQpXG4gICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlJPVEFURVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgTU9VU0UuUEFOOlxuICAgICAgICAgIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgICAgIGhhbmRsZU1vdXNlRG93blJvdGF0ZShldmVudClcbiAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuUk9UQVRFXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgICAgIGhhbmRsZU1vdXNlRG93blBhbihldmVudClcbiAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuUEFOXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkVcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlICE9PSBTVEFURS5OT05FKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVyblxuXG4gICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgU1RBVEUuUk9UQVRFOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgICBoYW5kbGVNb3VzZU1vdmVSb3RhdGUoZXZlbnQpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIFNUQVRFLkRPTExZOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVab29tID09PSBmYWxzZSkgcmV0dXJuXG4gICAgICAgICAgaGFuZGxlTW91c2VNb3ZlRG9sbHkoZXZlbnQpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIFNUQVRFLlBBTjpcbiAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSkgcmV0dXJuXG4gICAgICAgICAgaGFuZGxlTW91c2VNb3ZlUGFuKGV2ZW50KVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZVdoZWVsKGV2ZW50OiBXaGVlbEV2ZW50KSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgfHwgKHN0YXRlICE9PSBTVEFURS5OT05FICYmIHN0YXRlICE9PSBTVEFURS5ST1RBVEUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoc3RhcnRFdmVudClcblxuICAgICAgaGFuZGxlTW91c2VXaGVlbChldmVudClcblxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChlbmRFdmVudClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKSByZXR1cm5cbiAgICAgIGhhbmRsZUtleURvd24oZXZlbnQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICAgIHRyYWNrUG9pbnRlcihldmVudClcblxuICAgICAgc3dpdGNoIChwb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHN3aXRjaCAoc2NvcGUudG91Y2hlcy5PTkUpIHtcbiAgICAgICAgICAgIGNhc2UgVE9VQ0guUk9UQVRFOlxuICAgICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSkgcmV0dXJuXG4gICAgICAgICAgICAgIGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoKVxuICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURVxuICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlIFRPVUNILlBBTjpcbiAgICAgICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UpIHJldHVyblxuICAgICAgICAgICAgICBoYW5kbGVUb3VjaFN0YXJ0UGFuKClcbiAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9QQU5cbiAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc3dpdGNoIChzY29wZS50b3VjaGVzLlRXTykge1xuICAgICAgICAgICAgY2FzZSBUT1VDSC5ET0xMWV9QQU46XG4gICAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVab29tID09PSBmYWxzZSAmJiBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgICAgICAgaGFuZGxlVG91Y2hTdGFydERvbGx5UGFuKClcbiAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9ET0xMWV9QQU5cbiAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSBUT1VDSC5ET0xMWV9ST1RBVEU6XG4gICAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVab29tID09PSBmYWxzZSAmJiBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgICAgICAgaGFuZGxlVG91Y2hTdGFydERvbGx5Um90YXRlKClcbiAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9ET0xMWV9ST1RBVEVcbiAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgIT09IFNUQVRFLk5PTkUpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Ub3VjaE1vdmUoZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgICAgdHJhY2tQb2ludGVyKGV2ZW50KVxuXG4gICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgU1RBVEUuVE9VQ0hfUk9UQVRFOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgICBoYW5kbGVUb3VjaE1vdmVSb3RhdGUoZXZlbnQpXG4gICAgICAgICAgc2NvcGUudXBkYXRlKClcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgU1RBVEUuVE9VQ0hfUEFOOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgICBoYW5kbGVUb3VjaE1vdmVQYW4oZXZlbnQpXG4gICAgICAgICAgc2NvcGUudXBkYXRlKClcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgU1RBVEUuVE9VQ0hfRE9MTFlfUEFOOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVab29tID09PSBmYWxzZSAmJiBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKSByZXR1cm5cbiAgICAgICAgICBoYW5kbGVUb3VjaE1vdmVEb2xseVBhbihldmVudClcbiAgICAgICAgICBzY29wZS51cGRhdGUoKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBTVEFURS5UT1VDSF9ET0xMWV9ST1RBVEU6XG4gICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpIHJldHVyblxuICAgICAgICAgIGhhbmRsZVRvdWNoTW92ZURvbGx5Um90YXRlKGV2ZW50KVxuICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZXZlbnQ6IEV2ZW50KSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVyblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFBvaW50ZXIoZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgICAgcG9pbnRlcnMucHVzaChldmVudClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVQb2ludGVyKGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICAgIGRlbGV0ZSBwb2ludGVyUG9zaXRpb25zW2V2ZW50LnBvaW50ZXJJZF1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocG9pbnRlcnNbaV0ucG9pbnRlcklkID09IGV2ZW50LnBvaW50ZXJJZCkge1xuICAgICAgICAgIHBvaW50ZXJzLnNwbGljZShpLCAxKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2tQb2ludGVyKGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICAgIGxldCBwb3NpdGlvbiA9IHBvaW50ZXJQb3NpdGlvbnNbZXZlbnQucG9pbnRlcklkXVxuXG4gICAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3NpdGlvbiA9IG5ldyBWZWN0b3IyKClcbiAgICAgICAgcG9pbnRlclBvc2l0aW9uc1tldmVudC5wb2ludGVySWRdID0gcG9zaXRpb25cbiAgICAgIH1cblxuICAgICAgcG9zaXRpb24uc2V0KGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZWNvbmRQb2ludGVyUG9zaXRpb24oZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgICAgY29uc3QgcG9pbnRlciA9IGV2ZW50LnBvaW50ZXJJZCA9PT0gcG9pbnRlcnNbMF0ucG9pbnRlcklkID8gcG9pbnRlcnNbMV0gOiBwb2ludGVyc1swXVxuICAgICAgcmV0dXJuIHBvaW50ZXJQb3NpdGlvbnNbcG9pbnRlci5wb2ludGVySWRdXG4gICAgfVxuXG4gICAgLy8gQWRkIGRvbGx5IGluL291dCBtZXRob2RzIGZvciBwdWJsaWMgQVBJXG5cbiAgICB0aGlzLmRvbGx5SW4gPSAoZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpKSA9PiB7XG4gICAgICBkb2xseUluKGRvbGx5U2NhbGUpXG4gICAgICBzY29wZS51cGRhdGUoKVxuICAgIH1cblxuICAgIHRoaXMuZG9sbHlPdXQgPSAoZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpKSA9PiB7XG4gICAgICBkb2xseU91dChkb2xseVNjYWxlKVxuICAgICAgc2NvcGUudXBkYXRlKClcbiAgICB9XG5cbiAgICB0aGlzLmdldFNjYWxlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHNjYWxlXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTY2FsZSA9IChuZXdTY2FsZSkgPT4ge1xuICAgICAgc2V0U2NhbGUobmV3U2NhbGUpXG4gICAgICBzY29wZS51cGRhdGUoKVxuICAgIH1cblxuICAgIHRoaXMuZ2V0Wm9vbVNjYWxlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGdldFpvb21TY2FsZSgpXG4gICAgfVxuXG4gICAgLy8gY29ubmVjdCBldmVudHNcbiAgICBpZiAoZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkKSB0aGlzLmNvbm5lY3QoZG9tRWxlbWVudClcbiAgICAvLyBmb3JjZSBhbiB1cGRhdGUgYXQgc3RhcnRcbiAgICB0aGlzLnVwZGF0ZSgpXG4gIH1cbn1cblxuLy8gVGhpcyBzZXQgb2YgY29udHJvbHMgcGVyZm9ybXMgb3JiaXRpbmcsIGRvbGx5aW5nICh6b29taW5nKSwgYW5kIHBhbm5pbmcuXG4vLyBVbmxpa2UgVHJhY2tiYWxsQ29udHJvbHMsIGl0IG1haW50YWlucyB0aGUgXCJ1cFwiIGRpcmVjdGlvbiBvYmplY3QudXAgKCtZIGJ5IGRlZmF1bHQpLlxuLy8gVGhpcyBpcyB2ZXJ5IHNpbWlsYXIgdG8gT3JiaXRDb250cm9scywgYW5vdGhlciBzZXQgb2YgdG91Y2ggYmVoYXZpb3Jcbi8vXG4vLyAgICBPcmJpdCAtIHJpZ2h0IG1vdXNlLCBvciBsZWZ0IG1vdXNlICsgY3RybC9tZXRhL3NoaWZ0S2V5IC8gdG91Y2g6IHR3by1maW5nZXIgcm90YXRlXG4vLyAgICBab29tIC0gbWlkZGxlIG1vdXNlLCBvciBtb3VzZXdoZWVsIC8gdG91Y2g6IHR3by1maW5nZXIgc3ByZWFkIG9yIHNxdWlzaFxuLy8gICAgUGFuIC0gbGVmdCBtb3VzZSwgb3IgYXJyb3cga2V5cyAvIHRvdWNoOiBvbmUtZmluZ2VyIG1vdmVcblxuY2xhc3MgTWFwQ29udHJvbHMgZXh0ZW5kcyBPcmJpdENvbnRyb2xzIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0OiBQZXJzcGVjdGl2ZUNhbWVyYSB8IE9ydGhvZ3JhcGhpY0NhbWVyYSwgZG9tRWxlbWVudD86IEhUTUxFbGVtZW50KSB7XG4gICAgc3VwZXIob2JqZWN0LCBkb21FbGVtZW50KVxuXG4gICAgdGhpcy5zY3JlZW5TcGFjZVBhbm5pbmcgPSBmYWxzZSAvLyBwYW4gb3J0aG9nb25hbCB0byB3b3JsZC1zcGFjZSBkaXJlY3Rpb24gY2FtZXJhLnVwXG5cbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5MRUZUID0gTU9VU0UuUEFOXG4gICAgdGhpcy5tb3VzZUJ1dHRvbnMuUklHSFQgPSBNT1VTRS5ST1RBVEVcblxuICAgIHRoaXMudG91Y2hlcy5PTkUgPSBUT1VDSC5QQU5cbiAgICB0aGlzLnRvdWNoZXMuVFdPID0gVE9VQ0guRE9MTFlfUk9UQVRFXG4gIH1cbn1cblxuZXhwb3J0IHsgT3JiaXRDb250cm9scywgTWFwQ29udHJvbHMgfVxuIl0sIm5hbWVzIjpbIl9yYXkiLCJSYXkiLCJfcGxhbmUiLCJQbGFuZSIsIlRJTFRfTElNSVQiLCJNYXRoIiwiY29zIiwiUEkiLCJtb2R1bG9XcmFwQXJvdW5kIiwib2Zmc2V0IiwiY2FwYWNpdHkiLCJPcmJpdENvbnRyb2xzIiwiRXZlbnREaXNwYXRjaGVyIiwiY29uc3RydWN0b3IiLCJvYmplY3QiLCJkb21FbGVtZW50IiwiX19wdWJsaWNGaWVsZCIsIlZlY3RvcjMiLCJJbmZpbml0eSIsIkxFRlQiLCJVUCIsIlJJR0hUIiwiQk9UVE9NIiwiTU9VU0UiLCJST1RBVEUiLCJNSURETEUiLCJET0xMWSIsIlBBTiIsIk9ORSIsIlRPVUNIIiwiVFdPIiwiRE9MTFlfUEFOIiwidGFyZ2V0MCIsInRhcmdldCIsImNsb25lIiwicG9zaXRpb24wIiwicG9zaXRpb24iLCJ6b29tMCIsInpvb20iLCJnZXRQb2xhckFuZ2xlIiwic3BoZXJpY2FsIiwicGhpIiwiZ2V0QXppbXV0aGFsQW5nbGUiLCJ0aGV0YSIsInNldFBvbGFyQW5nbGUiLCJ2YWx1ZSIsImN1cnJlbnRQaGkiLCJwaGlEaXN0IiwiYWJzIiwic3BoZXJpY2FsRGVsdGEiLCJzY29wZSIsInVwZGF0ZSIsInNldEF6aW11dGhhbEFuZ2xlIiwiY3VycmVudFRoZXRhIiwidGhldGFEaXN0IiwiZ2V0RGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwibGlzdGVuVG9LZXlFdmVudHMiLCJhZGRFdmVudExpc3RlbmVyIiwib25LZXlEb3duIiwiX2RvbUVsZW1lbnRLZXlFdmVudHMiLCJzdG9wTGlzdGVuVG9LZXlFdmVudHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2F2ZVN0YXRlIiwiY29weSIsInJlc2V0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsImRpc3BhdGNoRXZlbnQiLCJjaGFuZ2VFdmVudCIsInN0YXRlIiwiU1RBVEUiLCJOT05FIiwidXAiLCJxdWF0IiwiUXVhdGVybmlvbiIsInNldEZyb21Vbml0VmVjdG9ycyIsInF1YXRJbnZlcnNlIiwiaW52ZXJ0IiwibGFzdFBvc2l0aW9uIiwibGFzdFF1YXRlcm5pb24iLCJ0d29QSSIsInN1YiIsImFwcGx5UXVhdGVybmlvbiIsInNldEZyb21WZWN0b3IzIiwiYXV0b1JvdGF0ZSIsInJvdGF0ZUxlZnQiLCJnZXRBdXRvUm90YXRpb25BbmdsZSIsImVuYWJsZURhbXBpbmciLCJkYW1waW5nRmFjdG9yIiwibWluIiwibWluQXppbXV0aEFuZ2xlIiwibWF4IiwibWF4QXppbXV0aEFuZ2xlIiwiaXNGaW5pdGUiLCJtaW5Qb2xhckFuZ2xlIiwibWF4UG9sYXJBbmdsZSIsIm1ha2VTYWZlIiwiYWRkU2NhbGVkVmVjdG9yIiwicGFuT2Zmc2V0IiwiYWRkIiwiem9vbVRvQ3Vyc29yIiwicGVyZm9ybUN1cnNvclpvb20iLCJpc09ydGhvZ3JhcGhpY0NhbWVyYSIsInJhZGl1cyIsImNsYW1wRGlzdGFuY2UiLCJzY2FsZSIsInNldEZyb21TcGhlcmljYWwiLCJtYXRyaXhBdXRvVXBkYXRlIiwidXBkYXRlTWF0cml4IiwibG9va0F0IiwibXVsdGlwbHlTY2FsYXIiLCJzZXQiLCJ6b29tQ2hhbmdlZCIsIm5ld1JhZGl1cyIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiaXNQZXJzcGVjdGl2ZUNhbWVyYSIsInByZXZSYWRpdXMiLCJsZW5ndGgiLCJyYWRpdXNEZWx0YSIsImRvbGx5RGlyZWN0aW9uIiwidXBkYXRlTWF0cml4V29ybGQiLCJtb3VzZUJlZm9yZSIsIm1vdXNlIiwieCIsInkiLCJ1bnByb2plY3QiLCJtaW5ab29tIiwibWF4Wm9vbSIsIm1vdXNlQWZ0ZXIiLCJjb25zb2xlIiwid2FybiIsInNjcmVlblNwYWNlUGFubmluZyIsInRyYW5zZm9ybURpcmVjdGlvbiIsIm1hdHJpeCIsIm9yaWdpbiIsImRpcmVjdGlvbiIsImRvdCIsInNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50IiwiaW50ZXJzZWN0UGxhbmUiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJkaXN0YW5jZVRvU3F1YXJlZCIsIkVQUyIsInF1YXRlcm5pb24iLCJjb25uZWN0Iiwic3R5bGUiLCJ0b3VjaEFjdGlvbiIsIm9uQ29udGV4dE1lbnUiLCJvblBvaW50ZXJEb3duIiwib25Qb2ludGVyVXAiLCJvbk1vdXNlV2hlZWwiLCJkaXNwb3NlIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIm93bmVyRG9jdW1lbnQiLCJvblBvaW50ZXJNb3ZlIiwiX2YiLCJ0eXBlIiwic3RhcnRFdmVudCIsImVuZEV2ZW50IiwiVE9VQ0hfUk9UQVRFIiwiVE9VQ0hfUEFOIiwiVE9VQ0hfRE9MTFlfUEFOIiwiVE9VQ0hfRE9MTFlfUk9UQVRFIiwiU3BoZXJpY2FsIiwicm90YXRlU3RhcnQiLCJWZWN0b3IyIiwicm90YXRlRW5kIiwicm90YXRlRGVsdGEiLCJwYW5TdGFydCIsInBhbkVuZCIsInBhbkRlbHRhIiwiZG9sbHlTdGFydCIsImRvbGx5RW5kIiwiZG9sbHlEZWx0YSIsInBvaW50ZXJzIiwicG9pbnRlclBvc2l0aW9ucyIsImF1dG9Sb3RhdGVTcGVlZCIsImdldFpvb21TY2FsZSIsInBvdyIsInpvb21TcGVlZCIsImFuZ2xlIiwicmV2ZXJzZU9yYml0IiwicmV2ZXJzZUhvcml6b250YWxPcmJpdCIsInJvdGF0ZVVwIiwicmV2ZXJzZVZlcnRpY2FsT3JiaXQiLCJwYW5MZWZ0IiwidiIsImRpc3RhbmNlIiwib2JqZWN0TWF0cml4Iiwic2V0RnJvbU1hdHJpeENvbHVtbiIsInBhblVwIiwiY3Jvc3NWZWN0b3JzIiwicGFuIiwiZGVsdGFYIiwiZGVsdGFZIiwiZWxlbWVudCIsInRhcmdldERpc3RhbmNlIiwidGFuIiwiZm92IiwiY2xpZW50SGVpZ2h0IiwicmlnaHQiLCJsZWZ0IiwiY2xpZW50V2lkdGgiLCJ0b3AiLCJib3R0b20iLCJlbmFibGVQYW4iLCJzZXRTY2FsZSIsIm5ld1NjYWxlIiwiZW5hYmxlWm9vbSIsImRvbGx5T3V0IiwiZG9sbHlTY2FsZSIsImRvbGx5SW4iLCJ1cGRhdGVNb3VzZVBhcmFtZXRlcnMiLCJldmVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRYIiwiY2xpZW50WSIsInciLCJ3aWR0aCIsImgiLCJoZWlnaHQiLCJub3JtYWxpemUiLCJkaXN0IiwibWluRGlzdGFuY2UiLCJtYXhEaXN0YW5jZSIsImhhbmRsZU1vdXNlRG93blJvdGF0ZSIsImhhbmRsZU1vdXNlRG93bkRvbGx5IiwiaGFuZGxlTW91c2VEb3duUGFuIiwiaGFuZGxlTW91c2VNb3ZlUm90YXRlIiwic3ViVmVjdG9ycyIsInJvdGF0ZVNwZWVkIiwiaGFuZGxlTW91c2VNb3ZlRG9sbHkiLCJoYW5kbGVNb3VzZU1vdmVQYW4iLCJwYW5TcGVlZCIsImhhbmRsZU1vdXNlV2hlZWwiLCJoYW5kbGVLZXlEb3duIiwibmVlZHNVcGRhdGUiLCJjb2RlIiwia2V5cyIsImtleVBhblNwZWVkIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVUb3VjaFN0YXJ0Um90YXRlIiwicGFnZVgiLCJwYWdlWSIsImhhbmRsZVRvdWNoU3RhcnRQYW4iLCJoYW5kbGVUb3VjaFN0YXJ0RG9sbHkiLCJkeCIsImR5Iiwic3FydCIsImhhbmRsZVRvdWNoU3RhcnREb2xseVBhbiIsImhhbmRsZVRvdWNoU3RhcnREb2xseVJvdGF0ZSIsImVuYWJsZVJvdGF0ZSIsImhhbmRsZVRvdWNoTW92ZVJvdGF0ZSIsImdldFNlY29uZFBvaW50ZXJQb3NpdGlvbiIsImhhbmRsZVRvdWNoTW92ZVBhbiIsImhhbmRsZVRvdWNoTW92ZURvbGx5IiwiaGFuZGxlVG91Y2hNb3ZlRG9sbHlQYW4iLCJoYW5kbGVUb3VjaE1vdmVEb2xseVJvdGF0ZSIsImVuYWJsZWQiLCJhZGRQb2ludGVyIiwicG9pbnRlclR5cGUiLCJvblRvdWNoU3RhcnQiLCJvbk1vdXNlRG93biIsIm9uVG91Y2hNb3ZlIiwib25Nb3VzZU1vdmUiLCJyZW1vdmVQb2ludGVyIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwibW91c2VBY3Rpb24iLCJidXR0b24iLCJtb3VzZUJ1dHRvbnMiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwidHJhY2tQb2ludGVyIiwidG91Y2hlcyIsIkRPTExZX1JPVEFURSIsInB1c2giLCJpIiwic3BsaWNlIiwicG9pbnRlciIsImdldFNjYWxlIiwiTWFwQ29udHJvbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/controls/OrbitControls.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/EXRLoader.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/EXRLoader.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXRLoader: () => (/* binding */ EXRLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fflate */ \"(ssr)/./node_modules/fflate/esm/index.mjs\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/_polyfill/constants.js\");\n\n\n\nconst hasColorSpace = _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_0__.version >= 152;\nclass EXRLoader extends three__WEBPACK_IMPORTED_MODULE_1__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType;\n    }\n    parse(buffer) {\n        const USHORT_RANGE = 1 << 16;\n        const BITMAP_SIZE = USHORT_RANGE >> 3;\n        const HUF_ENCBITS = 16;\n        const HUF_DECBITS = 14;\n        const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n        const HUF_DECSIZE = 1 << HUF_DECBITS;\n        const HUF_DECMASK = HUF_DECSIZE - 1;\n        const NBITS = 16;\n        const A_OFFSET = 1 << NBITS - 1;\n        const MOD_MASK = (1 << NBITS) - 1;\n        const SHORT_ZEROCODE_RUN = 59;\n        const LONG_ZEROCODE_RUN = 63;\n        const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n        const ULONG_SIZE = 8;\n        const FLOAT32_SIZE = 4;\n        const INT32_SIZE = 4;\n        const INT16_SIZE = 2;\n        const INT8_SIZE = 1;\n        const STATIC_HUFFMAN = 0;\n        const DEFLATE = 1;\n        const UNKNOWN = 0;\n        const LOSSY_DCT = 1;\n        const RLE = 2;\n        const logBase = Math.pow(2.7182818, 2.2);\n        function reverseLutFromBitmap(bitmap, lut) {\n            var k = 0;\n            for(var i = 0; i < USHORT_RANGE; ++i){\n                if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n                    lut[k++] = i;\n                }\n            }\n            var n = k - 1;\n            while(k < USHORT_RANGE)lut[k++] = 0;\n            return n;\n        }\n        function hufClearDecTable(hdec) {\n            for(var i = 0; i < HUF_DECSIZE; i++){\n                hdec[i] = {};\n                hdec[i].len = 0;\n                hdec[i].lit = 0;\n                hdec[i].p = null;\n            }\n        }\n        const getBitsReturn = {\n            l: 0,\n            c: 0,\n            lc: 0\n        };\n        function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n            while(lc < nBits){\n                c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n                lc += 8;\n            }\n            lc -= nBits;\n            getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n            getBitsReturn.c = c;\n            getBitsReturn.lc = lc;\n        }\n        const hufTableBuffer = new Array(59);\n        function hufCanonicalCodeTable(hcode) {\n            for(var i = 0; i <= 58; ++i)hufTableBuffer[i] = 0;\n            for(var i = 0; i < HUF_ENCSIZE; ++i)hufTableBuffer[hcode[i]] += 1;\n            var c = 0;\n            for(var i = 58; i > 0; --i){\n                var nc = c + hufTableBuffer[i] >> 1;\n                hufTableBuffer[i] = c;\n                c = nc;\n            }\n            for(var i = 0; i < HUF_ENCSIZE; ++i){\n                var l = hcode[i];\n                if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n            }\n        }\n        function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n            var p = inOffset;\n            var c = 0;\n            var lc = 0;\n            for(; im <= iM; im++){\n                if (p.value - inOffset.value > ni) return false;\n                getBits(6, c, lc, uInt8Array2, p);\n                var l = getBitsReturn.l;\n                c = getBitsReturn.c;\n                lc = getBitsReturn.lc;\n                hcode[im] = l;\n                if (l == LONG_ZEROCODE_RUN) {\n                    if (p.value - inOffset.value > ni) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    getBits(8, c, lc, uInt8Array2, p);\n                    var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n                    c = getBitsReturn.c;\n                    lc = getBitsReturn.lc;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                } else if (l >= SHORT_ZEROCODE_RUN) {\n                    var zerun = l - SHORT_ZEROCODE_RUN + 2;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                }\n            }\n            hufCanonicalCodeTable(hcode);\n        }\n        function hufLength(code) {\n            return code & 63;\n        }\n        function hufCode(code) {\n            return code >> 6;\n        }\n        function hufBuildDecTable(hcode, im, iM, hdecod) {\n            for(; im <= iM; im++){\n                var c = hufCode(hcode[im]);\n                var l = hufLength(hcode[im]);\n                if (c >> l) {\n                    throw \"Invalid table entry\";\n                }\n                if (l > HUF_DECBITS) {\n                    var pl = hdecod[c >> l - HUF_DECBITS];\n                    if (pl.len) {\n                        throw \"Invalid table entry\";\n                    }\n                    pl.lit++;\n                    if (pl.p) {\n                        var p = pl.p;\n                        pl.p = new Array(pl.lit);\n                        for(var i = 0; i < pl.lit - 1; ++i){\n                            pl.p[i] = p[i];\n                        }\n                    } else {\n                        pl.p = new Array(1);\n                    }\n                    pl.p[pl.lit - 1] = im;\n                } else if (l) {\n                    var plOffset = 0;\n                    for(var i = 1 << HUF_DECBITS - l; i > 0; i--){\n                        var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n                        if (pl.len || pl.p) {\n                            throw \"Invalid table entry\";\n                        }\n                        pl.len = l;\n                        pl.lit = im;\n                        plOffset++;\n                    }\n                }\n            }\n            return true;\n        }\n        const getCharReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getChar(c, lc, uInt8Array2, inOffset) {\n            c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n            lc += 8;\n            getCharReturn.c = c;\n            getCharReturn.lc = lc;\n        }\n        const getCodeReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n            if (po == rlc) {\n                if (lc < 8) {\n                    getChar(c, lc, uInt8Array2, inOffset);\n                    c = getCharReturn.c;\n                    lc = getCharReturn.lc;\n                }\n                lc -= 8;\n                var cs = c >> lc;\n                var cs = new Uint8Array([\n                    cs\n                ])[0];\n                if (outBufferOffset.value + cs > outBufferEndOffset) {\n                    return false;\n                }\n                var s = outBuffer[outBufferOffset.value - 1];\n                while(cs-- > 0){\n                    outBuffer[outBufferOffset.value++] = s;\n                }\n            } else if (outBufferOffset.value < outBufferEndOffset) {\n                outBuffer[outBufferOffset.value++] = po;\n            } else {\n                return false;\n            }\n            getCodeReturn.c = c;\n            getCodeReturn.lc = lc;\n        }\n        function UInt16(value) {\n            return value & 65535;\n        }\n        function Int16(value) {\n            var ref = UInt16(value);\n            return ref > 32767 ? ref - 65536 : ref;\n        }\n        const wdec14Return = {\n            a: 0,\n            b: 0\n        };\n        function wdec14(l, h) {\n            var ls = Int16(l);\n            var hs = Int16(h);\n            var hi = hs;\n            var ai = ls + (hi & 1) + (hi >> 1);\n            var as = ai;\n            var bs = ai - hi;\n            wdec14Return.a = as;\n            wdec14Return.b = bs;\n        }\n        function wdec16(l, h) {\n            var m = UInt16(l);\n            var d = UInt16(h);\n            var bb = m - (d >> 1) & MOD_MASK;\n            var aa = d + bb - A_OFFSET & MOD_MASK;\n            wdec14Return.a = aa;\n            wdec14Return.b = bb;\n        }\n        function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n            var w14 = mx < 1 << 14;\n            var n = nx > ny ? ny : nx;\n            var p = 1;\n            var p2;\n            while(p <= n)p <<= 1;\n            p >>= 1;\n            p2 = p;\n            p >>= 1;\n            while(p >= 1){\n                var py = 0;\n                var ey = py + oy * (ny - p2);\n                var oy1 = oy * p;\n                var oy2 = oy * p2;\n                var ox1 = ox * p;\n                var ox2 = ox * p2;\n                var i00, i01, i10, i11;\n                for(; py <= ey; py += oy2){\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        var p10 = px + oy1;\n                        var p11 = p10 + ox1;\n                        if (w14) {\n                            wdec14(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec14(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec14(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        } else {\n                            wdec16(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec16(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec16(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        }\n                    }\n                    if (nx & p) {\n                        var p10 = px + oy1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p10 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p10 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                if (ny & p) {\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p01 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p01 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                p2 = p;\n                p >>= 1;\n            }\n            return py;\n        }\n        function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n            var c = 0;\n            var lc = 0;\n            var outBufferEndOffset = no;\n            var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n            while(inOffset.value < inOffsetEnd){\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n                while(lc >= HUF_DECBITS){\n                    var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n                    var pl = decodingTable[index];\n                    if (pl.len) {\n                        lc -= pl.len;\n                        getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                        c = getCodeReturn.c;\n                        lc = getCodeReturn.lc;\n                    } else {\n                        if (!pl.p) {\n                            throw \"hufDecode issues\";\n                        }\n                        var j;\n                        for(j = 0; j < pl.lit; j++){\n                            var l = hufLength(encodingTable[pl.p[j]]);\n                            while(lc < l && inOffset.value < inOffsetEnd){\n                                getChar(c, lc, uInt8Array2, inOffset);\n                                c = getCharReturn.c;\n                                lc = getCharReturn.lc;\n                            }\n                            if (lc >= l) {\n                                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                                    lc -= l;\n                                    getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                                    c = getCodeReturn.c;\n                                    lc = getCodeReturn.lc;\n                                    break;\n                                }\n                            }\n                        }\n                        if (j == pl.lit) {\n                            throw \"hufDecode issues\";\n                        }\n                    }\n                }\n            }\n            var i = 8 - ni & 7;\n            c >>= i;\n            lc -= i;\n            while(lc > 0){\n                var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n                if (pl.len) {\n                    lc -= pl.len;\n                    getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                } else {\n                    throw \"hufDecode issues\";\n                }\n            }\n            return true;\n        }\n        function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n            var outOffset = {\n                value: 0\n            };\n            var initialInOffset = inOffset.value;\n            var im = parseUint32(inDataView, inOffset);\n            var iM = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            var nBits = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n                throw \"Something wrong with HUF_ENCSIZE\";\n            }\n            var freq = new Array(HUF_ENCSIZE);\n            var hdec = new Array(HUF_DECSIZE);\n            hufClearDecTable(hdec);\n            var ni = nCompressed - (inOffset.value - initialInOffset);\n            hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n            if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n                throw \"Something wrong with hufUncompress\";\n            }\n            hufBuildDecTable(freq, im, iM, hdec);\n            hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n        }\n        function applyLut(lut, data, nData) {\n            for(var i = 0; i < nData; ++i){\n                data[i] = lut[data[i]];\n            }\n        }\n        function predictor(source) {\n            for(var t = 1; t < source.length; t++){\n                var d = source[t - 1] + source[t] - 128;\n                source[t] = d;\n            }\n        }\n        function interleaveScalar(source, out) {\n            var t1 = 0;\n            var t2 = Math.floor((source.length + 1) / 2);\n            var s = 0;\n            var stop = source.length - 1;\n            while(true){\n                if (s > stop) break;\n                out[s++] = source[t1++];\n                if (s > stop) break;\n                out[s++] = source[t2++];\n            }\n        }\n        function decodeRunLength(source) {\n            var size = source.byteLength;\n            var out = new Array();\n            var p = 0;\n            var reader = new DataView(source);\n            while(size > 0){\n                var l = reader.getInt8(p++);\n                if (l < 0) {\n                    var count = -l;\n                    size -= count + 1;\n                    for(var i = 0; i < count; i++){\n                        out.push(reader.getUint8(p++));\n                    }\n                } else {\n                    var count = l;\n                    size -= 2;\n                    var value = reader.getUint8(p++);\n                    for(var i = 0; i < count + 1; i++){\n                        out.push(value);\n                    }\n                }\n            }\n            return out;\n        }\n        function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n            var dataView = new DataView(outBuffer.buffer);\n            var width = channelData[cscSet.idx[0]].width;\n            var height = channelData[cscSet.idx[0]].height;\n            var numComp = 3;\n            var numFullBlocksX = Math.floor(width / 8);\n            var numBlocksX = Math.ceil(width / 8);\n            var numBlocksY = Math.ceil(height / 8);\n            var leftoverX = width - (numBlocksX - 1) * 8;\n            var leftoverY = height - (numBlocksY - 1) * 8;\n            var currAcComp = {\n                value: 0\n            };\n            var currDcComp = new Array(numComp);\n            var dctData = new Array(numComp);\n            var halfZigBlock = new Array(numComp);\n            var rowBlock = new Array(numComp);\n            var rowOffsets = new Array(numComp);\n            for(let comp2 = 0; comp2 < numComp; ++comp2){\n                rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n                currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n                dctData[comp2] = new Float32Array(64);\n                halfZigBlock[comp2] = new Uint16Array(64);\n                rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n            }\n            for(let blocky = 0; blocky < numBlocksY; ++blocky){\n                var maxY = 8;\n                if (blocky == numBlocksY - 1) maxY = leftoverY;\n                var maxX = 8;\n                for(let blockx = 0; blockx < numBlocksX; ++blockx){\n                    if (blockx == numBlocksX - 1) maxX = leftoverX;\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        halfZigBlock[comp2].fill(0);\n                        halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n                        unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n                        unZigZag(halfZigBlock[comp2], dctData[comp2]);\n                        dctInverse(dctData[comp2]);\n                    }\n                    {\n                        csc709Inverse(dctData);\n                    }\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n                    }\n                }\n                let offset2 = 0;\n                for(let comp2 = 0; comp2 < numComp; ++comp2){\n                    const type2 = channelData[cscSet.idx[comp2]].type;\n                    for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                        offset2 = rowOffsets[comp2][y2];\n                        for(let blockx = 0; blockx < numFullBlocksX; ++blockx){\n                            const src = blockx * 64 + (y2 & 7) * 8;\n                            dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n                            dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n                            dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n                            dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n                            dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n                            dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n                            dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n                            dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n                            offset2 += 8 * INT16_SIZE * type2;\n                        }\n                    }\n                    if (numFullBlocksX != numBlocksX) {\n                        for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                            const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n                            const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n                            for(let x2 = 0; x2 < maxX; ++x2){\n                                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n                            }\n                        }\n                    }\n                }\n            }\n            var halfRow = new Uint16Array(width);\n            var dataView = new DataView(outBuffer.buffer);\n            for(var comp = 0; comp < numComp; ++comp){\n                channelData[cscSet.idx[comp]].decoded = true;\n                var type = channelData[cscSet.idx[comp]].type;\n                if (channelData[comp].type != 2) continue;\n                for(var y = 0; y < height; ++y){\n                    const offset2 = rowOffsets[comp][y];\n                    for(var x = 0; x < width; ++x){\n                        halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n                    }\n                    for(var x = 0; x < width; ++x){\n                        dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n                    }\n                }\n            }\n        }\n        function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n            var acValue;\n            var dctComp = 1;\n            while(dctComp < 64){\n                acValue = acBuffer[currAcComp.value];\n                if (acValue == 65280) {\n                    dctComp = 64;\n                } else if (acValue >> 8 == 255) {\n                    dctComp += acValue & 255;\n                } else {\n                    halfZigBlock[dctComp] = acValue;\n                    dctComp++;\n                }\n                currAcComp.value++;\n            }\n        }\n        function unZigZag(src, dst) {\n            dst[0] = decodeFloat16(src[0]);\n            dst[1] = decodeFloat16(src[1]);\n            dst[2] = decodeFloat16(src[5]);\n            dst[3] = decodeFloat16(src[6]);\n            dst[4] = decodeFloat16(src[14]);\n            dst[5] = decodeFloat16(src[15]);\n            dst[6] = decodeFloat16(src[27]);\n            dst[7] = decodeFloat16(src[28]);\n            dst[8] = decodeFloat16(src[2]);\n            dst[9] = decodeFloat16(src[4]);\n            dst[10] = decodeFloat16(src[7]);\n            dst[11] = decodeFloat16(src[13]);\n            dst[12] = decodeFloat16(src[16]);\n            dst[13] = decodeFloat16(src[26]);\n            dst[14] = decodeFloat16(src[29]);\n            dst[15] = decodeFloat16(src[42]);\n            dst[16] = decodeFloat16(src[3]);\n            dst[17] = decodeFloat16(src[8]);\n            dst[18] = decodeFloat16(src[12]);\n            dst[19] = decodeFloat16(src[17]);\n            dst[20] = decodeFloat16(src[25]);\n            dst[21] = decodeFloat16(src[30]);\n            dst[22] = decodeFloat16(src[41]);\n            dst[23] = decodeFloat16(src[43]);\n            dst[24] = decodeFloat16(src[9]);\n            dst[25] = decodeFloat16(src[11]);\n            dst[26] = decodeFloat16(src[18]);\n            dst[27] = decodeFloat16(src[24]);\n            dst[28] = decodeFloat16(src[31]);\n            dst[29] = decodeFloat16(src[40]);\n            dst[30] = decodeFloat16(src[44]);\n            dst[31] = decodeFloat16(src[53]);\n            dst[32] = decodeFloat16(src[10]);\n            dst[33] = decodeFloat16(src[19]);\n            dst[34] = decodeFloat16(src[23]);\n            dst[35] = decodeFloat16(src[32]);\n            dst[36] = decodeFloat16(src[39]);\n            dst[37] = decodeFloat16(src[45]);\n            dst[38] = decodeFloat16(src[52]);\n            dst[39] = decodeFloat16(src[54]);\n            dst[40] = decodeFloat16(src[20]);\n            dst[41] = decodeFloat16(src[22]);\n            dst[42] = decodeFloat16(src[33]);\n            dst[43] = decodeFloat16(src[38]);\n            dst[44] = decodeFloat16(src[46]);\n            dst[45] = decodeFloat16(src[51]);\n            dst[46] = decodeFloat16(src[55]);\n            dst[47] = decodeFloat16(src[60]);\n            dst[48] = decodeFloat16(src[21]);\n            dst[49] = decodeFloat16(src[34]);\n            dst[50] = decodeFloat16(src[37]);\n            dst[51] = decodeFloat16(src[47]);\n            dst[52] = decodeFloat16(src[50]);\n            dst[53] = decodeFloat16(src[56]);\n            dst[54] = decodeFloat16(src[59]);\n            dst[55] = decodeFloat16(src[61]);\n            dst[56] = decodeFloat16(src[35]);\n            dst[57] = decodeFloat16(src[36]);\n            dst[58] = decodeFloat16(src[48]);\n            dst[59] = decodeFloat16(src[49]);\n            dst[60] = decodeFloat16(src[57]);\n            dst[61] = decodeFloat16(src[58]);\n            dst[62] = decodeFloat16(src[62]);\n            dst[63] = decodeFloat16(src[63]);\n        }\n        function dctInverse(data) {\n            const a = 0.5 * Math.cos(3.14159 / 4);\n            const b = 0.5 * Math.cos(3.14159 / 16);\n            const c = 0.5 * Math.cos(3.14159 / 8);\n            const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n            const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n            const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n            const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n            var alpha = new Array(4);\n            var beta = new Array(4);\n            var theta = new Array(4);\n            var gamma = new Array(4);\n            for(var row = 0; row < 8; ++row){\n                var rowPtr = row * 8;\n                alpha[0] = c * data[rowPtr + 2];\n                alpha[1] = f * data[rowPtr + 2];\n                alpha[2] = c * data[rowPtr + 6];\n                alpha[3] = f * data[rowPtr + 6];\n                beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n                beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n                beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n                beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n                theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n                theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[rowPtr + 0] = gamma[0] + beta[0];\n                data[rowPtr + 1] = gamma[1] + beta[1];\n                data[rowPtr + 2] = gamma[2] + beta[2];\n                data[rowPtr + 3] = gamma[3] + beta[3];\n                data[rowPtr + 4] = gamma[3] - beta[3];\n                data[rowPtr + 5] = gamma[2] - beta[2];\n                data[rowPtr + 6] = gamma[1] - beta[1];\n                data[rowPtr + 7] = gamma[0] - beta[0];\n            }\n            for(var column = 0; column < 8; ++column){\n                alpha[0] = c * data[16 + column];\n                alpha[1] = f * data[16 + column];\n                alpha[2] = c * data[48 + column];\n                alpha[3] = f * data[48 + column];\n                beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n                beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n                beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n                beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n                theta[0] = a * (data[column] + data[32 + column]);\n                theta[3] = a * (data[column] - data[32 + column]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[0 + column] = gamma[0] + beta[0];\n                data[8 + column] = gamma[1] + beta[1];\n                data[16 + column] = gamma[2] + beta[2];\n                data[24 + column] = gamma[3] + beta[3];\n                data[32 + column] = gamma[3] - beta[3];\n                data[40 + column] = gamma[2] - beta[2];\n                data[48 + column] = gamma[1] - beta[1];\n                data[56 + column] = gamma[0] - beta[0];\n            }\n        }\n        function csc709Inverse(data) {\n            for(var i = 0; i < 64; ++i){\n                var y = data[0][i];\n                var cb = data[1][i];\n                var cr = data[2][i];\n                data[0][i] = y + 1.5747 * cr;\n                data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n                data[2][i] = y + 1.8556 * cb;\n            }\n        }\n        function convertToHalf(src, dst, idx) {\n            for(var i = 0; i < 64; ++i){\n                dst[idx + i] = three__WEBPACK_IMPORTED_MODULE_1__.DataUtils.toHalfFloat(toLinear(src[i]));\n            }\n        }\n        function toLinear(float) {\n            if (float <= 1) {\n                return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n            } else {\n                return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n            }\n        }\n        function uncompressRAW(info) {\n            return new DataView(info.array.buffer, info.offset.value, info.size);\n        }\n        function uncompressRLE(info) {\n            var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressZIP(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPIZ(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n            var bitmap = new Uint8Array(BITMAP_SIZE);\n            var outBufferEnd = 0;\n            var pizChannelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; i++){\n                pizChannelData[i] = {};\n                pizChannelData[i][\"start\"] = outBufferEnd;\n                pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n                pizChannelData[i][\"nx\"] = info.width;\n                pizChannelData[i][\"ny\"] = info.lines;\n                pizChannelData[i][\"size\"] = info.type;\n                outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n            }\n            var minNonZero = parseUint16(inDataView, inOffset);\n            var maxNonZero = parseUint16(inDataView, inOffset);\n            if (maxNonZero >= BITMAP_SIZE) {\n                throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n            }\n            if (minNonZero <= maxNonZero) {\n                for(var i = 0; i < maxNonZero - minNonZero + 1; i++){\n                    bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n                }\n            }\n            var lut = new Uint16Array(USHORT_RANGE);\n            var maxValue = reverseLutFromBitmap(bitmap, lut);\n            var length = parseUint32(inDataView, inOffset);\n            hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = pizChannelData[i];\n                for(var j = 0; j < pizChannelData[i].size; ++j){\n                    wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n                }\n            }\n            applyLut(lut, outBuffer, outBufferEnd);\n            var tmpOffset2 = 0;\n            var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n            for(var y = 0; y < info.lines; y++){\n                for(var c = 0; c < info.channels; c++){\n                    var cd = pizChannelData[c];\n                    var n = cd.nx * cd.size;\n                    var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n                    tmpBuffer.set(cp, tmpOffset2);\n                    tmpOffset2 += n * INT16_SIZE;\n                    cd.end += n;\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPXR(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n            const sz = info.lines * info.channels * info.width;\n            const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n            let tmpBufferEnd = 0;\n            let writePtr = 0;\n            const ptr = new Array(4);\n            for(let y = 0; y < info.lines; y++){\n                for(let c = 0; c < info.channels; c++){\n                    let pixel = 0;\n                    switch(info.type){\n                        case 1:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            tmpBufferEnd = ptr[1] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                        case 2:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            ptr[2] = ptr[1] + info.width;\n                            tmpBufferEnd = ptr[2] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                    }\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressDWA(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n            var dwaHeader = {\n                version: parseInt64(inDataView, inOffset),\n                unknownUncompressedSize: parseInt64(inDataView, inOffset),\n                unknownCompressedSize: parseInt64(inDataView, inOffset),\n                acCompressedSize: parseInt64(inDataView, inOffset),\n                dcCompressedSize: parseInt64(inDataView, inOffset),\n                rleCompressedSize: parseInt64(inDataView, inOffset),\n                rleUncompressedSize: parseInt64(inDataView, inOffset),\n                rleRawSize: parseInt64(inDataView, inOffset),\n                totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n                totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n                acCompression: parseInt64(inDataView, inOffset)\n            };\n            if (dwaHeader.version < 2) {\n                throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n            }\n            var channelRules = new Array();\n            var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n            while(ruleSize > 0){\n                var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n                var value = parseUint8(inDataView, inOffset);\n                var compression = value >> 2 & 3;\n                var csc = (value >> 4) - 1;\n                var index = new Int8Array([\n                    csc\n                ])[0];\n                var type = parseUint8(inDataView, inOffset);\n                channelRules.push({\n                    name,\n                    index,\n                    type,\n                    compression\n                });\n                ruleSize -= name.length + 3;\n            }\n            var channels = EXRHeader.channels;\n            var channelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = channelData[i] = {};\n                var channel = channels[i];\n                cd.name = channel.name;\n                cd.compression = UNKNOWN;\n                cd.decoded = false;\n                cd.type = channel.pixelType;\n                cd.pLinear = channel.pLinear;\n                cd.width = info.width;\n                cd.height = info.lines;\n            }\n            var cscSet = {\n                idx: new Array(3)\n            };\n            for(var offset2 = 0; offset2 < info.channels; ++offset2){\n                var cd = channelData[offset2];\n                for(var i = 0; i < channelRules.length; ++i){\n                    var rule = channelRules[i];\n                    if (cd.name == rule.name) {\n                        cd.compression = rule.compression;\n                        if (rule.index >= 0) {\n                            cscSet.idx[rule.index] = offset2;\n                        }\n                        cd.offset = offset2;\n                    }\n                }\n            }\n            if (dwaHeader.acCompressedSize > 0) {\n                switch(dwaHeader.acCompression){\n                    case STATIC_HUFFMAN:\n                        var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n                        hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n                        break;\n                    case DEFLATE:\n                        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n                        var data = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n                        var acBuffer = new Uint16Array(data.buffer);\n                        inOffset.value += dwaHeader.totalAcUncompressedCount;\n                        break;\n                }\n            }\n            if (dwaHeader.dcCompressedSize > 0) {\n                var zlibInfo = {\n                    array: info.array,\n                    offset: inOffset,\n                    size: dwaHeader.dcCompressedSize\n                };\n                var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n                inOffset.value += dwaHeader.dcCompressedSize;\n            }\n            if (dwaHeader.rleRawSize > 0) {\n                var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n                var data = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n                var rleBuffer = decodeRunLength(data.buffer);\n                inOffset.value += dwaHeader.rleCompressedSize;\n            }\n            var outBufferEnd = 0;\n            var rowOffsets = new Array(channelData.length);\n            for(var i = 0; i < rowOffsets.length; ++i){\n                rowOffsets[i] = new Array();\n            }\n            for(var y = 0; y < info.lines; ++y){\n                for(var chan = 0; chan < channelData.length; ++chan){\n                    rowOffsets[chan].push(outBufferEnd);\n                    outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n                }\n            }\n            lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n            for(var i = 0; i < channelData.length; ++i){\n                var cd = channelData[i];\n                if (cd.decoded) continue;\n                switch(cd.compression){\n                    case RLE:\n                        var row = 0;\n                        var rleOffset = 0;\n                        for(var y = 0; y < info.lines; ++y){\n                            var rowOffsetBytes = rowOffsets[i][row];\n                            for(var x = 0; x < cd.width; ++x){\n                                for(var byte = 0; byte < INT16_SIZE * cd.type; ++byte){\n                                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                                }\n                                rleOffset++;\n                            }\n                            row++;\n                        }\n                        break;\n                    case LOSSY_DCT:\n                    default:\n                        throw \"EXRLoader.parse: unsupported channel compression\";\n                }\n            }\n            return new DataView(outBuffer.buffer);\n        }\n        function parseNullTerminatedString(buffer2, offset2) {\n            var uintBuffer = new Uint8Array(buffer2);\n            var endOffset = 0;\n            while(uintBuffer[offset2.value + endOffset] != 0){\n                endOffset += 1;\n            }\n            var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n            offset2.value = offset2.value + endOffset + 1;\n            return stringValue;\n        }\n        function parseFixedLengthString(buffer2, offset2, size) {\n            var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n            offset2.value = offset2.value + size;\n            return stringValue;\n        }\n        function parseRational(dataView, offset2) {\n            var x = parseInt32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseTimecode(dataView, offset2) {\n            var x = parseUint32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseInt32(dataView, offset2) {\n            var Int32 = dataView.getInt32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Int32;\n        }\n        function parseUint32(dataView, offset2) {\n            var Uint32 = dataView.getUint32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Uint32;\n        }\n        function parseUint8Array(uInt8Array2, offset2) {\n            var Uint8 = uInt8Array2[offset2.value];\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        function parseUint8(dataView, offset2) {\n            var Uint8 = dataView.getUint8(offset2.value);\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        const parseInt64 = function(dataView, offset2) {\n            let int;\n            if (\"getBigInt64\" in DataView.prototype) {\n                int = Number(dataView.getBigInt64(offset2.value, true));\n            } else {\n                int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n            }\n            offset2.value += ULONG_SIZE;\n            return int;\n        };\n        function parseFloat32(dataView, offset2) {\n            var float = dataView.getFloat32(offset2.value, true);\n            offset2.value += FLOAT32_SIZE;\n            return float;\n        }\n        function decodeFloat32(dataView, offset2) {\n            return three__WEBPACK_IMPORTED_MODULE_1__.DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n        }\n        function decodeFloat16(binary) {\n            var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n            return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n        }\n        function parseUint16(dataView, offset2) {\n            var Uint16 = dataView.getUint16(offset2.value, true);\n            offset2.value += INT16_SIZE;\n            return Uint16;\n        }\n        function parseFloat16(buffer2, offset2) {\n            return decodeFloat16(parseUint16(buffer2, offset2));\n        }\n        function parseChlist(dataView, buffer2, offset2, size) {\n            var startOffset = offset2.value;\n            var channels = [];\n            while(offset2.value < startOffset + size - 1){\n                var name = parseNullTerminatedString(buffer2, offset2);\n                var pixelType = parseInt32(dataView, offset2);\n                var pLinear = parseUint8(dataView, offset2);\n                offset2.value += 3;\n                var xSampling = parseInt32(dataView, offset2);\n                var ySampling = parseInt32(dataView, offset2);\n                channels.push({\n                    name,\n                    pixelType,\n                    pLinear,\n                    xSampling,\n                    ySampling\n                });\n            }\n            offset2.value += 1;\n            return channels;\n        }\n        function parseChromaticities(dataView, offset2) {\n            var redX = parseFloat32(dataView, offset2);\n            var redY = parseFloat32(dataView, offset2);\n            var greenX = parseFloat32(dataView, offset2);\n            var greenY = parseFloat32(dataView, offset2);\n            var blueX = parseFloat32(dataView, offset2);\n            var blueY = parseFloat32(dataView, offset2);\n            var whiteX = parseFloat32(dataView, offset2);\n            var whiteY = parseFloat32(dataView, offset2);\n            return {\n                redX,\n                redY,\n                greenX,\n                greenY,\n                blueX,\n                blueY,\n                whiteX,\n                whiteY\n            };\n        }\n        function parseCompression(dataView, offset2) {\n            var compressionCodes = [\n                \"NO_COMPRESSION\",\n                \"RLE_COMPRESSION\",\n                \"ZIPS_COMPRESSION\",\n                \"ZIP_COMPRESSION\",\n                \"PIZ_COMPRESSION\",\n                \"PXR24_COMPRESSION\",\n                \"B44_COMPRESSION\",\n                \"B44A_COMPRESSION\",\n                \"DWAA_COMPRESSION\",\n                \"DWAB_COMPRESSION\"\n            ];\n            var compression = parseUint8(dataView, offset2);\n            return compressionCodes[compression];\n        }\n        function parseBox2i(dataView, offset2) {\n            var xMin = parseUint32(dataView, offset2);\n            var yMin = parseUint32(dataView, offset2);\n            var xMax = parseUint32(dataView, offset2);\n            var yMax = parseUint32(dataView, offset2);\n            return {\n                xMin,\n                yMin,\n                xMax,\n                yMax\n            };\n        }\n        function parseLineOrder(dataView, offset2) {\n            var lineOrders = [\n                \"INCREASING_Y\"\n            ];\n            var lineOrder = parseUint8(dataView, offset2);\n            return lineOrders[lineOrder];\n        }\n        function parseV2f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseV3f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            var z = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y,\n                z\n            ];\n        }\n        function parseValue(dataView, buffer2, offset2, type, size) {\n            if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n                return parseFixedLengthString(buffer2, offset2, size);\n            } else if (type === \"chlist\") {\n                return parseChlist(dataView, buffer2, offset2, size);\n            } else if (type === \"chromaticities\") {\n                return parseChromaticities(dataView, offset2);\n            } else if (type === \"compression\") {\n                return parseCompression(dataView, offset2);\n            } else if (type === \"box2i\") {\n                return parseBox2i(dataView, offset2);\n            } else if (type === \"lineOrder\") {\n                return parseLineOrder(dataView, offset2);\n            } else if (type === \"float\") {\n                return parseFloat32(dataView, offset2);\n            } else if (type === \"v2f\") {\n                return parseV2f(dataView, offset2);\n            } else if (type === \"v3f\") {\n                return parseV3f(dataView, offset2);\n            } else if (type === \"int\") {\n                return parseInt32(dataView, offset2);\n            } else if (type === \"rational\") {\n                return parseRational(dataView, offset2);\n            } else if (type === \"timecode\") {\n                return parseTimecode(dataView, offset2);\n            } else if (type === \"preview\") {\n                offset2.value += size;\n                return \"skipped\";\n            } else {\n                offset2.value += size;\n                return void 0;\n            }\n        }\n        function parseHeader(dataView, buffer2, offset2) {\n            const EXRHeader2 = {};\n            if (dataView.getUint32(0, true) != 20000630) {\n                throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n            }\n            EXRHeader2.version = dataView.getUint8(4);\n            const spec = dataView.getUint8(5);\n            EXRHeader2.spec = {\n                singleTile: !!(spec & 2),\n                longName: !!(spec & 4),\n                deepFormat: !!(spec & 8),\n                multiPart: !!(spec & 16)\n            };\n            offset2.value = 8;\n            var keepReading = true;\n            while(keepReading){\n                var attributeName = parseNullTerminatedString(buffer2, offset2);\n                if (attributeName == 0) {\n                    keepReading = false;\n                } else {\n                    var attributeType = parseNullTerminatedString(buffer2, offset2);\n                    var attributeSize = parseUint32(dataView, offset2);\n                    var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n                    if (attributeValue === void 0) {\n                        console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n                    } else {\n                        EXRHeader2[attributeName] = attributeValue;\n                    }\n                }\n            }\n            if ((spec & ~4) != 0) {\n                console.error(\"EXRHeader:\", EXRHeader2);\n                throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n            }\n            return EXRHeader2;\n        }\n        function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n            const EXRDecoder2 = {\n                size: 0,\n                viewer: dataView,\n                array: uInt8Array2,\n                offset: offset2,\n                width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n                height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n                channels: EXRHeader2.channels.length,\n                bytesPerLine: null,\n                lines: null,\n                inputSize: null,\n                type: EXRHeader2.channels[0].pixelType,\n                uncompress: null,\n                getter: null,\n                format: null,\n                [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n            };\n            switch(EXRHeader2.compression){\n                case \"NO_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRAW;\n                    break;\n                case \"RLE_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRLE;\n                    break;\n                case \"ZIPS_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"ZIP_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"PIZ_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressPIZ;\n                    break;\n                case \"PXR24_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressPXR;\n                    break;\n                case \"DWAA_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                case \"DWAB_COMPRESSION\":\n                    EXRDecoder2.lines = 256;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                default:\n                    throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n            }\n            EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n            if (EXRDecoder2.type == 1) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_1__.FloatType:\n                        EXRDecoder2.getter = parseFloat16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType:\n                        EXRDecoder2.getter = parseUint16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                }\n            } else if (EXRDecoder2.type == 2) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_1__.FloatType:\n                        EXRDecoder2.getter = parseFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType:\n                        EXRDecoder2.getter = decodeFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                }\n            } else {\n                throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n            }\n            EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n            for(var i = 0; i < EXRDecoder2.blockCount; i++)parseInt64(dataView, offset2);\n            EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n            const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n            switch(outputType){\n                case three__WEBPACK_IMPORTED_MODULE_1__.FloatType:\n                    EXRDecoder2.byteArray = new Float32Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType:\n                    EXRDecoder2.byteArray = new Uint16Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);\n                    break;\n                default:\n                    console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n                    break;\n            }\n            EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n            if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_1__.RGBAFormat;\n            else EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_1__.RedFormat;\n            if (hasColorSpace) EXRDecoder2.colorSpace = \"srgb-linear\";\n            else EXRDecoder2.encoding = 3e3;\n            return EXRDecoder2;\n        }\n        const bufferDataView = new DataView(buffer);\n        const uInt8Array = new Uint8Array(buffer);\n        const offset = {\n            value: 0\n        };\n        const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n        const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n        const tmpOffset = {\n            value: 0\n        };\n        const channelOffsets = {\n            R: 0,\n            G: 1,\n            B: 2,\n            A: 3,\n            Y: 0\n        };\n        for(let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++){\n            const line = parseUint32(bufferDataView, offset);\n            EXRDecoder.size = parseUint32(bufferDataView, offset);\n            EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n            const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n            const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n            offset.value += EXRDecoder.size;\n            for(let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++){\n                const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n                if (true_y >= EXRDecoder.height) break;\n                for(let channelID = 0; channelID < EXRDecoder.channels; channelID++){\n                    const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n                    for(let x = 0; x < EXRDecoder.width; x++){\n                        tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n                        const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n                        EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n                    }\n                }\n            }\n        }\n        return {\n            header: EXRHeader,\n            width: EXRDecoder.width,\n            height: EXRDecoder.height,\n            data: EXRDecoder.byteArray,\n            format: EXRDecoder.format,\n            [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n            type: this.type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            if (hasColorSpace) texture.colorSpace = texData.colorSpace;\n            else texture.encoding = texData.encoding;\n            texture.minFilter = three__WEBPACK_IMPORTED_MODULE_1__.LinearFilter;\n            texture.magFilter = three__WEBPACK_IMPORTED_MODULE_1__.LinearFilter;\n            texture.generateMipmaps = false;\n            texture.flipY = false;\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=EXRLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL0VYUkxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBdUZBLE1BQU1BLGdCQUFnQkMsMkRBQU9BLElBQUk7QUFFakMsTUFBTUMsa0JBQWtCQyxvREFBaUJBO0lBQ3ZDQyxZQUFZQyxPQUFBLENBQVM7UUFDbkIsTUFBTUE7UUFFTixLQUFLQyxJQUFBLEdBQU9DLGdEQUFhQTtJQUMxQjtJQUVEQyxNQUFNQyxNQUFBLEVBQVE7UUFDWixNQUFNQyxlQUFlLEtBQUs7UUFDMUIsTUFBTUMsY0FBY0QsZ0JBQWdCO1FBRXBDLE1BQU1FLGNBQWM7UUFDcEIsTUFBTUMsY0FBYztRQUVwQixNQUFNQyxjQUFBLENBQWUsS0FBS0YsV0FBQSxJQUFlO1FBQ3pDLE1BQU1HLGNBQWMsS0FBS0Y7UUFDekIsTUFBTUcsY0FBY0QsY0FBYztRQUVsQyxNQUFNRSxRQUFRO1FBQ2QsTUFBTUMsV0FBVyxLQUFNRCxRQUFRO1FBQy9CLE1BQU1FLFdBQUEsQ0FBWSxLQUFLRixLQUFBLElBQVM7UUFFaEMsTUFBTUcscUJBQXFCO1FBQzNCLE1BQU1DLG9CQUFvQjtRQUMxQixNQUFNQyxvQkFBb0IsSUFBSUQsb0JBQW9CRDtRQUVsRCxNQUFNRyxhQUFhO1FBQ25CLE1BQU1DLGVBQWU7UUFDckIsTUFBTUMsYUFBYTtRQUNuQixNQUFNQyxhQUFhO1FBQ25CLE1BQU1DLFlBQVk7UUFFbEIsTUFBTUMsaUJBQWlCO1FBQ3ZCLE1BQU1DLFVBQVU7UUFFaEIsTUFBTUMsVUFBVTtRQUNoQixNQUFNQyxZQUFZO1FBQ2xCLE1BQU1DLE1BQU07UUFFWixNQUFNQyxVQUFVQyxLQUFLQyxHQUFBLENBQUksV0FBVztRQUVwQyxTQUFTQyxxQkFBcUJDLE1BQUEsRUFBUUMsR0FBQTtZQUNwQyxJQUFJQyxJQUFJO1lBRVIsUUFBU0MsSUFBSSxHQUFHQSxJQUFJOUIsY0FBYyxFQUFF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LEdBQUEsQ0FBSSxHQUFFLEdBQUlILGNBQWNQLEdBQUEsQ0FBSSxHQUFHO1lBQy9CVSxHQUFBLENBQUksR0FBRSxHQUFJSCxjQUFjUCxHQUFBLENBQUksR0FBRztZQUUvQlUsR0FBQSxDQUFJLEdBQUUsR0FBSUgsY0FBY1AsR0FBQSxDQUFJLEdBQUc7WUFDL0JVLEdBQUEsQ0FBSSxHQUFFLEdBQUlILGNBQWNQLEdBQUEsQ0FBSSxHQUFHO1lBQy9CVSxHQUFBLENBQUksR0FBRSxHQUFJSCxjQUFjUCxHQUFBLENBQUksR0FBRztZQUMvQlUsR0FBQSxDQUFJLEdBQUUsR0FBSUgsY0FBY1AsR0FBQSxDQUFJLEdBQUc7WUFDL0JVLEdBQUEsQ0FBSSxHQUFFLEdBQUlILGNBQWNQLEdBQUEsQ0FBSSxFQUFFO1lBQzlCVSxHQUFBLENBQUksR0FBRSxHQUFJSCxjQUFjUCxHQUFBLENBQUksR0FBRztZQUMvQlUsR0FBQSxDQUFJLEdBQUUsR0FBSUgsY0FBY1AsR0FBQSxDQUFJLEdBQUc7WUFDL0JVLEdBQUEsQ0FBSSxHQUFFLEdBQUlILGNBQWNQLEdBQUEsQ0FBSSxHQUFHO1lBQy9CVSxHQUFBLENBQUksR0FBRSxHQUFJSCxjQUFjUCxHQUFBLENBQUksR0FBRztZQUMvQlUsR0FBQSxDQUFJLEdBQUUsR0FBSUgsY0FBY1AsR0FBQSxDQUFJLEdBQUc7WUFFL0JVLEdBQUEsQ0FBSSxHQUFFLEdBQUlILGNBQWNQLEdBQUEsQ0FBSSxHQUFHO1lBQy9CVSxHQUFBLENBQUksR0FBRSxHQUFJSCxjQUFjUCxHQUFBLENBQUksR0FBRztZQUMvQlUsR0FBQSxDQUFJLEdBQUUsR0FBSUgsY0FBY1AsR0FBQSxDQUFJLEdBQUc7WUFDL0JVLEdBQUEsQ0FBSSxHQUFFLEdBQUlILGNBQWNQLEdBQUEsQ0FBSSxHQUFHO1lBQy9CVSxHQUFBLENBQUksR0FBRSxHQUFJSCxjQUFjUCxHQUFBLENBQUksR0FBRztZQUMvQlUsR0FBQSxDQUFJLEdBQUUsR0FBSUgsY0FBY1AsR0FBQSxDQUFJLEdBQUc7WUFDL0JVLEdBQUEsQ0FBSSxHQUFFLEdBQUlILGNBQWNQLEdBQUEsQ0FBSSxHQUFHO1lBQy9CVSxHQUFBLENBQUksR0FBRSxHQUFJSCxjQUFjUCxHQUFBLENBQUksR0FBRztZQUMvQlUsR0FBQSxDQUFJLEdBQUUsR0FBSUgsY0FBY1AsR0FBQSxDQUFJLEdBQUc7WUFDL0JVLEdBQUEsQ0FBSSxHQUFFLEdBQUlILGNBQWNQLEdBQUEsQ0FBSSxHQUFHO1lBRS9CVSxHQUFBLENBQUksR0FBRSxHQUFJSCxjQUFjUCxHQUFBLENBQUksR0FBRztZQUMvQlUsR0FBQSxDQUFJLEdBQUUsR0FBSUgsY0FBY1AsR0FBQSxDQUFJLEdBQUc7WUFDL0JVLEdBQUEsQ0FBSSxHQUFFLEdBQUlILGNBQWNQLEdBQUEsQ0FBSSxHQUFHO1lBQy9CVSxHQUFBLENBQUksR0FBRSxHQUFJSCxjQUFjUCxHQUFBLENBQUksR0FBRztZQUMvQlUsR0FBQSxDQUFJLEdBQUUsR0FBSUgsY0FBY1AsR0FBQSxDQUFJLEdBQUc7WUFDL0JVLEdBQUEsQ0FBSSxHQUFFLEdBQUlILGNBQWNQLEdBQUEsQ0FBSSxHQUFHO1lBQy9CVSxHQUFBLENBQUksR0FBRSxHQUFJSCxjQUFjUCxHQUFBLENBQUksR0FBRztZQUMvQlUsR0FBQSxDQUFJLEdBQUUsR0FBSUgsY0FBY1AsR0FBQSxDQUFJLEdBQUc7WUFDL0JVLEdBQUEsQ0FBSSxHQUFFLEdBQUlILGNBQWNQLEdBQUEsQ0FBSSxHQUFHO1lBQy9CVSxHQUFBLENBQUksR0FBRSxHQUFJSCxjQUFjUCxHQUFBLENBQUksR0FBRztZQUUvQlUsR0FBQSxDQUFJLEdBQUUsR0FBSUgsY0FBY1AsR0FBQSxDQUFJLEdBQUc7WUFDL0JVLEdBQUEsQ0FBSSxHQUFFLEdBQUlILGNBQWNQLEdBQUEsQ0FBSSxHQUFHO1lBQy9CVSxHQUFBLENBQUksR0FBRSxHQUFJSCxjQUFjUCxHQUFBLENBQUksR0FBRztZQUMvQlUsR0FBQSxDQUFJLEdBQUUsR0FBSUgsY0FBY1AsR0FBQSxDQUFJLEdBQUc7WUFDL0JVLEdBQUEsQ0FBSSxHQUFFLEdBQUlILGNBQWNQLEdBQUEsQ0FB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QTtZQUNuQjlCLE1BQU1tTyxXQUFXVSxTQUFBO1lBQ2pCSixRQUFRTixXQUFXTSxNQUFBO1lBQ25CLENBQUMxWCxnQkFBZ0IsZUFBZSxXQUFVLEVBQUdvWCxVQUFBLENBQVdwWCxnQkFBZ0IsZUFBZSxXQUFVO1lBQ2pHTSxNQUFNLEtBQUtBLElBQUE7UUFDWjtJQUNGO0lBRUQ2WSxZQUFZalYsS0FBQSxFQUFPO1FBQ2pCLEtBQUs1RCxJQUFBLEdBQU80RDtRQUNaLE9BQU87SUFDUjtJQUVEa1YsS0FBS0MsR0FBQSxFQUFLQyxNQUFBLEVBQVFDLFVBQUEsRUFBWUMsT0FBQSxFQUFTO1FBQ3JDLFNBQVNDLGVBQWVDLE9BQUEsRUFBU0MsT0FBQTtZQUMvQixJQUFJM1osZUFBZTBaLFFBQVF6QixVQUFBLEdBQWEwQixRQUFRMUIsVUFBQTtpQkFDM0N5QixRQUFReEIsUUFBQSxHQUFXeUIsUUFBUXpCLFFBQUE7WUFDaEN3QixRQUFRRSxTQUFBLEdBQVlDLCtDQUFZQTtZQUNoQ0gsUUFBUUksU0FBQSxHQUFZRCwrQ0FBWUE7WUFDaENILFFBQVFLLGVBQUEsR0FBa0I7WUFDMUJMLFFBQVFNLEtBQUEsR0FBUTtZQUVoQixJQUFJVixRQUFRQSxPQUFPSSxTQUFTQztRQUM3QjtRQUVELE9BQU8sTUFBTVAsS0FBS0MsS0FBS0ksZ0JBQWdCRixZQUFZQztJQUNwRDtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm9ja2V0c2ltLy4uLy4uL3NyYy9sb2FkZXJzL0VYUkxvYWRlci5qcz8wNzhkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFRleHR1cmUsXG4gIERhdGFUZXh0dXJlTG9hZGVyLFxuICBEYXRhVXRpbHMsXG4gIEZsb2F0VHlwZSxcbiAgSGFsZkZsb2F0VHlwZSxcbiAgTGluZWFyRmlsdGVyLFxuICBSZWRGb3JtYXQsXG4gIFJHQkFGb3JtYXQsXG59IGZyb20gJ3RocmVlJ1xuaW1wb3J0IHsgdW56bGliU3luYyB9IGZyb20gJ2ZmbGF0ZSdcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi9fcG9seWZpbGwvY29uc3RhbnRzJ1xuXG4vKipcbiAqIE9wZW5FWFIgbG9hZGVyIGN1cnJlbnRseSBzdXBwb3J0cyB1bmNvbXByZXNzZWQsIFpJUChTKSwgUkxFLCBQSVogYW5kIERXQS9CIGNvbXByZXNzaW9uLlxuICogU3VwcG9ydHMgcmVhZGluZyBhcyBVbnNpZ25lZEJ5dGUsIEhhbGZGbG9hdCBhbmQgRmxvYXQgdHlwZSBkYXRhIHRleHR1cmUuXG4gKlxuICogUmVmZXJyZWQgdG8gdGhlIG9yaWdpbmFsIEluZHVzdHJpYWwgTGlnaHQgJiBNYWdpYyBPcGVuRVhSIGltcGxlbWVudGF0aW9uIGFuZCB0aGUgVGlueUVYUiAvIFN5b3lvIEZ1aml0YVxuICogaW1wbGVtZW50YXRpb24sIHNvIEkgaGF2ZSBwcmVzZXJ2ZWQgdGhlaXIgY29weXJpZ2h0IG5vdGljZXMuXG4gKi9cblxuLy8gLypcbi8vIENvcHlyaWdodCAoYykgMjAxNCAtIDIwMTcsIFN5b3lvIEZ1aml0YVxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbi8vICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuLy8gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vICAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIFN5b3lvIEZ1aml0YSBub3IgdGhlXG4vLyAgICAgICBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuLy8gICAgICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuLy8gQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbi8vIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbi8vIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuLy8gRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbi8vIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbi8vIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuLy8gT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4vLyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vICovXG5cbi8vIC8vIFRpbnlFWFIgY29udGFpbnMgc29tZSBPcGVuRVhSIGNvZGUsIHdoaWNoIGlzIGxpY2Vuc2VkIHVuZGVyIC0tLS0tLS0tLS0tLVxuXG4vLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIC8vXG4vLyAvLyBDb3B5cmlnaHQgKGMpIDIwMDIsIEluZHVzdHJpYWwgTGlnaHQgJiBNYWdpYywgYSBkaXZpc2lvbiBvZiBMdWNhc1xuLy8gLy8gRGlnaXRhbCBMdGQuIExMQ1xuLy8gLy9cbi8vIC8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAvL1xuLy8gLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyAvLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyAvLyBtZXQ6XG4vLyAvLyAqICAgICAgIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAvLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAvLyAqICAgICAgIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIC8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIC8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIC8vIGRpc3RyaWJ1dGlvbi5cbi8vIC8vICogICAgICAgTmVpdGhlciB0aGUgbmFtZSBvZiBJbmR1c3RyaWFsIExpZ2h0ICYgTWFnaWMgbm9yIHRoZSBuYW1lcyBvZlxuLy8gLy8gaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuLy8gLy8gZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy8gLy9cbi8vIC8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIC8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIC8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIC8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyAvLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIC8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIC8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vIC8vXG4vLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gLy8gRW5kIG9mIE9wZW5FWFIgbGljZW5zZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNTc3MVxuY29uc3QgaGFzQ29sb3JTcGFjZSA9IHZlcnNpb24gPj0gMTUyXG5cbmNsYXNzIEVYUkxvYWRlciBleHRlbmRzIERhdGFUZXh0dXJlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpXG5cbiAgICB0aGlzLnR5cGUgPSBIYWxmRmxvYXRUeXBlXG4gIH1cblxuICBwYXJzZShidWZmZXIpIHtcbiAgICBjb25zdCBVU0hPUlRfUkFOR0UgPSAxIDw8IDE2XG4gICAgY29uc3QgQklUTUFQX1NJWkUgPSBVU0hPUlRfUkFOR0UgPj4gM1xuXG4gICAgY29uc3QgSFVGX0VOQ0JJVFMgPSAxNiAvLyBsaXRlcmFsICh2YWx1ZSkgYml0IGxlbmd0aFxuICAgIGNvbnN0IEhVRl9ERUNCSVRTID0gMTQgLy8gZGVjb2RpbmcgYml0IHNpemUgKD49IDgpXG5cbiAgICBjb25zdCBIVUZfRU5DU0laRSA9ICgxIDw8IEhVRl9FTkNCSVRTKSArIDEgLy8gZW5jb2RpbmcgdGFibGUgc2l6ZVxuICAgIGNvbnN0IEhVRl9ERUNTSVpFID0gMSA8PCBIVUZfREVDQklUUyAvLyBkZWNvZGluZyB0YWJsZSBzaXplXG4gICAgY29uc3QgSFVGX0RFQ01BU0sgPSBIVUZfREVDU0laRSAtIDFcblxuICAgIGNvbnN0IE5CSVRTID0gMTZcbiAgICBjb25zdCBBX09GRlNFVCA9IDEgPDwgKE5CSVRTIC0gMSlcbiAgICBjb25zdCBNT0RfTUFTSyA9ICgxIDw8IE5CSVRTKSAtIDFcblxuICAgIGNvbnN0IFNIT1JUX1pFUk9DT0RFX1JVTiA9IDU5XG4gICAgY29uc3QgTE9OR19aRVJPQ09ERV9SVU4gPSA2M1xuICAgIGNvbnN0IFNIT1JURVNUX0xPTkdfUlVOID0gMiArIExPTkdfWkVST0NPREVfUlVOIC0gU0hPUlRfWkVST0NPREVfUlVOXG5cbiAgICBjb25zdCBVTE9OR19TSVpFID0gOFxuICAgIGNvbnN0IEZMT0FUMzJfU0laRSA9IDRcbiAgICBjb25zdCBJTlQzMl9TSVpFID0gNFxuICAgIGNvbnN0IElOVDE2X1NJWkUgPSAyXG4gICAgY29uc3QgSU5UOF9TSVpFID0gMVxuXG4gICAgY29uc3QgU1RBVElDX0hVRkZNQU4gPSAwXG4gICAgY29uc3QgREVGTEFURSA9IDFcblxuICAgIGNvbnN0IFVOS05PV04gPSAwXG4gICAgY29uc3QgTE9TU1lfRENUID0gMVxuICAgIGNvbnN0IFJMRSA9IDJcblxuICAgIGNvbnN0IGxvZ0Jhc2UgPSBNYXRoLnBvdygyLjcxODI4MTgsIDIuMilcblxuICAgIGZ1bmN0aW9uIHJldmVyc2VMdXRGcm9tQml0bWFwKGJpdG1hcCwgbHV0KSB7XG4gICAgICB2YXIgayA9IDBcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBVU0hPUlRfUkFOR0U7ICsraSkge1xuICAgICAgICBpZiAoaSA9PSAwIHx8IGJpdG1hcFtpID4+IDNdICYgKDEgPDwgKGkgJiA3KSkpIHtcbiAgICAgICAgICBsdXRbaysrXSA9IGlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbiA9IGsgLSAxXG5cbiAgICAgIHdoaWxlIChrIDwgVVNIT1JUX1JBTkdFKSBsdXRbaysrXSA9IDBcblxuICAgICAgcmV0dXJuIG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodWZDbGVhckRlY1RhYmxlKGhkZWMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSFVGX0RFQ1NJWkU7IGkrKykge1xuICAgICAgICBoZGVjW2ldID0ge31cbiAgICAgICAgaGRlY1tpXS5sZW4gPSAwXG4gICAgICAgIGhkZWNbaV0ubGl0ID0gMFxuICAgICAgICBoZGVjW2ldLnAgPSBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZ2V0Qml0c1JldHVybiA9IHsgbDogMCwgYzogMCwgbGM6IDAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qml0cyhuQml0cywgYywgbGMsIHVJbnQ4QXJyYXksIGluT2Zmc2V0KSB7XG4gICAgICB3aGlsZSAobGMgPCBuQml0cykge1xuICAgICAgICBjID0gKGMgPDwgOCkgfCBwYXJzZVVpbnQ4QXJyYXkodUludDhBcnJheSwgaW5PZmZzZXQpXG4gICAgICAgIGxjICs9IDhcbiAgICAgIH1cblxuICAgICAgbGMgLT0gbkJpdHNcblxuICAgICAgZ2V0Qml0c1JldHVybi5sID0gKGMgPj4gbGMpICYgKCgxIDw8IG5CaXRzKSAtIDEpXG4gICAgICBnZXRCaXRzUmV0dXJuLmMgPSBjXG4gICAgICBnZXRCaXRzUmV0dXJuLmxjID0gbGNcbiAgICB9XG5cbiAgICBjb25zdCBodWZUYWJsZUJ1ZmZlciA9IG5ldyBBcnJheSg1OSlcblxuICAgIGZ1bmN0aW9uIGh1ZkNhbm9uaWNhbENvZGVUYWJsZShoY29kZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gNTg7ICsraSkgaHVmVGFibGVCdWZmZXJbaV0gPSAwXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEhVRl9FTkNTSVpFOyArK2kpIGh1ZlRhYmxlQnVmZmVyW2hjb2RlW2ldXSArPSAxXG5cbiAgICAgIHZhciBjID0gMFxuXG4gICAgICBmb3IgKHZhciBpID0gNTg7IGkgPiAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG5jID0gKGMgKyBodWZUYWJsZUJ1ZmZlcltpXSkgPj4gMVxuICAgICAgICBodWZUYWJsZUJ1ZmZlcltpXSA9IGNcbiAgICAgICAgYyA9IG5jXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSFVGX0VOQ1NJWkU7ICsraSkge1xuICAgICAgICB2YXIgbCA9IGhjb2RlW2ldXG4gICAgICAgIGlmIChsID4gMCkgaGNvZGVbaV0gPSBsIHwgKGh1ZlRhYmxlQnVmZmVyW2xdKysgPDwgNilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodWZVbnBhY2tFbmNUYWJsZSh1SW50OEFycmF5LCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbmksIGltLCBpTSwgaGNvZGUpIHtcbiAgICAgIHZhciBwID0gaW5PZmZzZXRcbiAgICAgIHZhciBjID0gMFxuICAgICAgdmFyIGxjID0gMFxuXG4gICAgICBmb3IgKDsgaW0gPD0gaU07IGltKyspIHtcbiAgICAgICAgaWYgKHAudmFsdWUgLSBpbk9mZnNldC52YWx1ZSA+IG5pKSByZXR1cm4gZmFsc2VcblxuICAgICAgICBnZXRCaXRzKDYsIGMsIGxjLCB1SW50OEFycmF5LCBwKVxuXG4gICAgICAgIHZhciBsID0gZ2V0Qml0c1JldHVybi5sXG4gICAgICAgIGMgPSBnZXRCaXRzUmV0dXJuLmNcbiAgICAgICAgbGMgPSBnZXRCaXRzUmV0dXJuLmxjXG5cbiAgICAgICAgaGNvZGVbaW1dID0gbFxuXG4gICAgICAgIGlmIChsID09IExPTkdfWkVST0NPREVfUlVOKSB7XG4gICAgICAgICAgaWYgKHAudmFsdWUgLSBpbk9mZnNldC52YWx1ZSA+IG5pKSB7XG4gICAgICAgICAgICB0aHJvdyAnU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5wYWNrRW5jVGFibGUnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0Qml0cyg4LCBjLCBsYywgdUludDhBcnJheSwgcClcblxuICAgICAgICAgIHZhciB6ZXJ1biA9IGdldEJpdHNSZXR1cm4ubCArIFNIT1JURVNUX0xPTkdfUlVOXG4gICAgICAgICAgYyA9IGdldEJpdHNSZXR1cm4uY1xuICAgICAgICAgIGxjID0gZ2V0Qml0c1JldHVybi5sY1xuXG4gICAgICAgICAgaWYgKGltICsgemVydW4gPiBpTSArIDEpIHtcbiAgICAgICAgICAgIHRocm93ICdTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbnBhY2tFbmNUYWJsZSdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoemVydW4tLSkgaGNvZGVbaW0rK10gPSAwXG5cbiAgICAgICAgICBpbS0tXG4gICAgICAgIH0gZWxzZSBpZiAobCA+PSBTSE9SVF9aRVJPQ09ERV9SVU4pIHtcbiAgICAgICAgICB2YXIgemVydW4gPSBsIC0gU0hPUlRfWkVST0NPREVfUlVOICsgMlxuXG4gICAgICAgICAgaWYgKGltICsgemVydW4gPiBpTSArIDEpIHtcbiAgICAgICAgICAgIHRocm93ICdTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbnBhY2tFbmNUYWJsZSdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoemVydW4tLSkgaGNvZGVbaW0rK10gPSAwXG5cbiAgICAgICAgICBpbS0tXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaHVmQ2Fub25pY2FsQ29kZVRhYmxlKGhjb2RlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1Zkxlbmd0aChjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSAmIDYzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVmQ29kZShjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA+PiA2XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVmQnVpbGREZWNUYWJsZShoY29kZSwgaW0sIGlNLCBoZGVjb2QpIHtcbiAgICAgIGZvciAoOyBpbSA8PSBpTTsgaW0rKykge1xuICAgICAgICB2YXIgYyA9IGh1ZkNvZGUoaGNvZGVbaW1dKVxuICAgICAgICB2YXIgbCA9IGh1Zkxlbmd0aChoY29kZVtpbV0pXG5cbiAgICAgICAgaWYgKGMgPj4gbCkge1xuICAgICAgICAgIHRocm93ICdJbnZhbGlkIHRhYmxlIGVudHJ5J1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGwgPiBIVUZfREVDQklUUykge1xuICAgICAgICAgIHZhciBwbCA9IGhkZWNvZFtjID4+IChsIC0gSFVGX0RFQ0JJVFMpXVxuXG4gICAgICAgICAgaWYgKHBsLmxlbikge1xuICAgICAgICAgICAgdGhyb3cgJ0ludmFsaWQgdGFibGUgZW50cnknXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGwubGl0KytcblxuICAgICAgICAgIGlmIChwbC5wKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHBsLnBcbiAgICAgICAgICAgIHBsLnAgPSBuZXcgQXJyYXkocGwubGl0KVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsLmxpdCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICBwbC5wW2ldID0gcFtpXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwbC5wID0gbmV3IEFycmF5KDEpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGwucFtwbC5saXQgLSAxXSA9IGltXG4gICAgICAgIH0gZWxzZSBpZiAobCkge1xuICAgICAgICAgIHZhciBwbE9mZnNldCA9IDBcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAxIDw8IChIVUZfREVDQklUUyAtIGwpOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgcGwgPSBoZGVjb2RbKGMgPDwgKEhVRl9ERUNCSVRTIC0gbCkpICsgcGxPZmZzZXRdXG5cbiAgICAgICAgICAgIGlmIChwbC5sZW4gfHwgcGwucCkge1xuICAgICAgICAgICAgICB0aHJvdyAnSW52YWxpZCB0YWJsZSBlbnRyeSdcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGwubGVuID0gbFxuICAgICAgICAgICAgcGwubGl0ID0gaW1cblxuICAgICAgICAgICAgcGxPZmZzZXQrK1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGdldENoYXJSZXR1cm4gPSB7IGM6IDAsIGxjOiAwIH1cblxuICAgIGZ1bmN0aW9uIGdldENoYXIoYywgbGMsIHVJbnQ4QXJyYXksIGluT2Zmc2V0KSB7XG4gICAgICBjID0gKGMgPDwgOCkgfCBwYXJzZVVpbnQ4QXJyYXkodUludDhBcnJheSwgaW5PZmZzZXQpXG4gICAgICBsYyArPSA4XG5cbiAgICAgIGdldENoYXJSZXR1cm4uYyA9IGNcbiAgICAgIGdldENoYXJSZXR1cm4ubGMgPSBsY1xuICAgIH1cblxuICAgIGNvbnN0IGdldENvZGVSZXR1cm4gPSB7IGM6IDAsIGxjOiAwIH1cblxuICAgIGZ1bmN0aW9uIGdldENvZGUocG8sIHJsYywgYywgbGMsIHVJbnQ4QXJyYXksIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBvdXRCdWZmZXIsIG91dEJ1ZmZlck9mZnNldCwgb3V0QnVmZmVyRW5kT2Zmc2V0KSB7XG4gICAgICBpZiAocG8gPT0gcmxjKSB7XG4gICAgICAgIGlmIChsYyA8IDgpIHtcbiAgICAgICAgICBnZXRDaGFyKGMsIGxjLCB1SW50OEFycmF5LCBpbk9mZnNldClcbiAgICAgICAgICBjID0gZ2V0Q2hhclJldHVybi5jXG4gICAgICAgICAgbGMgPSBnZXRDaGFyUmV0dXJuLmxjXG4gICAgICAgIH1cblxuICAgICAgICBsYyAtPSA4XG5cbiAgICAgICAgdmFyIGNzID0gYyA+PiBsY1xuICAgICAgICB2YXIgY3MgPSBuZXcgVWludDhBcnJheShbY3NdKVswXVxuXG4gICAgICAgIGlmIChvdXRCdWZmZXJPZmZzZXQudmFsdWUgKyBjcyA+IG91dEJ1ZmZlckVuZE9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHMgPSBvdXRCdWZmZXJbb3V0QnVmZmVyT2Zmc2V0LnZhbHVlIC0gMV1cblxuICAgICAgICB3aGlsZSAoY3MtLSA+IDApIHtcbiAgICAgICAgICBvdXRCdWZmZXJbb3V0QnVmZmVyT2Zmc2V0LnZhbHVlKytdID0gc1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG91dEJ1ZmZlck9mZnNldC52YWx1ZSA8IG91dEJ1ZmZlckVuZE9mZnNldCkge1xuICAgICAgICBvdXRCdWZmZXJbb3V0QnVmZmVyT2Zmc2V0LnZhbHVlKytdID0gcG9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBnZXRDb2RlUmV0dXJuLmMgPSBjXG4gICAgICBnZXRDb2RlUmV0dXJuLmxjID0gbGNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVSW50MTYodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmIDB4ZmZmZlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEludDE2KHZhbHVlKSB7XG4gICAgICB2YXIgcmVmID0gVUludDE2KHZhbHVlKVxuICAgICAgcmV0dXJuIHJlZiA+IDB4N2ZmZiA/IHJlZiAtIDB4MTAwMDAgOiByZWZcbiAgICB9XG5cbiAgICBjb25zdCB3ZGVjMTRSZXR1cm4gPSB7IGE6IDAsIGI6IDAgfVxuXG4gICAgZnVuY3Rpb24gd2RlYzE0KGwsIGgpIHtcbiAgICAgIHZhciBscyA9IEludDE2KGwpXG4gICAgICB2YXIgaHMgPSBJbnQxNihoKVxuXG4gICAgICB2YXIgaGkgPSBoc1xuICAgICAgdmFyIGFpID0gbHMgKyAoaGkgJiAxKSArIChoaSA+PiAxKVxuXG4gICAgICB2YXIgYXMgPSBhaVxuICAgICAgdmFyIGJzID0gYWkgLSBoaVxuXG4gICAgICB3ZGVjMTRSZXR1cm4uYSA9IGFzXG4gICAgICB3ZGVjMTRSZXR1cm4uYiA9IGJzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2RlYzE2KGwsIGgpIHtcbiAgICAgIHZhciBtID0gVUludDE2KGwpXG4gICAgICB2YXIgZCA9IFVJbnQxNihoKVxuXG4gICAgICB2YXIgYmIgPSAobSAtIChkID4+IDEpKSAmIE1PRF9NQVNLXG4gICAgICB2YXIgYWEgPSAoZCArIGJiIC0gQV9PRkZTRVQpICYgTU9EX01BU0tcblxuICAgICAgd2RlYzE0UmV0dXJuLmEgPSBhYVxuICAgICAgd2RlYzE0UmV0dXJuLmIgPSBiYlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhdjJEZWNvZGUoYnVmZmVyLCBqLCBueCwgb3gsIG55LCBveSwgbXgpIHtcbiAgICAgIHZhciB3MTQgPSBteCA8IDEgPDwgMTRcbiAgICAgIHZhciBuID0gbnggPiBueSA/IG55IDogbnhcbiAgICAgIHZhciBwID0gMVxuICAgICAgdmFyIHAyXG5cbiAgICAgIHdoaWxlIChwIDw9IG4pIHAgPDw9IDFcblxuICAgICAgcCA+Pj0gMVxuICAgICAgcDIgPSBwXG4gICAgICBwID4+PSAxXG5cbiAgICAgIHdoaWxlIChwID49IDEpIHtcbiAgICAgICAgdmFyIHB5ID0gMFxuICAgICAgICB2YXIgZXkgPSBweSArIG95ICogKG55IC0gcDIpXG4gICAgICAgIHZhciBveTEgPSBveSAqIHBcbiAgICAgICAgdmFyIG95MiA9IG95ICogcDJcbiAgICAgICAgdmFyIG94MSA9IG94ICogcFxuICAgICAgICB2YXIgb3gyID0gb3ggKiBwMlxuICAgICAgICB2YXIgaTAwLCBpMDEsIGkxMCwgaTExXG5cbiAgICAgICAgZm9yICg7IHB5IDw9IGV5OyBweSArPSBveTIpIHtcbiAgICAgICAgICB2YXIgcHggPSBweVxuICAgICAgICAgIHZhciBleCA9IHB5ICsgb3ggKiAobnggLSBwMilcblxuICAgICAgICAgIGZvciAoOyBweCA8PSBleDsgcHggKz0gb3gyKSB7XG4gICAgICAgICAgICB2YXIgcDAxID0gcHggKyBveDFcbiAgICAgICAgICAgIHZhciBwMTAgPSBweCArIG95MVxuICAgICAgICAgICAgdmFyIHAxMSA9IHAxMCArIG94MVxuXG4gICAgICAgICAgICBpZiAodzE0KSB7XG4gICAgICAgICAgICAgIHdkZWMxNChidWZmZXJbcHggKyBqXSwgYnVmZmVyW3AxMCArIGpdKVxuXG4gICAgICAgICAgICAgIGkwMCA9IHdkZWMxNFJldHVybi5hXG4gICAgICAgICAgICAgIGkxMCA9IHdkZWMxNFJldHVybi5iXG5cbiAgICAgICAgICAgICAgd2RlYzE0KGJ1ZmZlcltwMDEgKyBqXSwgYnVmZmVyW3AxMSArIGpdKVxuXG4gICAgICAgICAgICAgIGkwMSA9IHdkZWMxNFJldHVybi5hXG4gICAgICAgICAgICAgIGkxMSA9IHdkZWMxNFJldHVybi5iXG5cbiAgICAgICAgICAgICAgd2RlYzE0KGkwMCwgaTAxKVxuXG4gICAgICAgICAgICAgIGJ1ZmZlcltweCArIGpdID0gd2RlYzE0UmV0dXJuLmFcbiAgICAgICAgICAgICAgYnVmZmVyW3AwMSArIGpdID0gd2RlYzE0UmV0dXJuLmJcblxuICAgICAgICAgICAgICB3ZGVjMTQoaTEwLCBpMTEpXG5cbiAgICAgICAgICAgICAgYnVmZmVyW3AxMCArIGpdID0gd2RlYzE0UmV0dXJuLmFcbiAgICAgICAgICAgICAgYnVmZmVyW3AxMSArIGpdID0gd2RlYzE0UmV0dXJuLmJcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdkZWMxNihidWZmZXJbcHggKyBqXSwgYnVmZmVyW3AxMCArIGpdKVxuXG4gICAgICAgICAgICAgIGkwMCA9IHdkZWMxNFJldHVybi5hXG4gICAgICAgICAgICAgIGkxMCA9IHdkZWMxNFJldHVybi5iXG5cbiAgICAgICAgICAgICAgd2RlYzE2KGJ1ZmZlcltwMDEgKyBqXSwgYnVmZmVyW3AxMSArIGpdKVxuXG4gICAgICAgICAgICAgIGkwMSA9IHdkZWMxNFJldHVybi5hXG4gICAgICAgICAgICAgIGkxMSA9IHdkZWMxNFJldHVybi5iXG5cbiAgICAgICAgICAgICAgd2RlYzE2KGkwMCwgaTAxKVxuXG4gICAgICAgICAgICAgIGJ1ZmZlcltweCArIGpdID0gd2RlYzE0UmV0dXJuLmFcbiAgICAgICAgICAgICAgYnVmZmVyW3AwMSArIGpdID0gd2RlYzE0UmV0dXJuLmJcblxuICAgICAgICAgICAgICB3ZGVjMTYoaTEwLCBpMTEpXG5cbiAgICAgICAgICAgICAgYnVmZmVyW3AxMCArIGpdID0gd2RlYzE0UmV0dXJuLmFcbiAgICAgICAgICAgICAgYnVmZmVyW3AxMSArIGpdID0gd2RlYzE0UmV0dXJuLmJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobnggJiBwKSB7XG4gICAgICAgICAgICB2YXIgcDEwID0gcHggKyBveTFcblxuICAgICAgICAgICAgaWYgKHcxNCkgd2RlYzE0KGJ1ZmZlcltweCArIGpdLCBidWZmZXJbcDEwICsgal0pXG4gICAgICAgICAgICBlbHNlIHdkZWMxNihidWZmZXJbcHggKyBqXSwgYnVmZmVyW3AxMCArIGpdKVxuXG4gICAgICAgICAgICBpMDAgPSB3ZGVjMTRSZXR1cm4uYVxuICAgICAgICAgICAgYnVmZmVyW3AxMCArIGpdID0gd2RlYzE0UmV0dXJuLmJcblxuICAgICAgICAgICAgYnVmZmVyW3B4ICsgal0gPSBpMDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnkgJiBwKSB7XG4gICAgICAgICAgdmFyIHB4ID0gcHlcbiAgICAgICAgICB2YXIgZXggPSBweSArIG94ICogKG54IC0gcDIpXG5cbiAgICAgICAgICBmb3IgKDsgcHggPD0gZXg7IHB4ICs9IG94Mikge1xuICAgICAgICAgICAgdmFyIHAwMSA9IHB4ICsgb3gxXG5cbiAgICAgICAgICAgIGlmICh3MTQpIHdkZWMxNChidWZmZXJbcHggKyBqXSwgYnVmZmVyW3AwMSArIGpdKVxuICAgICAgICAgICAgZWxzZSB3ZGVjMTYoYnVmZmVyW3B4ICsgal0sIGJ1ZmZlcltwMDEgKyBqXSlcblxuICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmFcbiAgICAgICAgICAgIGJ1ZmZlcltwMDEgKyBqXSA9IHdkZWMxNFJldHVybi5iXG5cbiAgICAgICAgICAgIGJ1ZmZlcltweCArIGpdID0gaTAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcDIgPSBwXG4gICAgICAgIHAgPj49IDFcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHB5XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVmRGVjb2RlKFxuICAgICAgZW5jb2RpbmdUYWJsZSxcbiAgICAgIGRlY29kaW5nVGFibGUsXG4gICAgICB1SW50OEFycmF5LFxuICAgICAgaW5EYXRhVmlldyxcbiAgICAgIGluT2Zmc2V0LFxuICAgICAgbmksXG4gICAgICBybGMsXG4gICAgICBubyxcbiAgICAgIG91dEJ1ZmZlcixcbiAgICAgIG91dE9mZnNldCxcbiAgICApIHtcbiAgICAgIHZhciBjID0gMFxuICAgICAgdmFyIGxjID0gMFxuICAgICAgdmFyIG91dEJ1ZmZlckVuZE9mZnNldCA9IG5vXG4gICAgICB2YXIgaW5PZmZzZXRFbmQgPSBNYXRoLnRydW5jKGluT2Zmc2V0LnZhbHVlICsgKG5pICsgNykgLyA4KVxuXG4gICAgICB3aGlsZSAoaW5PZmZzZXQudmFsdWUgPCBpbk9mZnNldEVuZCkge1xuICAgICAgICBnZXRDaGFyKGMsIGxjLCB1SW50OEFycmF5LCBpbk9mZnNldClcblxuICAgICAgICBjID0gZ2V0Q2hhclJldHVybi5jXG4gICAgICAgIGxjID0gZ2V0Q2hhclJldHVybi5sY1xuXG4gICAgICAgIHdoaWxlIChsYyA+PSBIVUZfREVDQklUUykge1xuICAgICAgICAgIHZhciBpbmRleCA9IChjID4+IChsYyAtIEhVRl9ERUNCSVRTKSkgJiBIVUZfREVDTUFTS1xuICAgICAgICAgIHZhciBwbCA9IGRlY29kaW5nVGFibGVbaW5kZXhdXG5cbiAgICAgICAgICBpZiAocGwubGVuKSB7XG4gICAgICAgICAgICBsYyAtPSBwbC5sZW5cblxuICAgICAgICAgICAgZ2V0Q29kZShwbC5saXQsIHJsYywgYywgbGMsIHVJbnQ4QXJyYXksIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBvdXRCdWZmZXIsIG91dE9mZnNldCwgb3V0QnVmZmVyRW5kT2Zmc2V0KVxuXG4gICAgICAgICAgICBjID0gZ2V0Q29kZVJldHVybi5jXG4gICAgICAgICAgICBsYyA9IGdldENvZGVSZXR1cm4ubGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFwbC5wKSB7XG4gICAgICAgICAgICAgIHRocm93ICdodWZEZWNvZGUgaXNzdWVzJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgalxuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGwubGl0OyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBodWZMZW5ndGgoZW5jb2RpbmdUYWJsZVtwbC5wW2pdXSlcblxuICAgICAgICAgICAgICB3aGlsZSAobGMgPCBsICYmIGluT2Zmc2V0LnZhbHVlIDwgaW5PZmZzZXRFbmQpIHtcbiAgICAgICAgICAgICAgICBnZXRDaGFyKGMsIGxjLCB1SW50OEFycmF5LCBpbk9mZnNldClcblxuICAgICAgICAgICAgICAgIGMgPSBnZXRDaGFyUmV0dXJuLmNcbiAgICAgICAgICAgICAgICBsYyA9IGdldENoYXJSZXR1cm4ubGNcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChsYyA+PSBsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGh1ZkNvZGUoZW5jb2RpbmdUYWJsZVtwbC5wW2pdXSkgPT0gKChjID4+IChsYyAtIGwpKSAmICgoMSA8PCBsKSAtIDEpKSkge1xuICAgICAgICAgICAgICAgICAgbGMgLT0gbFxuXG4gICAgICAgICAgICAgICAgICBnZXRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBwbC5wW2pdLFxuICAgICAgICAgICAgICAgICAgICBybGMsXG4gICAgICAgICAgICAgICAgICAgIGMsXG4gICAgICAgICAgICAgICAgICAgIGxjLFxuICAgICAgICAgICAgICAgICAgICB1SW50OEFycmF5LFxuICAgICAgICAgICAgICAgICAgICBpbkRhdGFWaWV3LFxuICAgICAgICAgICAgICAgICAgICBpbk9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb3V0QnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICBvdXRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIG91dEJ1ZmZlckVuZE9mZnNldCxcbiAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgYyA9IGdldENvZGVSZXR1cm4uY1xuICAgICAgICAgICAgICAgICAgbGMgPSBnZXRDb2RlUmV0dXJuLmxjXG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqID09IHBsLmxpdCkge1xuICAgICAgICAgICAgICB0aHJvdyAnaHVmRGVjb2RlIGlzc3VlcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAoOCAtIG5pKSAmIDdcblxuICAgICAgYyA+Pj0gaVxuICAgICAgbGMgLT0gaVxuXG4gICAgICB3aGlsZSAobGMgPiAwKSB7XG4gICAgICAgIHZhciBwbCA9IGRlY29kaW5nVGFibGVbKGMgPDwgKEhVRl9ERUNCSVRTIC0gbGMpKSAmIEhVRl9ERUNNQVNLXVxuXG4gICAgICAgIGlmIChwbC5sZW4pIHtcbiAgICAgICAgICBsYyAtPSBwbC5sZW5cblxuICAgICAgICAgIGdldENvZGUocGwubGl0LCBybGMsIGMsIGxjLCB1SW50OEFycmF5LCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgb3V0QnVmZmVyLCBvdXRPZmZzZXQsIG91dEJ1ZmZlckVuZE9mZnNldClcblxuICAgICAgICAgIGMgPSBnZXRDb2RlUmV0dXJuLmNcbiAgICAgICAgICBsYyA9IGdldENvZGVSZXR1cm4ubGNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyAnaHVmRGVjb2RlIGlzc3VlcydcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1ZlVuY29tcHJlc3ModUludDhBcnJheSwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5Db21wcmVzc2VkLCBvdXRCdWZmZXIsIG5SYXcpIHtcbiAgICAgIHZhciBvdXRPZmZzZXQgPSB7IHZhbHVlOiAwIH1cbiAgICAgIHZhciBpbml0aWFsSW5PZmZzZXQgPSBpbk9mZnNldC52YWx1ZVxuXG4gICAgICB2YXIgaW0gPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldClcbiAgICAgIHZhciBpTSA9IHBhcnNlVWludDMyKGluRGF0YVZpZXcsIGluT2Zmc2V0KVxuXG4gICAgICBpbk9mZnNldC52YWx1ZSArPSA0XG5cbiAgICAgIHZhciBuQml0cyA9IHBhcnNlVWludDMyKGluRGF0YVZpZXcsIGluT2Zmc2V0KVxuXG4gICAgICBpbk9mZnNldC52YWx1ZSArPSA0XG5cbiAgICAgIGlmIChpbSA8IDAgfHwgaW0gPj0gSFVGX0VOQ1NJWkUgfHwgaU0gPCAwIHx8IGlNID49IEhVRl9FTkNTSVpFKSB7XG4gICAgICAgIHRocm93ICdTb21ldGhpbmcgd3Jvbmcgd2l0aCBIVUZfRU5DU0laRSdcbiAgICAgIH1cblxuICAgICAgdmFyIGZyZXEgPSBuZXcgQXJyYXkoSFVGX0VOQ1NJWkUpXG4gICAgICB2YXIgaGRlYyA9IG5ldyBBcnJheShIVUZfREVDU0laRSlcblxuICAgICAgaHVmQ2xlYXJEZWNUYWJsZShoZGVjKVxuXG4gICAgICB2YXIgbmkgPSBuQ29tcHJlc3NlZCAtIChpbk9mZnNldC52YWx1ZSAtIGluaXRpYWxJbk9mZnNldClcblxuICAgICAgaHVmVW5wYWNrRW5jVGFibGUodUludDhBcnJheSwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5pLCBpbSwgaU0sIGZyZXEpXG5cbiAgICAgIGlmIChuQml0cyA+IDggKiAobkNvbXByZXNzZWQgLSAoaW5PZmZzZXQudmFsdWUgLSBpbml0aWFsSW5PZmZzZXQpKSkge1xuICAgICAgICB0aHJvdyAnU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5jb21wcmVzcydcbiAgICAgIH1cblxuICAgICAgaHVmQnVpbGREZWNUYWJsZShmcmVxLCBpbSwgaU0sIGhkZWMpXG5cbiAgICAgIGh1ZkRlY29kZShmcmVxLCBoZGVjLCB1SW50OEFycmF5LCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbkJpdHMsIGlNLCBuUmF3LCBvdXRCdWZmZXIsIG91dE9mZnNldClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseUx1dChsdXQsIGRhdGEsIG5EYXRhKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5EYXRhOyArK2kpIHtcbiAgICAgICAgZGF0YVtpXSA9IGx1dFtkYXRhW2ldXVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZWRpY3Rvcihzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIHQgPSAxOyB0IDwgc291cmNlLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIHZhciBkID0gc291cmNlW3QgLSAxXSArIHNvdXJjZVt0XSAtIDEyOFxuICAgICAgICBzb3VyY2VbdF0gPSBkXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW50ZXJsZWF2ZVNjYWxhcihzb3VyY2UsIG91dCkge1xuICAgICAgdmFyIHQxID0gMFxuICAgICAgdmFyIHQyID0gTWF0aC5mbG9vcigoc291cmNlLmxlbmd0aCArIDEpIC8gMilcbiAgICAgIHZhciBzID0gMFxuICAgICAgdmFyIHN0b3AgPSBzb3VyY2UubGVuZ3RoIC0gMVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAocyA+IHN0b3ApIGJyZWFrXG4gICAgICAgIG91dFtzKytdID0gc291cmNlW3QxKytdXG5cbiAgICAgICAgaWYgKHMgPiBzdG9wKSBicmVha1xuICAgICAgICBvdXRbcysrXSA9IHNvdXJjZVt0MisrXVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZVJ1bkxlbmd0aChzb3VyY2UpIHtcbiAgICAgIHZhciBzaXplID0gc291cmNlLmJ5dGVMZW5ndGhcbiAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXkoKVxuICAgICAgdmFyIHAgPSAwXG5cbiAgICAgIHZhciByZWFkZXIgPSBuZXcgRGF0YVZpZXcoc291cmNlKVxuXG4gICAgICB3aGlsZSAoc2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIGwgPSByZWFkZXIuZ2V0SW50OChwKyspXG5cbiAgICAgICAgaWYgKGwgPCAwKSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gLWxcbiAgICAgICAgICBzaXplIC09IGNvdW50ICsgMVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBvdXQucHVzaChyZWFkZXIuZ2V0VWludDgocCsrKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gbFxuICAgICAgICAgIHNpemUgLT0gMlxuXG4gICAgICAgICAgdmFyIHZhbHVlID0gcmVhZGVyLmdldFVpbnQ4KHArKylcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9zc3lEY3REZWNvZGUoY3NjU2V0LCByb3dQdHJzLCBjaGFubmVsRGF0YSwgYWNCdWZmZXIsIGRjQnVmZmVyLCBvdXRCdWZmZXIpIHtcbiAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhvdXRCdWZmZXIuYnVmZmVyKVxuXG4gICAgICB2YXIgd2lkdGggPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4WzBdXS53aWR0aFxuICAgICAgdmFyIGhlaWdodCA9IGNoYW5uZWxEYXRhW2NzY1NldC5pZHhbMF1dLmhlaWdodFxuXG4gICAgICB2YXIgbnVtQ29tcCA9IDNcblxuICAgICAgdmFyIG51bUZ1bGxCbG9ja3NYID0gTWF0aC5mbG9vcih3aWR0aCAvIDguMClcbiAgICAgIHZhciBudW1CbG9ja3NYID0gTWF0aC5jZWlsKHdpZHRoIC8gOC4wKVxuICAgICAgdmFyIG51bUJsb2Nrc1kgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gOC4wKVxuICAgICAgdmFyIGxlZnRvdmVyWCA9IHdpZHRoIC0gKG51bUJsb2Nrc1ggLSAxKSAqIDhcbiAgICAgIHZhciBsZWZ0b3ZlclkgPSBoZWlnaHQgLSAobnVtQmxvY2tzWSAtIDEpICogOFxuXG4gICAgICB2YXIgY3VyckFjQ29tcCA9IHsgdmFsdWU6IDAgfVxuICAgICAgdmFyIGN1cnJEY0NvbXAgPSBuZXcgQXJyYXkobnVtQ29tcClcbiAgICAgIHZhciBkY3REYXRhID0gbmV3IEFycmF5KG51bUNvbXApXG4gICAgICB2YXIgaGFsZlppZ0Jsb2NrID0gbmV3IEFycmF5KG51bUNvbXApXG4gICAgICB2YXIgcm93QmxvY2sgPSBuZXcgQXJyYXkobnVtQ29tcClcbiAgICAgIHZhciByb3dPZmZzZXRzID0gbmV3IEFycmF5KG51bUNvbXApXG5cbiAgICAgIGZvciAobGV0IGNvbXAgPSAwOyBjb21wIDwgbnVtQ29tcDsgKytjb21wKSB7XG4gICAgICAgIHJvd09mZnNldHNbY29tcF0gPSByb3dQdHJzW2NzY1NldC5pZHhbY29tcF1dXG4gICAgICAgIGN1cnJEY0NvbXBbY29tcF0gPSBjb21wIDwgMSA/IDAgOiBjdXJyRGNDb21wW2NvbXAgLSAxXSArIG51bUJsb2Nrc1ggKiBudW1CbG9ja3NZXG4gICAgICAgIGRjdERhdGFbY29tcF0gPSBuZXcgRmxvYXQzMkFycmF5KDY0KVxuICAgICAgICBoYWxmWmlnQmxvY2tbY29tcF0gPSBuZXcgVWludDE2QXJyYXkoNjQpXG4gICAgICAgIHJvd0Jsb2NrW2NvbXBdID0gbmV3IFVpbnQxNkFycmF5KG51bUJsb2Nrc1ggKiA2NClcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgYmxvY2t5ID0gMDsgYmxvY2t5IDwgbnVtQmxvY2tzWTsgKytibG9ja3kpIHtcbiAgICAgICAgdmFyIG1heFkgPSA4XG5cbiAgICAgICAgaWYgKGJsb2NreSA9PSBudW1CbG9ja3NZIC0gMSkgbWF4WSA9IGxlZnRvdmVyWVxuXG4gICAgICAgIHZhciBtYXhYID0gOFxuXG4gICAgICAgIGZvciAobGV0IGJsb2NreCA9IDA7IGJsb2NreCA8IG51bUJsb2Nrc1g7ICsrYmxvY2t4KSB7XG4gICAgICAgICAgaWYgKGJsb2NreCA9PSBudW1CbG9ja3NYIC0gMSkgbWF4WCA9IGxlZnRvdmVyWFxuXG4gICAgICAgICAgZm9yIChsZXQgY29tcCA9IDA7IGNvbXAgPCBudW1Db21wOyArK2NvbXApIHtcbiAgICAgICAgICAgIGhhbGZaaWdCbG9ja1tjb21wXS5maWxsKDApXG5cbiAgICAgICAgICAgIC8vIHNldCBibG9jayBEQyBjb21wb25lbnRcbiAgICAgICAgICAgIGhhbGZaaWdCbG9ja1tjb21wXVswXSA9IGRjQnVmZmVyW2N1cnJEY0NvbXBbY29tcF0rK11cbiAgICAgICAgICAgIC8vIHNldCBibG9jayBBQyBjb21wb25lbnRzXG4gICAgICAgICAgICB1blJsZUFDKGN1cnJBY0NvbXAsIGFjQnVmZmVyLCBoYWxmWmlnQmxvY2tbY29tcF0pXG5cbiAgICAgICAgICAgIC8vIFVuWmlnWmFnIGJsb2NrIHRvIGZsb2F0XG4gICAgICAgICAgICB1blppZ1phZyhoYWxmWmlnQmxvY2tbY29tcF0sIGRjdERhdGFbY29tcF0pXG4gICAgICAgICAgICAvLyBkZWNvZGUgZmxvYXQgZGN0XG4gICAgICAgICAgICBkY3RJbnZlcnNlKGRjdERhdGFbY29tcF0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG51bUNvbXAgPT0gMykge1xuICAgICAgICAgICAgY3NjNzA5SW52ZXJzZShkY3REYXRhKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAobGV0IGNvbXAgPSAwOyBjb21wIDwgbnVtQ29tcDsgKytjb21wKSB7XG4gICAgICAgICAgICBjb252ZXJ0VG9IYWxmKGRjdERhdGFbY29tcF0sIHJvd0Jsb2NrW2NvbXBdLCBibG9ja3ggKiA2NClcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gYmxvY2t4XG5cbiAgICAgICAgbGV0IG9mZnNldCA9IDBcblxuICAgICAgICBmb3IgKGxldCBjb21wID0gMDsgY29tcCA8IG51bUNvbXA7ICsrY29tcCkge1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4W2NvbXBdXS50eXBlXG5cbiAgICAgICAgICBmb3IgKGxldCB5ID0gOCAqIGJsb2NreTsgeSA8IDggKiBibG9ja3kgKyBtYXhZOyArK3kpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHJvd09mZnNldHNbY29tcF1beV1cblxuICAgICAgICAgICAgZm9yIChsZXQgYmxvY2t4ID0gMDsgYmxvY2t4IDwgbnVtRnVsbEJsb2Nrc1g7ICsrYmxvY2t4KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNyYyA9IGJsb2NreCAqIDY0ICsgKHkgJiAweDcpICogOFxuXG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQgKyAwICogSU5UMTZfU0laRSAqIHR5cGUsIHJvd0Jsb2NrW2NvbXBdW3NyYyArIDBdLCB0cnVlKVxuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSAqIElOVDE2X1NJWkUgKiB0eXBlLCByb3dCbG9ja1tjb21wXVtzcmMgKyAxXSwgdHJ1ZSlcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldCArIDIgKiBJTlQxNl9TSVpFICogdHlwZSwgcm93QmxvY2tbY29tcF1bc3JjICsgMl0sIHRydWUpXG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQgKyAzICogSU5UMTZfU0laRSAqIHR5cGUsIHJvd0Jsb2NrW2NvbXBdW3NyYyArIDNdLCB0cnVlKVxuXG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQgKyA0ICogSU5UMTZfU0laRSAqIHR5cGUsIHJvd0Jsb2NrW2NvbXBdW3NyYyArIDRdLCB0cnVlKVxuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0ICsgNSAqIElOVDE2X1NJWkUgKiB0eXBlLCByb3dCbG9ja1tjb21wXVtzcmMgKyA1XSwgdHJ1ZSlcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldCArIDYgKiBJTlQxNl9TSVpFICogdHlwZSwgcm93QmxvY2tbY29tcF1bc3JjICsgNl0sIHRydWUpXG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQgKyA3ICogSU5UMTZfU0laRSAqIHR5cGUsIHJvd0Jsb2NrW2NvbXBdW3NyYyArIDddLCB0cnVlKVxuXG4gICAgICAgICAgICAgIG9mZnNldCArPSA4ICogSU5UMTZfU0laRSAqIHR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBoYW5kbGUgcGFydGlhbCBYIGJsb2Nrc1xuICAgICAgICAgIGlmIChudW1GdWxsQmxvY2tzWCAhPSBudW1CbG9ja3NYKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gOCAqIGJsb2NreTsgeSA8IDggKiBibG9ja3kgKyBtYXhZOyArK3kpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcm93T2Zmc2V0c1tjb21wXVt5XSArIDggKiBudW1GdWxsQmxvY2tzWCAqIElOVDE2X1NJWkUgKiB0eXBlXG4gICAgICAgICAgICAgIGNvbnN0IHNyYyA9IG51bUZ1bGxCbG9ja3NYICogNjQgKyAoeSAmIDB4NykgKiA4XG5cbiAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBtYXhYOyArK3gpIHtcbiAgICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0ICsgeCAqIElOVDE2X1NJWkUgKiB0eXBlLCByb3dCbG9ja1tjb21wXVtzcmMgKyB4XSwgdHJ1ZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBjb21wXG4gICAgICB9IC8vIGJsb2NreVxuXG4gICAgICB2YXIgaGFsZlJvdyA9IG5ldyBVaW50MTZBcnJheSh3aWR0aClcbiAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhvdXRCdWZmZXIuYnVmZmVyKVxuXG4gICAgICAvLyBjb252ZXJ0IGNoYW5uZWxzIGJhY2sgdG8gZmxvYXQsIGlmIG5lZWRlZFxuICAgICAgZm9yICh2YXIgY29tcCA9IDA7IGNvbXAgPCBudW1Db21wOyArK2NvbXApIHtcbiAgICAgICAgY2hhbm5lbERhdGFbY3NjU2V0LmlkeFtjb21wXV0uZGVjb2RlZCA9IHRydWVcbiAgICAgICAgdmFyIHR5cGUgPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4W2NvbXBdXS50eXBlXG5cbiAgICAgICAgaWYgKGNoYW5uZWxEYXRhW2NvbXBdLnR5cGUgIT0gMikgY29udGludWVcblxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcm93T2Zmc2V0c1tjb21wXVt5XVxuXG4gICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgICAgICBoYWxmUm93W3hdID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIHggKiBJTlQxNl9TSVpFICogdHlwZSwgdHJ1ZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldEZsb2F0MzIob2Zmc2V0ICsgeCAqIElOVDE2X1NJWkUgKiB0eXBlLCBkZWNvZGVGbG9hdDE2KGhhbGZSb3dbeF0pLCB0cnVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuUmxlQUMoY3VyckFjQ29tcCwgYWNCdWZmZXIsIGhhbGZaaWdCbG9jaykge1xuICAgICAgdmFyIGFjVmFsdWVcbiAgICAgIHZhciBkY3RDb21wID0gMVxuXG4gICAgICB3aGlsZSAoZGN0Q29tcCA8IDY0KSB7XG4gICAgICAgIGFjVmFsdWUgPSBhY0J1ZmZlcltjdXJyQWNDb21wLnZhbHVlXVxuXG4gICAgICAgIGlmIChhY1ZhbHVlID09IDB4ZmYwMCkge1xuICAgICAgICAgIGRjdENvbXAgPSA2NFxuICAgICAgICB9IGVsc2UgaWYgKGFjVmFsdWUgPj4gOCA9PSAweGZmKSB7XG4gICAgICAgICAgZGN0Q29tcCArPSBhY1ZhbHVlICYgMHhmZlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbGZaaWdCbG9ja1tkY3RDb21wXSA9IGFjVmFsdWVcbiAgICAgICAgICBkY3RDb21wKytcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJBY0NvbXAudmFsdWUrK1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuWmlnWmFnKHNyYywgZHN0KSB7XG4gICAgICBkc3RbMF0gPSBkZWNvZGVGbG9hdDE2KHNyY1swXSlcbiAgICAgIGRzdFsxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzFdKVxuICAgICAgZHN0WzJdID0gZGVjb2RlRmxvYXQxNihzcmNbNV0pXG4gICAgICBkc3RbM10gPSBkZWNvZGVGbG9hdDE2KHNyY1s2XSlcbiAgICAgIGRzdFs0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzE0XSlcbiAgICAgIGRzdFs1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzE1XSlcbiAgICAgIGRzdFs2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI3XSlcbiAgICAgIGRzdFs3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI4XSlcbiAgICAgIGRzdFs4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzJdKVxuICAgICAgZHN0WzldID0gZGVjb2RlRmxvYXQxNihzcmNbNF0pXG5cbiAgICAgIGRzdFsxMF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s3XSlcbiAgICAgIGRzdFsxMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxM10pXG4gICAgICBkc3RbMTJdID0gZGVjb2RlRmxvYXQxNihzcmNbMTZdKVxuICAgICAgZHN0WzEzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzI2XSlcbiAgICAgIGRzdFsxNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syOV0pXG4gICAgICBkc3RbMTVdID0gZGVjb2RlRmxvYXQxNihzcmNbNDJdKVxuICAgICAgZHN0WzE2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzNdKVxuICAgICAgZHN0WzE3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzhdKVxuICAgICAgZHN0WzE4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzEyXSlcbiAgICAgIGRzdFsxOV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxN10pXG5cbiAgICAgIGRzdFsyMF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syNV0pXG4gICAgICBkc3RbMjFdID0gZGVjb2RlRmxvYXQxNihzcmNbMzBdKVxuICAgICAgZHN0WzIyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQxXSlcbiAgICAgIGRzdFsyM10gPSBkZWNvZGVGbG9hdDE2KHNyY1s0M10pXG4gICAgICBkc3RbMjRdID0gZGVjb2RlRmxvYXQxNihzcmNbOV0pXG4gICAgICBkc3RbMjVdID0gZGVjb2RlRmxvYXQxNihzcmNbMTFdKVxuICAgICAgZHN0WzI2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzE4XSlcbiAgICAgIGRzdFsyN10gPSBkZWNvZGVGbG9hdDE2KHNyY1syNF0pXG4gICAgICBkc3RbMjhdID0gZGVjb2RlRmxvYXQxNihzcmNbMzFdKVxuICAgICAgZHN0WzI5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQwXSlcblxuICAgICAgZHN0WzMwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ0XSlcbiAgICAgIGRzdFszMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1M10pXG4gICAgICBkc3RbMzJdID0gZGVjb2RlRmxvYXQxNihzcmNbMTBdKVxuICAgICAgZHN0WzMzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzE5XSlcbiAgICAgIGRzdFszNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syM10pXG4gICAgICBkc3RbMzVdID0gZGVjb2RlRmxvYXQxNihzcmNbMzJdKVxuICAgICAgZHN0WzM2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM5XSlcbiAgICAgIGRzdFszN10gPSBkZWNvZGVGbG9hdDE2KHNyY1s0NV0pXG4gICAgICBkc3RbMzhdID0gZGVjb2RlRmxvYXQxNihzcmNbNTJdKVxuICAgICAgZHN0WzM5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzU0XSlcblxuICAgICAgZHN0WzQwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzIwXSlcbiAgICAgIGRzdFs0MV0gPSBkZWNvZGVGbG9hdDE2KHNyY1syMl0pXG4gICAgICBkc3RbNDJdID0gZGVjb2RlRmxvYXQxNihzcmNbMzNdKVxuICAgICAgZHN0WzQzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzM4XSlcbiAgICAgIGRzdFs0NF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0Nl0pXG4gICAgICBkc3RbNDVdID0gZGVjb2RlRmxvYXQxNihzcmNbNTFdKVxuICAgICAgZHN0WzQ2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzU1XSlcbiAgICAgIGRzdFs0N10gPSBkZWNvZGVGbG9hdDE2KHNyY1s2MF0pXG4gICAgICBkc3RbNDhdID0gZGVjb2RlRmxvYXQxNihzcmNbMjFdKVxuICAgICAgZHN0WzQ5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM0XSlcblxuICAgICAgZHN0WzUwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzM3XSlcbiAgICAgIGRzdFs1MV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0N10pXG4gICAgICBkc3RbNTJdID0gZGVjb2RlRmxvYXQxNihzcmNbNTBdKVxuICAgICAgZHN0WzUzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzU2XSlcbiAgICAgIGRzdFs1NF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1OV0pXG4gICAgICBkc3RbNTVdID0gZGVjb2RlRmxvYXQxNihzcmNbNjFdKVxuICAgICAgZHN0WzU2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM1XSlcbiAgICAgIGRzdFs1N10gPSBkZWNvZGVGbG9hdDE2KHNyY1szNl0pXG4gICAgICBkc3RbNThdID0gZGVjb2RlRmxvYXQxNihzcmNbNDhdKVxuICAgICAgZHN0WzU5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ5XSlcblxuICAgICAgZHN0WzYwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzU3XSlcbiAgICAgIGRzdFs2MV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1OF0pXG4gICAgICBkc3RbNjJdID0gZGVjb2RlRmxvYXQxNihzcmNbNjJdKVxuICAgICAgZHN0WzYzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzYzXSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkY3RJbnZlcnNlKGRhdGEpIHtcbiAgICAgIGNvbnN0IGEgPSAwLjUgKiBNYXRoLmNvcygzLjE0MTU5IC8gNC4wKVxuICAgICAgY29uc3QgYiA9IDAuNSAqIE1hdGguY29zKDMuMTQxNTkgLyAxNi4wKVxuICAgICAgY29uc3QgYyA9IDAuNSAqIE1hdGguY29zKDMuMTQxNTkgLyA4LjApXG4gICAgICBjb25zdCBkID0gMC41ICogTWF0aC5jb3MoKDMuMCAqIDMuMTQxNTkpIC8gMTYuMClcbiAgICAgIGNvbnN0IGUgPSAwLjUgKiBNYXRoLmNvcygoNS4wICogMy4xNDE1OSkgLyAxNi4wKVxuICAgICAgY29uc3QgZiA9IDAuNSAqIE1hdGguY29zKCgzLjAgKiAzLjE0MTU5KSAvIDguMClcbiAgICAgIGNvbnN0IGcgPSAwLjUgKiBNYXRoLmNvcygoNy4wICogMy4xNDE1OSkgLyAxNi4wKVxuXG4gICAgICB2YXIgYWxwaGEgPSBuZXcgQXJyYXkoNClcbiAgICAgIHZhciBiZXRhID0gbmV3IEFycmF5KDQpXG4gICAgICB2YXIgdGhldGEgPSBuZXcgQXJyYXkoNClcbiAgICAgIHZhciBnYW1tYSA9IG5ldyBBcnJheSg0KVxuXG4gICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCA4OyArK3Jvdykge1xuICAgICAgICB2YXIgcm93UHRyID0gcm93ICogOFxuXG4gICAgICAgIGFscGhhWzBdID0gYyAqIGRhdGFbcm93UHRyICsgMl1cbiAgICAgICAgYWxwaGFbMV0gPSBmICogZGF0YVtyb3dQdHIgKyAyXVxuICAgICAgICBhbHBoYVsyXSA9IGMgKiBkYXRhW3Jvd1B0ciArIDZdXG4gICAgICAgIGFscGhhWzNdID0gZiAqIGRhdGFbcm93UHRyICsgNl1cblxuICAgICAgICBiZXRhWzBdID0gYiAqIGRhdGFbcm93UHRyICsgMV0gKyBkICogZGF0YVtyb3dQdHIgKyAzXSArIGUgKiBkYXRhW3Jvd1B0ciArIDVdICsgZyAqIGRhdGFbcm93UHRyICsgN11cbiAgICAgICAgYmV0YVsxXSA9IGQgKiBkYXRhW3Jvd1B0ciArIDFdIC0gZyAqIGRhdGFbcm93UHRyICsgM10gLSBiICogZGF0YVtyb3dQdHIgKyA1XSAtIGUgKiBkYXRhW3Jvd1B0ciArIDddXG4gICAgICAgIGJldGFbMl0gPSBlICogZGF0YVtyb3dQdHIgKyAxXSAtIGIgKiBkYXRhW3Jvd1B0ciArIDNdICsgZyAqIGRhdGFbcm93UHRyICsgNV0gKyBkICogZGF0YVtyb3dQdHIgKyA3XVxuICAgICAgICBiZXRhWzNdID0gZyAqIGRhdGFbcm93UHRyICsgMV0gLSBlICogZGF0YVtyb3dQdHIgKyAzXSArIGQgKiBkYXRhW3Jvd1B0ciArIDVdIC0gYiAqIGRhdGFbcm93UHRyICsgN11cblxuICAgICAgICB0aGV0YVswXSA9IGEgKiAoZGF0YVtyb3dQdHIgKyAwXSArIGRhdGFbcm93UHRyICsgNF0pXG4gICAgICAgIHRoZXRhWzNdID0gYSAqIChkYXRhW3Jvd1B0ciArIDBdIC0gZGF0YVtyb3dQdHIgKyA0XSlcbiAgICAgICAgdGhldGFbMV0gPSBhbHBoYVswXSArIGFscGhhWzNdXG4gICAgICAgIHRoZXRhWzJdID0gYWxwaGFbMV0gLSBhbHBoYVsyXVxuXG4gICAgICAgIGdhbW1hWzBdID0gdGhldGFbMF0gKyB0aGV0YVsxXVxuICAgICAgICBnYW1tYVsxXSA9IHRoZXRhWzNdICsgdGhldGFbMl1cbiAgICAgICAgZ2FtbWFbMl0gPSB0aGV0YVszXSAtIHRoZXRhWzJdXG4gICAgICAgIGdhbW1hWzNdID0gdGhldGFbMF0gLSB0aGV0YVsxXVxuXG4gICAgICAgIGRhdGFbcm93UHRyICsgMF0gPSBnYW1tYVswXSArIGJldGFbMF1cbiAgICAgICAgZGF0YVtyb3dQdHIgKyAxXSA9IGdhbW1hWzFdICsgYmV0YVsxXVxuICAgICAgICBkYXRhW3Jvd1B0ciArIDJdID0gZ2FtbWFbMl0gKyBiZXRhWzJdXG4gICAgICAgIGRhdGFbcm93UHRyICsgM10gPSBnYW1tYVszXSArIGJldGFbM11cblxuICAgICAgICBkYXRhW3Jvd1B0ciArIDRdID0gZ2FtbWFbM10gLSBiZXRhWzNdXG4gICAgICAgIGRhdGFbcm93UHRyICsgNV0gPSBnYW1tYVsyXSAtIGJldGFbMl1cbiAgICAgICAgZGF0YVtyb3dQdHIgKyA2XSA9IGdhbW1hWzFdIC0gYmV0YVsxXVxuICAgICAgICBkYXRhW3Jvd1B0ciArIDddID0gZ2FtbWFbMF0gLSBiZXRhWzBdXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8IDg7ICsrY29sdW1uKSB7XG4gICAgICAgIGFscGhhWzBdID0gYyAqIGRhdGFbMTYgKyBjb2x1bW5dXG4gICAgICAgIGFscGhhWzFdID0gZiAqIGRhdGFbMTYgKyBjb2x1bW5dXG4gICAgICAgIGFscGhhWzJdID0gYyAqIGRhdGFbNDggKyBjb2x1bW5dXG4gICAgICAgIGFscGhhWzNdID0gZiAqIGRhdGFbNDggKyBjb2x1bW5dXG5cbiAgICAgICAgYmV0YVswXSA9IGIgKiBkYXRhWzggKyBjb2x1bW5dICsgZCAqIGRhdGFbMjQgKyBjb2x1bW5dICsgZSAqIGRhdGFbNDAgKyBjb2x1bW5dICsgZyAqIGRhdGFbNTYgKyBjb2x1bW5dXG4gICAgICAgIGJldGFbMV0gPSBkICogZGF0YVs4ICsgY29sdW1uXSAtIGcgKiBkYXRhWzI0ICsgY29sdW1uXSAtIGIgKiBkYXRhWzQwICsgY29sdW1uXSAtIGUgKiBkYXRhWzU2ICsgY29sdW1uXVxuICAgICAgICBiZXRhWzJdID0gZSAqIGRhdGFbOCArIGNvbHVtbl0gLSBiICogZGF0YVsyNCArIGNvbHVtbl0gKyBnICogZGF0YVs0MCArIGNvbHVtbl0gKyBkICogZGF0YVs1NiArIGNvbHVtbl1cbiAgICAgICAgYmV0YVszXSA9IGcgKiBkYXRhWzggKyBjb2x1bW5dIC0gZSAqIGRhdGFbMjQgKyBjb2x1bW5dICsgZCAqIGRhdGFbNDAgKyBjb2x1bW5dIC0gYiAqIGRhdGFbNTYgKyBjb2x1bW5dXG5cbiAgICAgICAgdGhldGFbMF0gPSBhICogKGRhdGFbY29sdW1uXSArIGRhdGFbMzIgKyBjb2x1bW5dKVxuICAgICAgICB0aGV0YVszXSA9IGEgKiAoZGF0YVtjb2x1bW5dIC0gZGF0YVszMiArIGNvbHVtbl0pXG5cbiAgICAgICAgdGhldGFbMV0gPSBhbHBoYVswXSArIGFscGhhWzNdXG4gICAgICAgIHRoZXRhWzJdID0gYWxwaGFbMV0gLSBhbHBoYVsyXVxuXG4gICAgICAgIGdhbW1hWzBdID0gdGhldGFbMF0gKyB0aGV0YVsxXVxuICAgICAgICBnYW1tYVsxXSA9IHRoZXRhWzNdICsgdGhldGFbMl1cbiAgICAgICAgZ2FtbWFbMl0gPSB0aGV0YVszXSAtIHRoZXRhWzJdXG4gICAgICAgIGdhbW1hWzNdID0gdGhldGFbMF0gLSB0aGV0YVsxXVxuXG4gICAgICAgIGRhdGFbMCArIGNvbHVtbl0gPSBnYW1tYVswXSArIGJldGFbMF1cbiAgICAgICAgZGF0YVs4ICsgY29sdW1uXSA9IGdhbW1hWzFdICsgYmV0YVsxXVxuICAgICAgICBkYXRhWzE2ICsgY29sdW1uXSA9IGdhbW1hWzJdICsgYmV0YVsyXVxuICAgICAgICBkYXRhWzI0ICsgY29sdW1uXSA9IGdhbW1hWzNdICsgYmV0YVszXVxuXG4gICAgICAgIGRhdGFbMzIgKyBjb2x1bW5dID0gZ2FtbWFbM10gLSBiZXRhWzNdXG4gICAgICAgIGRhdGFbNDAgKyBjb2x1bW5dID0gZ2FtbWFbMl0gLSBiZXRhWzJdXG4gICAgICAgIGRhdGFbNDggKyBjb2x1bW5dID0gZ2FtbWFbMV0gLSBiZXRhWzFdXG4gICAgICAgIGRhdGFbNTYgKyBjb2x1bW5dID0gZ2FtbWFbMF0gLSBiZXRhWzBdXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3NjNzA5SW52ZXJzZShkYXRhKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgICAgdmFyIHkgPSBkYXRhWzBdW2ldXG4gICAgICAgIHZhciBjYiA9IGRhdGFbMV1baV1cbiAgICAgICAgdmFyIGNyID0gZGF0YVsyXVtpXVxuXG4gICAgICAgIGRhdGFbMF1baV0gPSB5ICsgMS41NzQ3ICogY3JcbiAgICAgICAgZGF0YVsxXVtpXSA9IHkgLSAwLjE4NzMgKiBjYiAtIDAuNDY4MiAqIGNyXG4gICAgICAgIGRhdGFbMl1baV0gPSB5ICsgMS44NTU2ICogY2JcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0VG9IYWxmKHNyYywgZHN0LCBpZHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgICAgICBkc3RbaWR4ICsgaV0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQodG9MaW5lYXIoc3JjW2ldKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0xpbmVhcihmbG9hdCkge1xuICAgICAgaWYgKGZsb2F0IDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2lnbihmbG9hdCkgKiBNYXRoLnBvdyhNYXRoLmFicyhmbG9hdCksIDIuMilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpZ24oZmxvYXQpICogTWF0aC5wb3cobG9nQmFzZSwgTWF0aC5hYnMoZmxvYXQpIC0gMS4wKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NSQVcoaW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhpbmZvLmFycmF5LmJ1ZmZlciwgaW5mby5vZmZzZXQudmFsdWUsIGluZm8uc2l6ZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzUkxFKGluZm8pIHtcbiAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby52aWV3ZXIuYnVmZmVyLnNsaWNlKGluZm8ub2Zmc2V0LnZhbHVlLCBpbmZvLm9mZnNldC52YWx1ZSArIGluZm8uc2l6ZSlcblxuICAgICAgdmFyIHJhd0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGRlY29kZVJ1bkxlbmd0aChjb21wcmVzc2VkKSlcbiAgICAgIHZhciB0bXBCdWZmZXIgPSBuZXcgVWludDhBcnJheShyYXdCdWZmZXIubGVuZ3RoKVxuXG4gICAgICBwcmVkaWN0b3IocmF3QnVmZmVyKSAvLyByZXZlcnQgcHJlZGljdG9yXG5cbiAgICAgIGludGVybGVhdmVTY2FsYXIocmF3QnVmZmVyLCB0bXBCdWZmZXIpIC8vIGludGVybGVhdmUgcGl4ZWxzXG5cbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcilcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzWklQKGluZm8pIHtcbiAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby5hcnJheS5zbGljZShpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5vZmZzZXQudmFsdWUgKyBpbmZvLnNpemUpXG4gICAgICB2YXIgcmF3QnVmZmVyID0gdW56bGliU3luYyhjb21wcmVzc2VkKVxuICAgICAgdmFyIHRtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHJhd0J1ZmZlci5sZW5ndGgpXG5cbiAgICAgIHByZWRpY3RvcihyYXdCdWZmZXIpIC8vIHJldmVydCBwcmVkaWN0b3JcblxuICAgICAgaW50ZXJsZWF2ZVNjYWxhcihyYXdCdWZmZXIsIHRtcEJ1ZmZlcikgLy8gaW50ZXJsZWF2ZSBwaXhlbHNcblxuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NQSVooaW5mbykge1xuICAgICAgdmFyIGluRGF0YVZpZXcgPSBpbmZvLnZpZXdlclxuICAgICAgdmFyIGluT2Zmc2V0ID0geyB2YWx1ZTogaW5mby5vZmZzZXQudmFsdWUgfVxuXG4gICAgICB2YXIgb3V0QnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGluZm8ud2lkdGggKiBpbmZvLnNjYW5saW5lQmxvY2tTaXplICogKGluZm8uY2hhbm5lbHMgKiBpbmZvLnR5cGUpKVxuICAgICAgdmFyIGJpdG1hcCA9IG5ldyBVaW50OEFycmF5KEJJVE1BUF9TSVpFKVxuXG4gICAgICAvLyBTZXR1cCBjaGFubmVsIGluZm9cbiAgICAgIHZhciBvdXRCdWZmZXJFbmQgPSAwXG4gICAgICB2YXIgcGl6Q2hhbm5lbERhdGEgPSBuZXcgQXJyYXkoaW5mby5jaGFubmVscylcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5mby5jaGFubmVsczsgaSsrKSB7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldID0ge31cbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bJ3N0YXJ0J10gPSBvdXRCdWZmZXJFbmRcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bJ2VuZCddID0gcGl6Q2hhbm5lbERhdGFbaV1bJ3N0YXJ0J11cbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bJ254J10gPSBpbmZvLndpZHRoXG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldWydueSddID0gaW5mby5saW5lc1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVsnc2l6ZSddID0gaW5mby50eXBlXG5cbiAgICAgICAgb3V0QnVmZmVyRW5kICs9IHBpekNoYW5uZWxEYXRhW2ldLm54ICogcGl6Q2hhbm5lbERhdGFbaV0ubnkgKiBwaXpDaGFubmVsRGF0YVtpXS5zaXplXG4gICAgICB9XG5cbiAgICAgIC8vIFJlYWQgcmFuZ2UgY29tcHJlc3Npb24gZGF0YVxuXG4gICAgICB2YXIgbWluTm9uWmVybyA9IHBhcnNlVWludDE2KGluRGF0YVZpZXcsIGluT2Zmc2V0KVxuICAgICAgdmFyIG1heE5vblplcm8gPSBwYXJzZVVpbnQxNihpbkRhdGFWaWV3LCBpbk9mZnNldClcblxuICAgICAgaWYgKG1heE5vblplcm8gPj0gQklUTUFQX1NJWkUpIHtcbiAgICAgICAgdGhyb3cgJ1NvbWV0aGluZyBpcyB3cm9uZyB3aXRoIFBJWl9DT01QUkVTU0lPTiBCSVRNQVBfU0laRSdcbiAgICAgIH1cblxuICAgICAgaWYgKG1pbk5vblplcm8gPD0gbWF4Tm9uWmVybykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heE5vblplcm8gLSBtaW5Ob25aZXJvICsgMTsgaSsrKSB7XG4gICAgICAgICAgYml0bWFwW2kgKyBtaW5Ob25aZXJvXSA9IHBhcnNlVWludDgoaW5EYXRhVmlldywgaW5PZmZzZXQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmV2ZXJzZSBMVVRcbiAgICAgIHZhciBsdXQgPSBuZXcgVWludDE2QXJyYXkoVVNIT1JUX1JBTkdFKVxuICAgICAgdmFyIG1heFZhbHVlID0gcmV2ZXJzZUx1dEZyb21CaXRtYXAoYml0bWFwLCBsdXQpXG5cbiAgICAgIHZhciBsZW5ndGggPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldClcblxuICAgICAgLy8gSHVmZm1hbiBkZWNvZGluZ1xuICAgICAgaHVmVW5jb21wcmVzcyhpbmZvLmFycmF5LCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbGVuZ3RoLCBvdXRCdWZmZXIsIG91dEJ1ZmZlckVuZClcblxuICAgICAgLy8gV2F2ZWxldCBkZWNvZGluZ1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmZvLmNoYW5uZWxzOyArK2kpIHtcbiAgICAgICAgdmFyIGNkID0gcGl6Q2hhbm5lbERhdGFbaV1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBpekNoYW5uZWxEYXRhW2ldLnNpemU7ICsraikge1xuICAgICAgICAgIHdhdjJEZWNvZGUob3V0QnVmZmVyLCBjZC5zdGFydCArIGosIGNkLm54LCBjZC5zaXplLCBjZC5ueSwgY2QubnggKiBjZC5zaXplLCBtYXhWYWx1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBFeHBhbmQgdGhlIHBpeGVsIGRhdGEgdG8gdGhlaXIgb3JpZ2luYWwgcmFuZ2VcbiAgICAgIGFwcGx5THV0KGx1dCwgb3V0QnVmZmVyLCBvdXRCdWZmZXJFbmQpXG5cbiAgICAgIC8vIFJlYXJyYW5nZSB0aGUgcGl4ZWwgZGF0YSBpbnRvIHRoZSBmb3JtYXQgZXhwZWN0ZWQgYnkgdGhlIGNhbGxlci5cbiAgICAgIHZhciB0bXBPZmZzZXQgPSAwXG4gICAgICB2YXIgdG1wQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkob3V0QnVmZmVyLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyB5KyspIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBpbmZvLmNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICB2YXIgY2QgPSBwaXpDaGFubmVsRGF0YVtjXVxuXG4gICAgICAgICAgdmFyIG4gPSBjZC5ueCAqIGNkLnNpemVcbiAgICAgICAgICB2YXIgY3AgPSBuZXcgVWludDhBcnJheShvdXRCdWZmZXIuYnVmZmVyLCBjZC5lbmQgKiBJTlQxNl9TSVpFLCBuICogSU5UMTZfU0laRSlcblxuICAgICAgICAgIHRtcEJ1ZmZlci5zZXQoY3AsIHRtcE9mZnNldClcbiAgICAgICAgICB0bXBPZmZzZXQgKz0gbiAqIElOVDE2X1NJWkVcbiAgICAgICAgICBjZC5lbmQgKz0gblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcilcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzUFhSKGluZm8pIHtcbiAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby5hcnJheS5zbGljZShpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5vZmZzZXQudmFsdWUgKyBpbmZvLnNpemUpXG4gICAgICB2YXIgcmF3QnVmZmVyID0gdW56bGliU3luYyhjb21wcmVzc2VkKVxuXG4gICAgICBjb25zdCBzeiA9IGluZm8ubGluZXMgKiBpbmZvLmNoYW5uZWxzICogaW5mby53aWR0aFxuICAgICAgY29uc3QgdG1wQnVmZmVyID0gaW5mby50eXBlID09IDEgPyBuZXcgVWludDE2QXJyYXkoc3opIDogbmV3IFVpbnQzMkFycmF5KHN6KVxuXG4gICAgICBsZXQgdG1wQnVmZmVyRW5kID0gMFxuICAgICAgbGV0IHdyaXRlUHRyID0gMFxuICAgICAgY29uc3QgcHRyID0gbmV3IEFycmF5KDQpXG5cbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaW5mby5saW5lczsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgaW5mby5jaGFubmVsczsgYysrKSB7XG4gICAgICAgICAgbGV0IHBpeGVsID0gMFxuXG4gICAgICAgICAgc3dpdGNoIChpbmZvLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcHRyWzBdID0gdG1wQnVmZmVyRW5kXG4gICAgICAgICAgICAgIHB0clsxXSA9IHB0clswXSArIGluZm8ud2lkdGhcbiAgICAgICAgICAgICAgdG1wQnVmZmVyRW5kID0gcHRyWzFdICsgaW5mby53aWR0aFxuXG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5mby53aWR0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IChyYXdCdWZmZXJbcHRyWzBdKytdIDw8IDgpIHwgcmF3QnVmZmVyW3B0clsxXSsrXVxuXG4gICAgICAgICAgICAgICAgcGl4ZWwgKz0gZGlmZlxuXG4gICAgICAgICAgICAgICAgdG1wQnVmZmVyW3dyaXRlUHRyXSA9IHBpeGVsXG4gICAgICAgICAgICAgICAgd3JpdGVQdHIrK1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBwdHJbMF0gPSB0bXBCdWZmZXJFbmRcbiAgICAgICAgICAgICAgcHRyWzFdID0gcHRyWzBdICsgaW5mby53aWR0aFxuICAgICAgICAgICAgICBwdHJbMl0gPSBwdHJbMV0gKyBpbmZvLndpZHRoXG4gICAgICAgICAgICAgIHRtcEJ1ZmZlckVuZCA9IHB0clsyXSArIGluZm8ud2lkdGhcblxuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZm8ud2lkdGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSAocmF3QnVmZmVyW3B0clswXSsrXSA8PCAyNCkgfCAocmF3QnVmZmVyW3B0clsxXSsrXSA8PCAxNikgfCAocmF3QnVmZmVyW3B0clsyXSsrXSA8PCA4KVxuXG4gICAgICAgICAgICAgICAgcGl4ZWwgKz0gZGlmZlxuXG4gICAgICAgICAgICAgICAgdG1wQnVmZmVyW3dyaXRlUHRyXSA9IHBpeGVsXG4gICAgICAgICAgICAgICAgd3JpdGVQdHIrK1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NEV0EoaW5mbykge1xuICAgICAgdmFyIGluRGF0YVZpZXcgPSBpbmZvLnZpZXdlclxuICAgICAgdmFyIGluT2Zmc2V0ID0geyB2YWx1ZTogaW5mby5vZmZzZXQudmFsdWUgfVxuICAgICAgdmFyIG91dEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGluZm8ud2lkdGggKiBpbmZvLmxpbmVzICogKGluZm8uY2hhbm5lbHMgKiBpbmZvLnR5cGUgKiBJTlQxNl9TSVpFKSlcblxuICAgICAgLy8gUmVhZCBjb21wcmVzc2lvbiBoZWFkZXIgaW5mb3JtYXRpb25cbiAgICAgIHZhciBkd2FIZWFkZXIgPSB7XG4gICAgICAgIHZlcnNpb246IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB1bmtub3duVW5jb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHVua25vd25Db21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIGFjQ29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBkY0NvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgcmxlQ29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBybGVVbmNvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgcmxlUmF3U2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHRvdGFsQWNVbmNvbXByZXNzZWRDb3VudDogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHRvdGFsRGNVbmNvbXByZXNzZWRDb3VudDogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIGFjQ29tcHJlc3Npb246IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgfVxuXG4gICAgICBpZiAoZHdhSGVhZGVyLnZlcnNpb24gPCAyKSB7XG4gICAgICAgIHRocm93ICdFWFJMb2FkZXIucGFyc2U6ICcgKyBFWFJIZWFkZXIuY29tcHJlc3Npb24gKyAnIHZlcnNpb24gJyArIGR3YUhlYWRlci52ZXJzaW9uICsgJyBpcyB1bnN1cHBvcnRlZCdcbiAgICAgIH1cblxuICAgICAgLy8gUmVhZCBjaGFubmVsIHJ1bGVzZXQgaW5mb3JtYXRpb25cbiAgICAgIHZhciBjaGFubmVsUnVsZXMgPSBuZXcgQXJyYXkoKVxuICAgICAgdmFyIHJ1bGVTaXplID0gcGFyc2VVaW50MTYoaW5EYXRhVmlldywgaW5PZmZzZXQpIC0gSU5UMTZfU0laRVxuXG4gICAgICB3aGlsZSAocnVsZVNpemUgPiAwKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhpbkRhdGFWaWV3LmJ1ZmZlciwgaW5PZmZzZXQpXG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlVWludDgoaW5EYXRhVmlldywgaW5PZmZzZXQpXG4gICAgICAgIHZhciBjb21wcmVzc2lvbiA9ICh2YWx1ZSA+PiAyKSAmIDNcbiAgICAgICAgdmFyIGNzYyA9ICh2YWx1ZSA+PiA0KSAtIDFcbiAgICAgICAgdmFyIGluZGV4ID0gbmV3IEludDhBcnJheShbY3NjXSlbMF1cbiAgICAgICAgdmFyIHR5cGUgPSBwYXJzZVVpbnQ4KGluRGF0YVZpZXcsIGluT2Zmc2V0KVxuXG4gICAgICAgIGNoYW5uZWxSdWxlcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvbixcbiAgICAgICAgfSlcblxuICAgICAgICBydWxlU2l6ZSAtPSBuYW1lLmxlbmd0aCArIDNcbiAgICAgIH1cblxuICAgICAgLy8gQ2xhc3NpZnkgY2hhbm5lbHNcbiAgICAgIHZhciBjaGFubmVscyA9IEVYUkhlYWRlci5jaGFubmVsc1xuICAgICAgdmFyIGNoYW5uZWxEYXRhID0gbmV3IEFycmF5KGluZm8uY2hhbm5lbHMpXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5mby5jaGFubmVsczsgKytpKSB7XG4gICAgICAgIHZhciBjZCA9IChjaGFubmVsRGF0YVtpXSA9IHt9KVxuICAgICAgICB2YXIgY2hhbm5lbCA9IGNoYW5uZWxzW2ldXG5cbiAgICAgICAgY2QubmFtZSA9IGNoYW5uZWwubmFtZVxuICAgICAgICBjZC5jb21wcmVzc2lvbiA9IFVOS05PV05cbiAgICAgICAgY2QuZGVjb2RlZCA9IGZhbHNlXG4gICAgICAgIGNkLnR5cGUgPSBjaGFubmVsLnBpeGVsVHlwZVxuICAgICAgICBjZC5wTGluZWFyID0gY2hhbm5lbC5wTGluZWFyXG4gICAgICAgIGNkLndpZHRoID0gaW5mby53aWR0aFxuICAgICAgICBjZC5oZWlnaHQgPSBpbmZvLmxpbmVzXG4gICAgICB9XG5cbiAgICAgIHZhciBjc2NTZXQgPSB7XG4gICAgICAgIGlkeDogbmV3IEFycmF5KDMpLFxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBpbmZvLmNoYW5uZWxzOyArK29mZnNldCkge1xuICAgICAgICB2YXIgY2QgPSBjaGFubmVsRGF0YVtvZmZzZXRdXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVsUnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgcnVsZSA9IGNoYW5uZWxSdWxlc1tpXVxuXG4gICAgICAgICAgaWYgKGNkLm5hbWUgPT0gcnVsZS5uYW1lKSB7XG4gICAgICAgICAgICBjZC5jb21wcmVzc2lvbiA9IHJ1bGUuY29tcHJlc3Npb25cblxuICAgICAgICAgICAgaWYgKHJ1bGUuaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICBjc2NTZXQuaWR4W3J1bGUuaW5kZXhdID0gb2Zmc2V0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNkLm9mZnNldCA9IG9mZnNldFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZWFkIERDVCAtIEFDIGNvbXBvbmVudCBkYXRhXG4gICAgICBpZiAoZHdhSGVhZGVyLmFjQ29tcHJlc3NlZFNpemUgPiAwKSB7XG4gICAgICAgIHN3aXRjaCAoZHdhSGVhZGVyLmFjQ29tcHJlc3Npb24pIHtcbiAgICAgICAgICBjYXNlIFNUQVRJQ19IVUZGTUFOOlxuICAgICAgICAgICAgdmFyIGFjQnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGR3YUhlYWRlci50b3RhbEFjVW5jb21wcmVzc2VkQ291bnQpXG4gICAgICAgICAgICBodWZVbmNvbXByZXNzKFxuICAgICAgICAgICAgICBpbmZvLmFycmF5LFxuICAgICAgICAgICAgICBpbkRhdGFWaWV3LFxuICAgICAgICAgICAgICBpbk9mZnNldCxcbiAgICAgICAgICAgICAgZHdhSGVhZGVyLmFjQ29tcHJlc3NlZFNpemUsXG4gICAgICAgICAgICAgIGFjQnVmZmVyLFxuICAgICAgICAgICAgICBkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50LFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgREVGTEFURTpcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby5hcnJheS5zbGljZShpbk9mZnNldC52YWx1ZSwgaW5PZmZzZXQudmFsdWUgKyBkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50KVxuICAgICAgICAgICAgdmFyIGRhdGEgPSB1bnpsaWJTeW5jKGNvbXByZXNzZWQpXG4gICAgICAgICAgICB2YXIgYWNCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoZGF0YS5idWZmZXIpXG4gICAgICAgICAgICBpbk9mZnNldC52YWx1ZSArPSBkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50XG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlYWQgRENUIC0gREMgY29tcG9uZW50IGRhdGFcbiAgICAgIGlmIChkd2FIZWFkZXIuZGNDb21wcmVzc2VkU2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIHpsaWJJbmZvID0ge1xuICAgICAgICAgIGFycmF5OiBpbmZvLmFycmF5LFxuICAgICAgICAgIG9mZnNldDogaW5PZmZzZXQsXG4gICAgICAgICAgc2l6ZTogZHdhSGVhZGVyLmRjQ29tcHJlc3NlZFNpemUsXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRjQnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KHVuY29tcHJlc3NaSVAoemxpYkluZm8pLmJ1ZmZlcilcbiAgICAgICAgaW5PZmZzZXQudmFsdWUgKz0gZHdhSGVhZGVyLmRjQ29tcHJlc3NlZFNpemVcbiAgICAgIH1cblxuICAgICAgLy8gUmVhZCBSTEUgY29tcHJlc3NlZCBkYXRhXG4gICAgICBpZiAoZHdhSGVhZGVyLnJsZVJhd1NpemUgPiAwKSB7XG4gICAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby5hcnJheS5zbGljZShpbk9mZnNldC52YWx1ZSwgaW5PZmZzZXQudmFsdWUgKyBkd2FIZWFkZXIucmxlQ29tcHJlc3NlZFNpemUpXG4gICAgICAgIHZhciBkYXRhID0gdW56bGliU3luYyhjb21wcmVzc2VkKVxuICAgICAgICB2YXIgcmxlQnVmZmVyID0gZGVjb2RlUnVuTGVuZ3RoKGRhdGEuYnVmZmVyKVxuXG4gICAgICAgIGluT2Zmc2V0LnZhbHVlICs9IGR3YUhlYWRlci5ybGVDb21wcmVzc2VkU2l6ZVxuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIG91dGJ1ZmZlciBkYXRhIG9mZnNldFxuICAgICAgdmFyIG91dEJ1ZmZlckVuZCA9IDBcbiAgICAgIHZhciByb3dPZmZzZXRzID0gbmV3IEFycmF5KGNoYW5uZWxEYXRhLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93T2Zmc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICByb3dPZmZzZXRzW2ldID0gbmV3IEFycmF5KClcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyArK3kpIHtcbiAgICAgICAgZm9yICh2YXIgY2hhbiA9IDA7IGNoYW4gPCBjaGFubmVsRGF0YS5sZW5ndGg7ICsrY2hhbikge1xuICAgICAgICAgIHJvd09mZnNldHNbY2hhbl0ucHVzaChvdXRCdWZmZXJFbmQpXG4gICAgICAgICAgb3V0QnVmZmVyRW5kICs9IGNoYW5uZWxEYXRhW2NoYW5dLndpZHRoICogaW5mby50eXBlICogSU5UMTZfU0laRVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIExvc3N5IERDVCBkZWNvZGUgUkdCIGNoYW5uZWxzXG4gICAgICBsb3NzeURjdERlY29kZShjc2NTZXQsIHJvd09mZnNldHMsIGNoYW5uZWxEYXRhLCBhY0J1ZmZlciwgZGNCdWZmZXIsIG91dEJ1ZmZlcilcblxuICAgICAgLy8gRGVjb2RlIG90aGVyIGNoYW5uZWxzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5uZWxEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjZCA9IGNoYW5uZWxEYXRhW2ldXG5cbiAgICAgICAgaWYgKGNkLmRlY29kZWQpIGNvbnRpbnVlXG5cbiAgICAgICAgc3dpdGNoIChjZC5jb21wcmVzc2lvbikge1xuICAgICAgICAgIGNhc2UgUkxFOlxuICAgICAgICAgICAgdmFyIHJvdyA9IDBcbiAgICAgICAgICAgIHZhciBybGVPZmZzZXQgPSAwXG5cbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaW5mby5saW5lczsgKyt5KSB7XG4gICAgICAgICAgICAgIHZhciByb3dPZmZzZXRCeXRlcyA9IHJvd09mZnNldHNbaV1bcm93XVxuXG4gICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2Qud2lkdGg7ICsreCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGJ5dGUgPSAwOyBieXRlIDwgSU5UMTZfU0laRSAqIGNkLnR5cGU7ICsrYnl0ZSkge1xuICAgICAgICAgICAgICAgICAgb3V0QnVmZmVyW3Jvd09mZnNldEJ5dGVzKytdID0gcmxlQnVmZmVyW3JsZU9mZnNldCArIGJ5dGUgKiBjZC53aWR0aCAqIGNkLmhlaWdodF1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBybGVPZmZzZXQrK1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcm93KytcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgTE9TU1lfRENUOiAvLyBza2lwXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ0VYUkxvYWRlci5wYXJzZTogdW5zdXBwb3J0ZWQgY2hhbm5lbCBjb21wcmVzc2lvbidcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KG91dEJ1ZmZlci5idWZmZXIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhidWZmZXIsIG9mZnNldCkge1xuICAgICAgdmFyIHVpbnRCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIpXG4gICAgICB2YXIgZW5kT2Zmc2V0ID0gMFxuXG4gICAgICB3aGlsZSAodWludEJ1ZmZlcltvZmZzZXQudmFsdWUgKyBlbmRPZmZzZXRdICE9IDApIHtcbiAgICAgICAgZW5kT2Zmc2V0ICs9IDFcbiAgICAgIH1cblxuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHVpbnRCdWZmZXIuc2xpY2Uob2Zmc2V0LnZhbHVlLCBvZmZzZXQudmFsdWUgKyBlbmRPZmZzZXQpKVxuXG4gICAgICBvZmZzZXQudmFsdWUgPSBvZmZzZXQudmFsdWUgKyBlbmRPZmZzZXQgKyAxXG5cbiAgICAgIHJldHVybiBzdHJpbmdWYWx1ZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRml4ZWRMZW5ndGhTdHJpbmcoYnVmZmVyLCBvZmZzZXQsIHNpemUpIHtcbiAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShuZXcgVWludDhBcnJheShidWZmZXIpLnNsaWNlKG9mZnNldC52YWx1ZSwgb2Zmc2V0LnZhbHVlICsgc2l6ZSkpXG5cbiAgICAgIG9mZnNldC52YWx1ZSA9IG9mZnNldC52YWx1ZSArIHNpemVcblxuICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VSYXRpb25hbChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgICB2YXIgeCA9IHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldClcbiAgICAgIHZhciB5ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldClcblxuICAgICAgcmV0dXJuIFt4LCB5XVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVGltZWNvZGUoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgICAgdmFyIHggPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0KVxuICAgICAgdmFyIHkgPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0KVxuXG4gICAgICByZXR1cm4gW3gsIHldXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgICB2YXIgSW50MzIgPSBkYXRhVmlldy5nZXRJbnQzMihvZmZzZXQudmFsdWUsIHRydWUpXG5cbiAgICAgIG9mZnNldC52YWx1ZSA9IG9mZnNldC52YWx1ZSArIElOVDMyX1NJWkVcblxuICAgICAgcmV0dXJuIEludDMyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgICAgdmFyIFVpbnQzMiA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQudmFsdWUsIHRydWUpXG5cbiAgICAgIG9mZnNldC52YWx1ZSA9IG9mZnNldC52YWx1ZSArIElOVDMyX1NJWkVcblxuICAgICAgcmV0dXJuIFVpbnQzMlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVWludDhBcnJheSh1SW50OEFycmF5LCBvZmZzZXQpIHtcbiAgICAgIHZhciBVaW50OCA9IHVJbnQ4QXJyYXlbb2Zmc2V0LnZhbHVlXVxuXG4gICAgICBvZmZzZXQudmFsdWUgPSBvZmZzZXQudmFsdWUgKyBJTlQ4X1NJWkVcblxuICAgICAgcmV0dXJuIFVpbnQ4XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgICB2YXIgVWludDggPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQudmFsdWUpXG5cbiAgICAgIG9mZnNldC52YWx1ZSA9IG9mZnNldC52YWx1ZSArIElOVDhfU0laRVxuXG4gICAgICByZXR1cm4gVWludDhcbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZUludDY0ID0gZnVuY3Rpb24gKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgIGxldCBpbnRcblxuICAgICAgaWYgKCdnZXRCaWdJbnQ2NCcgaW4gRGF0YVZpZXcucHJvdG90eXBlKSB7XG4gICAgICAgIGludCA9IE51bWJlcihkYXRhVmlldy5nZXRCaWdJbnQ2NChvZmZzZXQudmFsdWUsIHRydWUpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ID0gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldC52YWx1ZSArIDQsIHRydWUpICsgTnVtYmVyKGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQudmFsdWUsIHRydWUpIDw8IDMyKVxuICAgICAgfVxuXG4gICAgICBvZmZzZXQudmFsdWUgKz0gVUxPTkdfU0laRVxuXG4gICAgICByZXR1cm4gaW50XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgIHZhciBmbG9hdCA9IGRhdGFWaWV3LmdldEZsb2F0MzIob2Zmc2V0LnZhbHVlLCB0cnVlKVxuXG4gICAgICBvZmZzZXQudmFsdWUgKz0gRkxPQVQzMl9TSVpFXG5cbiAgICAgIHJldHVybiBmbG9hdFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIERhdGFVdGlscy50b0hhbGZGbG9hdChwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldCkpXG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTY3ODQzMi9kZWNvbXByZXNzaW5nLWhhbGYtcHJlY2lzaW9uLWZsb2F0cy1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gZGVjb2RlRmxvYXQxNihiaW5hcnkpIHtcbiAgICAgIHZhciBleHBvbmVudCA9IChiaW5hcnkgJiAweDdjMDApID4+IDEwLFxuICAgICAgICBmcmFjdGlvbiA9IGJpbmFyeSAmIDB4MDNmZlxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAoYmluYXJ5ID4+IDE1ID8gLTEgOiAxKSAqXG4gICAgICAgIChleHBvbmVudFxuICAgICAgICAgID8gZXhwb25lbnQgPT09IDB4MWZcbiAgICAgICAgICAgID8gZnJhY3Rpb25cbiAgICAgICAgICAgICAgPyBOYU5cbiAgICAgICAgICAgICAgOiBJbmZpbml0eVxuICAgICAgICAgICAgOiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1KSAqICgxICsgZnJhY3Rpb24gLyAweDQwMClcbiAgICAgICAgICA6IDYuMTAzNTE1NjI1ZS01ICogKGZyYWN0aW9uIC8gMHg0MDApKVxuICAgICAgKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVWludDE2KGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgIHZhciBVaW50MTYgPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0LnZhbHVlLCB0cnVlKVxuXG4gICAgICBvZmZzZXQudmFsdWUgKz0gSU5UMTZfU0laRVxuXG4gICAgICByZXR1cm4gVWludDE2XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGbG9hdDE2KGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZGVjb2RlRmxvYXQxNihwYXJzZVVpbnQxNihidWZmZXIsIG9mZnNldCkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDaGxpc3QoZGF0YVZpZXcsIGJ1ZmZlciwgb2Zmc2V0LCBzaXplKSB7XG4gICAgICB2YXIgc3RhcnRPZmZzZXQgPSBvZmZzZXQudmFsdWVcbiAgICAgIHZhciBjaGFubmVscyA9IFtdXG5cbiAgICAgIHdoaWxlIChvZmZzZXQudmFsdWUgPCBzdGFydE9mZnNldCArIHNpemUgLSAxKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhidWZmZXIsIG9mZnNldClcbiAgICAgICAgdmFyIHBpeGVsVHlwZSA9IHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldClcbiAgICAgICAgdmFyIHBMaW5lYXIgPSBwYXJzZVVpbnQ4KGRhdGFWaWV3LCBvZmZzZXQpXG4gICAgICAgIG9mZnNldC52YWx1ZSArPSAzIC8vIHJlc2VydmVkLCB0aHJlZSBjaGFyc1xuICAgICAgICB2YXIgeFNhbXBsaW5nID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0KVxuICAgICAgICB2YXIgeVNhbXBsaW5nID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0KVxuXG4gICAgICAgIGNoYW5uZWxzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgcGl4ZWxUeXBlOiBwaXhlbFR5cGUsXG4gICAgICAgICAgcExpbmVhcjogcExpbmVhcixcbiAgICAgICAgICB4U2FtcGxpbmc6IHhTYW1wbGluZyxcbiAgICAgICAgICB5U2FtcGxpbmc6IHlTYW1wbGluZyxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0LnZhbHVlICs9IDFcblxuICAgICAgcmV0dXJuIGNoYW5uZWxzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDaHJvbWF0aWNpdGllcyhkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgICB2YXIgcmVkWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0KVxuICAgICAgdmFyIHJlZFkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldClcbiAgICAgIHZhciBncmVlblggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldClcbiAgICAgIHZhciBncmVlblkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldClcbiAgICAgIHZhciBibHVlWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0KVxuICAgICAgdmFyIGJsdWVZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQpXG4gICAgICB2YXIgd2hpdGVYID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQpXG4gICAgICB2YXIgd2hpdGVZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQpXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZFg6IHJlZFgsXG4gICAgICAgIHJlZFk6IHJlZFksXG4gICAgICAgIGdyZWVuWDogZ3JlZW5YLFxuICAgICAgICBncmVlblk6IGdyZWVuWSxcbiAgICAgICAgYmx1ZVg6IGJsdWVYLFxuICAgICAgICBibHVlWTogYmx1ZVksXG4gICAgICAgIHdoaXRlWDogd2hpdGVYLFxuICAgICAgICB3aGl0ZVk6IHdoaXRlWSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbXByZXNzaW9uKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgIHZhciBjb21wcmVzc2lvbkNvZGVzID0gW1xuICAgICAgICAnTk9fQ09NUFJFU1NJT04nLFxuICAgICAgICAnUkxFX0NPTVBSRVNTSU9OJyxcbiAgICAgICAgJ1pJUFNfQ09NUFJFU1NJT04nLFxuICAgICAgICAnWklQX0NPTVBSRVNTSU9OJyxcbiAgICAgICAgJ1BJWl9DT01QUkVTU0lPTicsXG4gICAgICAgICdQWFIyNF9DT01QUkVTU0lPTicsXG4gICAgICAgICdCNDRfQ09NUFJFU1NJT04nLFxuICAgICAgICAnQjQ0QV9DT01QUkVTU0lPTicsXG4gICAgICAgICdEV0FBX0NPTVBSRVNTSU9OJyxcbiAgICAgICAgJ0RXQUJfQ09NUFJFU1NJT04nLFxuICAgICAgXVxuXG4gICAgICB2YXIgY29tcHJlc3Npb24gPSBwYXJzZVVpbnQ4KGRhdGFWaWV3LCBvZmZzZXQpXG5cbiAgICAgIHJldHVybiBjb21wcmVzc2lvbkNvZGVzW2NvbXByZXNzaW9uXVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQm94MmkoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgICAgdmFyIHhNaW4gPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0KVxuICAgICAgdmFyIHlNaW4gPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0KVxuICAgICAgdmFyIHhNYXggPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0KVxuICAgICAgdmFyIHlNYXggPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0KVxuXG4gICAgICByZXR1cm4geyB4TWluOiB4TWluLCB5TWluOiB5TWluLCB4TWF4OiB4TWF4LCB5TWF4OiB5TWF4IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxpbmVPcmRlcihkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgICB2YXIgbGluZU9yZGVycyA9IFsnSU5DUkVBU0lOR19ZJ11cblxuICAgICAgdmFyIGxpbmVPcmRlciA9IHBhcnNlVWludDgoZGF0YVZpZXcsIG9mZnNldClcblxuICAgICAgcmV0dXJuIGxpbmVPcmRlcnNbbGluZU9yZGVyXVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVjJmKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgIHZhciB4ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQpXG4gICAgICB2YXIgeSA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0KVxuXG4gICAgICByZXR1cm4gW3gsIHldXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWM2YoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgICAgdmFyIHggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldClcbiAgICAgIHZhciB5ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQpXG4gICAgICB2YXIgeiA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0KVxuXG4gICAgICByZXR1cm4gW3gsIHksIHpdXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZShkYXRhVmlldywgYnVmZmVyLCBvZmZzZXQsIHR5cGUsIHNpemUpIHtcbiAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnc3RyaW5ndmVjdG9yJyB8fCB0eXBlID09PSAnaWNjUHJvZmlsZScpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRml4ZWRMZW5ndGhTdHJpbmcoYnVmZmVyLCBvZmZzZXQsIHNpemUpXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjaGxpc3QnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNobGlzdChkYXRhVmlldywgYnVmZmVyLCBvZmZzZXQsIHNpemUpXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjaHJvbWF0aWNpdGllcycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQ2hyb21hdGljaXRpZXMoZGF0YVZpZXcsIG9mZnNldClcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvbXByZXNzaW9uJykge1xuICAgICAgICByZXR1cm4gcGFyc2VDb21wcmVzc2lvbihkYXRhVmlldywgb2Zmc2V0KVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYm94MmknKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUJveDJpKGRhdGFWaWV3LCBvZmZzZXQpXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsaW5lT3JkZXInKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUxpbmVPcmRlcihkYXRhVmlldywgb2Zmc2V0KVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZmxvYXQnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldClcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3YyZicpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVjJmKGRhdGFWaWV3LCBvZmZzZXQpXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2M2YnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVYzZihkYXRhVmlldywgb2Zmc2V0KVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaW50Jykge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0KVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncmF0aW9uYWwnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVJhdGlvbmFsKGRhdGFWaWV3LCBvZmZzZXQpXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0aW1lY29kZScpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVGltZWNvZGUoZGF0YVZpZXcsIG9mZnNldClcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3ByZXZpZXcnKSB7XG4gICAgICAgIG9mZnNldC52YWx1ZSArPSBzaXplXG4gICAgICAgIHJldHVybiAnc2tpcHBlZCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldC52YWx1ZSArPSBzaXplXG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcihkYXRhVmlldywgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIGNvbnN0IEVYUkhlYWRlciA9IHt9XG5cbiAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MzIoMCwgdHJ1ZSkgIT0gMjAwMDA2MzApIHtcbiAgICAgICAgLy8gbWFnaWNcbiAgICAgICAgdGhyb3cgXCJUSFJFRS5FWFJMb2FkZXI6IHByb3ZpZGVkIGZpbGUgZG9lc24ndCBhcHBlYXIgdG8gYmUgaW4gT3BlbkVYUiBmb3JtYXQuXCJcbiAgICAgIH1cblxuICAgICAgRVhSSGVhZGVyLnZlcnNpb24gPSBkYXRhVmlldy5nZXRVaW50OCg0KVxuXG4gICAgICBjb25zdCBzcGVjID0gZGF0YVZpZXcuZ2V0VWludDgoNSkgLy8gZnVsbE1hc2tcblxuICAgICAgRVhSSGVhZGVyLnNwZWMgPSB7XG4gICAgICAgIHNpbmdsZVRpbGU6ICEhKHNwZWMgJiAyKSxcbiAgICAgICAgbG9uZ05hbWU6ICEhKHNwZWMgJiA0KSxcbiAgICAgICAgZGVlcEZvcm1hdDogISEoc3BlYyAmIDgpLFxuICAgICAgICBtdWx0aVBhcnQ6ICEhKHNwZWMgJiAxNiksXG4gICAgICB9XG5cbiAgICAgIC8vIHN0YXJ0IG9mIGhlYWRlclxuXG4gICAgICBvZmZzZXQudmFsdWUgPSA4IC8vIHN0YXJ0IGF0IDggLSBhZnRlciBwcmUtYW1ibGVcblxuICAgICAgdmFyIGtlZXBSZWFkaW5nID0gdHJ1ZVxuXG4gICAgICB3aGlsZSAoa2VlcFJlYWRpbmcpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlciwgb2Zmc2V0KVxuXG4gICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09IDApIHtcbiAgICAgICAgICBrZWVwUmVhZGluZyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZVR5cGUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlciwgb2Zmc2V0KVxuICAgICAgICAgIHZhciBhdHRyaWJ1dGVTaXplID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldClcbiAgICAgICAgICB2YXIgYXR0cmlidXRlVmFsdWUgPSBwYXJzZVZhbHVlKGRhdGFWaWV3LCBidWZmZXIsIG9mZnNldCwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlU2l6ZSlcblxuICAgICAgICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEVYUkxvYWRlci5wYXJzZTogc2tpcHBlZCB1bmtub3duIGhlYWRlciBhdHRyaWJ1dGUgdHlwZSBcXCcke2F0dHJpYnV0ZVR5cGV9XFwnLmApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEVYUkhlYWRlclthdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZVZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoc3BlYyAmIH4weDA0KSAhPSAwKSB7XG4gICAgICAgIC8vIHVuc3VwcG9ydGVkIHRpbGVkLCBkZWVwLWltYWdlLCBtdWx0aS1wYXJ0XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0VYUkhlYWRlcjonLCBFWFJIZWFkZXIpXG4gICAgICAgIHRocm93ICdUSFJFRS5FWFJMb2FkZXI6IHByb3ZpZGVkIGZpbGUgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLidcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEVYUkhlYWRlclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwRGVjb2RlcihFWFJIZWFkZXIsIGRhdGFWaWV3LCB1SW50OEFycmF5LCBvZmZzZXQsIG91dHB1dFR5cGUpIHtcbiAgICAgIGNvbnN0IEVYUkRlY29kZXIgPSB7XG4gICAgICAgIHNpemU6IDAsXG4gICAgICAgIHZpZXdlcjogZGF0YVZpZXcsXG4gICAgICAgIGFycmF5OiB1SW50OEFycmF5LFxuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgd2lkdGg6IEVYUkhlYWRlci5kYXRhV2luZG93LnhNYXggLSBFWFJIZWFkZXIuZGF0YVdpbmRvdy54TWluICsgMSxcbiAgICAgICAgaGVpZ2h0OiBFWFJIZWFkZXIuZGF0YVdpbmRvdy55TWF4IC0gRVhSSGVhZGVyLmRhdGFXaW5kb3cueU1pbiArIDEsXG4gICAgICAgIGNoYW5uZWxzOiBFWFJIZWFkZXIuY2hhbm5lbHMubGVuZ3RoLFxuICAgICAgICBieXRlc1BlckxpbmU6IG51bGwsXG4gICAgICAgIGxpbmVzOiBudWxsLFxuICAgICAgICBpbnB1dFNpemU6IG51bGwsXG4gICAgICAgIHR5cGU6IEVYUkhlYWRlci5jaGFubmVsc1swXS5waXhlbFR5cGUsXG4gICAgICAgIHVuY29tcHJlc3M6IG51bGwsXG4gICAgICAgIGdldHRlcjogbnVsbCxcbiAgICAgICAgZm9ybWF0OiBudWxsLFxuICAgICAgICBbaGFzQ29sb3JTcGFjZSA/ICdjb2xvclNwYWNlJyA6ICdlbmNvZGluZyddOiBudWxsLFxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKEVYUkhlYWRlci5jb21wcmVzc2lvbikge1xuICAgICAgICBjYXNlICdOT19DT01QUkVTU0lPTic6XG4gICAgICAgICAgRVhSRGVjb2Rlci5saW5lcyA9IDFcbiAgICAgICAgICBFWFJEZWNvZGVyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUkFXXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdSTEVfQ09NUFJFU1NJT04nOlxuICAgICAgICAgIEVYUkRlY29kZXIubGluZXMgPSAxXG4gICAgICAgICAgRVhSRGVjb2Rlci51bmNvbXByZXNzID0gdW5jb21wcmVzc1JMRVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnWklQU19DT01QUkVTU0lPTic6XG4gICAgICAgICAgRVhSRGVjb2Rlci5saW5lcyA9IDFcbiAgICAgICAgICBFWFJEZWNvZGVyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzWklQXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdaSVBfQ09NUFJFU1NJT04nOlxuICAgICAgICAgIEVYUkRlY29kZXIubGluZXMgPSAxNlxuICAgICAgICAgIEVYUkRlY29kZXIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NaSVBcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ1BJWl9DT01QUkVTU0lPTic6XG4gICAgICAgICAgRVhSRGVjb2Rlci5saW5lcyA9IDMyXG4gICAgICAgICAgRVhSRGVjb2Rlci51bmNvbXByZXNzID0gdW5jb21wcmVzc1BJWlxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnUFhSMjRfQ09NUFJFU1NJT04nOlxuICAgICAgICAgIEVYUkRlY29kZXIubGluZXMgPSAxNlxuICAgICAgICAgIEVYUkRlY29kZXIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NQWFJcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ0RXQUFfQ09NUFJFU1NJT04nOlxuICAgICAgICAgIEVYUkRlY29kZXIubGluZXMgPSAzMlxuICAgICAgICAgIEVYUkRlY29kZXIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NEV0FcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ0RXQUJfQ09NUFJFU1NJT04nOlxuICAgICAgICAgIEVYUkRlY29kZXIubGluZXMgPSAyNTZcbiAgICAgICAgICBFWFJEZWNvZGVyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzRFdBXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93ICdFWFJMb2FkZXIucGFyc2U6ICcgKyBFWFJIZWFkZXIuY29tcHJlc3Npb24gKyAnIGlzIHVuc3VwcG9ydGVkJ1xuICAgICAgfVxuXG4gICAgICBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplID0gRVhSRGVjb2Rlci5saW5lc1xuXG4gICAgICBpZiAoRVhSRGVjb2Rlci50eXBlID09IDEpIHtcbiAgICAgICAgLy8gaGFsZlxuICAgICAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgICAgIEVYUkRlY29kZXIuZ2V0dGVyID0gcGFyc2VGbG9hdDE2XG4gICAgICAgICAgICBFWFJEZWNvZGVyLmlucHV0U2l6ZSA9IElOVDE2X1NJWkVcbiAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyLmdldHRlciA9IHBhcnNlVWludDE2XG4gICAgICAgICAgICBFWFJEZWNvZGVyLmlucHV0U2l6ZSA9IElOVDE2X1NJWkVcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRVhSRGVjb2Rlci50eXBlID09IDIpIHtcbiAgICAgICAgLy8gZmxvYXRcbiAgICAgICAgc3dpdGNoIChvdXRwdXRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyLmdldHRlciA9IHBhcnNlRmxvYXQzMlxuICAgICAgICAgICAgRVhSRGVjb2Rlci5pbnB1dFNpemUgPSBGTE9BVDMyX1NJWkVcbiAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyLmdldHRlciA9IGRlY29kZUZsb2F0MzJcbiAgICAgICAgICAgIEVYUkRlY29kZXIuaW5wdXRTaXplID0gRkxPQVQzMl9TSVpFXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICdFWFJMb2FkZXIucGFyc2U6IHVuc3VwcG9ydGVkIHBpeGVsVHlwZSAnICsgRVhSRGVjb2Rlci50eXBlICsgJyBmb3IgJyArIEVYUkhlYWRlci5jb21wcmVzc2lvbiArICcuJ1xuICAgICAgfVxuXG4gICAgICBFWFJEZWNvZGVyLmJsb2NrQ291bnQgPSAoRVhSSGVhZGVyLmRhdGFXaW5kb3cueU1heCArIDEpIC8gRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEVYUkRlY29kZXIuYmxvY2tDb3VudDsgaSsrKSBwYXJzZUludDY0KGRhdGFWaWV3LCBvZmZzZXQpIC8vIHNjYW5saW5lT2Zmc2V0XG5cbiAgICAgIC8vIHdlIHNob3VsZCBiZSBwYXNzZWQgdGhlIHNjYW5saW5lIG9mZnNldCB0YWJsZSwgcmVhZHkgdG8gc3RhcnQgcmVhZGluZyBwaXhlbCBkYXRhLlxuXG4gICAgICAvLyBSR0IgaW1hZ2VzIHdpbGwgYmUgY29udmVydGVkIHRvIFJHQkEgZm9ybWF0LCBwcmV2ZW50aW5nIHNvZnR3YXJlIGVtdWxhdGlvbiBpbiBzZWxlY3QgZGV2aWNlcy5cbiAgICAgIEVYUkRlY29kZXIub3V0cHV0Q2hhbm5lbHMgPSBFWFJEZWNvZGVyLmNoYW5uZWxzID09IDMgPyA0IDogRVhSRGVjb2Rlci5jaGFubmVsc1xuICAgICAgY29uc3Qgc2l6ZSA9IEVYUkRlY29kZXIud2lkdGggKiBFWFJEZWNvZGVyLmhlaWdodCAqIEVYUkRlY29kZXIub3V0cHV0Q2hhbm5lbHNcblxuICAgICAgc3dpdGNoIChvdXRwdXRUeXBlKSB7XG4gICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICAgIEVYUkRlY29kZXIuYnl0ZUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShzaXplKVxuXG4gICAgICAgICAgLy8gRmlsbCBpbml0aWFsbHkgd2l0aCAxcyBmb3IgdGhlIGFscGhhIHZhbHVlIGlmIHRoZSB0ZXh0dXJlIGlzIG5vdCBSR0JBLCBSR0IgdmFsdWVzIHdpbGwgYmUgb3ZlcndyaXR0ZW5cbiAgICAgICAgICBpZiAoRVhSRGVjb2Rlci5jaGFubmVscyA8IEVYUkRlY29kZXIub3V0cHV0Q2hhbm5lbHMpIEVYUkRlY29kZXIuYnl0ZUFycmF5LmZpbGwoMSwgMCwgc2l6ZSlcblxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgIEVYUkRlY29kZXIuYnl0ZUFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHNpemUpXG5cbiAgICAgICAgICBpZiAoRVhSRGVjb2Rlci5jaGFubmVscyA8IEVYUkRlY29kZXIub3V0cHV0Q2hhbm5lbHMpIEVYUkRlY29kZXIuYnl0ZUFycmF5LmZpbGwoMHgzYzAwLCAwLCBzaXplKSAvLyBVaW50MTZBcnJheSBob2xkcyBoYWxmIGZsb2F0IGRhdGEsIDB4M0MwMCBpcyAxXG5cbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuRVhSTG9hZGVyOiB1bnN1cHBvcnRlZCB0eXBlOiAnLCBvdXRwdXRUeXBlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIEVYUkRlY29kZXIuYnl0ZXNQZXJMaW5lID0gRVhSRGVjb2Rlci53aWR0aCAqIEVYUkRlY29kZXIuaW5wdXRTaXplICogRVhSRGVjb2Rlci5jaGFubmVsc1xuXG4gICAgICBpZiAoRVhSRGVjb2Rlci5vdXRwdXRDaGFubmVscyA9PSA0KSBFWFJEZWNvZGVyLmZvcm1hdCA9IFJHQkFGb3JtYXRcbiAgICAgIGVsc2UgRVhSRGVjb2Rlci5mb3JtYXQgPSBSZWRGb3JtYXRcblxuICAgICAgaWYgKGhhc0NvbG9yU3BhY2UpIEVYUkRlY29kZXIuY29sb3JTcGFjZSA9ICdzcmdiLWxpbmVhcidcbiAgICAgIGVsc2UgRVhSRGVjb2Rlci5lbmNvZGluZyA9IDMwMDAgLy8gTGluZWFyRW5jb2RpbmdcblxuICAgICAgcmV0dXJuIEVYUkRlY29kZXJcbiAgICB9XG5cbiAgICAvLyBzdGFydCBwYXJzaW5nIGZpbGUgW1NUQVJUXVxuXG4gICAgY29uc3QgYnVmZmVyRGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKVxuICAgIGNvbnN0IHVJbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpXG4gICAgY29uc3Qgb2Zmc2V0ID0geyB2YWx1ZTogMCB9XG5cbiAgICAvLyBnZXQgaGVhZGVyIGluZm9ybWF0aW9uIGFuZCB2YWxpZGF0ZSBmb3JtYXQuXG4gICAgY29uc3QgRVhSSGVhZGVyID0gcGFyc2VIZWFkZXIoYnVmZmVyRGF0YVZpZXcsIGJ1ZmZlciwgb2Zmc2V0KVxuXG4gICAgLy8gZ2V0IGlucHV0IGNvbXByZXNzaW9uIGluZm9ybWF0aW9uIGFuZCBwcmVwYXJlIGRlY29kaW5nLlxuICAgIGNvbnN0IEVYUkRlY29kZXIgPSBzZXR1cERlY29kZXIoRVhSSGVhZGVyLCBidWZmZXJEYXRhVmlldywgdUludDhBcnJheSwgb2Zmc2V0LCB0aGlzLnR5cGUpXG5cbiAgICBjb25zdCB0bXBPZmZzZXQgPSB7IHZhbHVlOiAwIH1cbiAgICBjb25zdCBjaGFubmVsT2Zmc2V0cyA9IHsgUjogMCwgRzogMSwgQjogMiwgQTogMywgWTogMCB9XG5cbiAgICBmb3IgKFxuICAgICAgbGV0IHNjYW5saW5lQmxvY2tJZHggPSAwO1xuICAgICAgc2NhbmxpbmVCbG9ja0lkeCA8IEVYUkRlY29kZXIuaGVpZ2h0IC8gRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTtcbiAgICAgIHNjYW5saW5lQmxvY2tJZHgrK1xuICAgICkge1xuICAgICAgY29uc3QgbGluZSA9IHBhcnNlVWludDMyKGJ1ZmZlckRhdGFWaWV3LCBvZmZzZXQpIC8vIGxpbmVfbm9cbiAgICAgIEVYUkRlY29kZXIuc2l6ZSA9IHBhcnNlVWludDMyKGJ1ZmZlckRhdGFWaWV3LCBvZmZzZXQpIC8vIGRhdGFfbGVuXG4gICAgICBFWFJEZWNvZGVyLmxpbmVzID1cbiAgICAgICAgbGluZSArIEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemUgPiBFWFJEZWNvZGVyLmhlaWdodFxuICAgICAgICAgID8gRVhSRGVjb2Rlci5oZWlnaHQgLSBsaW5lXG4gICAgICAgICAgOiBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplXG5cbiAgICAgIGNvbnN0IGlzQ29tcHJlc3NlZCA9IEVYUkRlY29kZXIuc2l6ZSA8IEVYUkRlY29kZXIubGluZXMgKiBFWFJEZWNvZGVyLmJ5dGVzUGVyTGluZVxuICAgICAgY29uc3Qgdmlld2VyID0gaXNDb21wcmVzc2VkID8gRVhSRGVjb2Rlci51bmNvbXByZXNzKEVYUkRlY29kZXIpIDogdW5jb21wcmVzc1JBVyhFWFJEZWNvZGVyKVxuXG4gICAgICBvZmZzZXQudmFsdWUgKz0gRVhSRGVjb2Rlci5zaXplXG5cbiAgICAgIGZvciAobGV0IGxpbmVfeSA9IDA7IGxpbmVfeSA8IEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemU7IGxpbmVfeSsrKSB7XG4gICAgICAgIGNvbnN0IHRydWVfeSA9IGxpbmVfeSArIHNjYW5saW5lQmxvY2tJZHggKiBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplXG4gICAgICAgIGlmICh0cnVlX3kgPj0gRVhSRGVjb2Rlci5oZWlnaHQpIGJyZWFrXG5cbiAgICAgICAgZm9yIChsZXQgY2hhbm5lbElEID0gMDsgY2hhbm5lbElEIDwgRVhSRGVjb2Rlci5jaGFubmVsczsgY2hhbm5lbElEKyspIHtcbiAgICAgICAgICBjb25zdCBjT2ZmID0gY2hhbm5lbE9mZnNldHNbRVhSSGVhZGVyLmNoYW5uZWxzW2NoYW5uZWxJRF0ubmFtZV1cblxuICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgRVhSRGVjb2Rlci53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICB0bXBPZmZzZXQudmFsdWUgPVxuICAgICAgICAgICAgICAobGluZV95ICogKEVYUkRlY29kZXIuY2hhbm5lbHMgKiBFWFJEZWNvZGVyLndpZHRoKSArIGNoYW5uZWxJRCAqIEVYUkRlY29kZXIud2lkdGggKyB4KSAqXG4gICAgICAgICAgICAgIEVYUkRlY29kZXIuaW5wdXRTaXplXG4gICAgICAgICAgICBjb25zdCBvdXRJbmRleCA9XG4gICAgICAgICAgICAgIChFWFJEZWNvZGVyLmhlaWdodCAtIDEgLSB0cnVlX3kpICogKEVYUkRlY29kZXIud2lkdGggKiBFWFJEZWNvZGVyLm91dHB1dENoYW5uZWxzKSArXG4gICAgICAgICAgICAgIHggKiBFWFJEZWNvZGVyLm91dHB1dENoYW5uZWxzICtcbiAgICAgICAgICAgICAgY09mZlxuICAgICAgICAgICAgRVhSRGVjb2Rlci5ieXRlQXJyYXlbb3V0SW5kZXhdID0gRVhSRGVjb2Rlci5nZXR0ZXIodmlld2VyLCB0bXBPZmZzZXQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRlcjogRVhSSGVhZGVyLFxuICAgICAgd2lkdGg6IEVYUkRlY29kZXIud2lkdGgsXG4gICAgICBoZWlnaHQ6IEVYUkRlY29kZXIuaGVpZ2h0LFxuICAgICAgZGF0YTogRVhSRGVjb2Rlci5ieXRlQXJyYXksXG4gICAgICBmb3JtYXQ6IEVYUkRlY29kZXIuZm9ybWF0LFxuICAgICAgW2hhc0NvbG9yU3BhY2UgPyAnY29sb3JTcGFjZScgOiAnZW5jb2RpbmcnXTogRVhSRGVjb2RlcltoYXNDb2xvclNwYWNlID8gJ2NvbG9yU3BhY2UnIDogJ2VuY29kaW5nJ10sXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgfVxuICB9XG5cbiAgc2V0RGF0YVR5cGUodmFsdWUpIHtcbiAgICB0aGlzLnR5cGUgPSB2YWx1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgZnVuY3Rpb24gb25Mb2FkQ2FsbGJhY2sodGV4dHVyZSwgdGV4RGF0YSkge1xuICAgICAgaWYgKGhhc0NvbG9yU3BhY2UpIHRleHR1cmUuY29sb3JTcGFjZSA9IHRleERhdGEuY29sb3JTcGFjZVxuICAgICAgZWxzZSB0ZXh0dXJlLmVuY29kaW5nID0gdGV4RGF0YS5lbmNvZGluZ1xuICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXJcbiAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyXG4gICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlXG4gICAgICB0ZXh0dXJlLmZsaXBZID0gZmFsc2VcblxuICAgICAgaWYgKG9uTG9hZCkgb25Mb2FkKHRleHR1cmUsIHRleERhdGEpXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmxvYWQodXJsLCBvbkxvYWRDYWxsYmFjaywgb25Qcm9ncmVzcywgb25FcnJvcilcbiAgfVxufVxuXG5leHBvcnQgeyBFWFJMb2FkZXIgfVxuIl0sIm5hbWVzIjpbImhhc0NvbG9yU3BhY2UiLCJ2ZXJzaW9uIiwiRVhSTG9hZGVyIiwiRGF0YVRleHR1cmVMb2FkZXIiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiLCJ0eXBlIiwiSGFsZkZsb2F0VHlwZSIsInBhcnNlIiwiYnVmZmVyIiwiVVNIT1JUX1JBTkdFIiwiQklUTUFQX1NJWkUiLCJIVUZfRU5DQklUUyIsIkhVRl9ERUNCSVRTIiwiSFVGX0VOQ1NJWkUiLCJIVUZfREVDU0laRSIsIkhVRl9ERUNNQVNLIiwiTkJJVFMiLCJBX09GRlNFVCIsIk1PRF9NQVNLIiwiU0hPUlRfWkVST0NPREVfUlVOIiwiTE9OR19aRVJPQ09ERV9SVU4iLCJTSE9SVEVTVF9MT05HX1JVTiIsIlVMT05HX1NJWkUiLCJGTE9BVDMyX1NJWkUiLCJJTlQzMl9TSVpFIiwiSU5UMTZfU0laRSIsIklOVDhfU0laRSIsIlNUQVRJQ19IVUZGTUFOIiwiREVGTEFURSIsIlVOS05PV04iLCJMT1NTWV9EQ1QiLCJSTEUiLCJsb2dCYXNlIiwiTWF0aCIsInBvdyIsInJldmVyc2VMdXRGcm9tQml0bWFwIiwiYml0bWFwIiwibHV0IiwiayIsImkiLCJuIiwiaHVmQ2xlYXJEZWNUYWJsZSIsImhkZWMiLCJsZW4iLCJsaXQiLCJwIiwiZ2V0Qml0c1JldHVybiIsImwiLCJjIiwibGMiLCJnZXRCaXRzIiwibkJpdHMiLCJ1SW50OEFycmF5IiwiaW5PZmZzZXQiLCJwYXJzZVVpbnQ4QXJyYXkiLCJodWZUYWJsZUJ1ZmZlciIsIkFycmF5IiwiaHVmQ2Fub25pY2FsQ29kZVRhYmxlIiwiaGNvZGUiLCJuYyIsImh1ZlVucGFja0VuY1RhYmxlIiwiaW5EYXRhVmlldyIsIm5pIiwiaW0iLCJpTSIsInZhbHVlIiwiemVydW4iLCJodWZMZW5ndGgiLCJjb2RlIiwiaHVmQ29kZSIsImh1ZkJ1aWxkRGVjVGFibGUiLCJoZGVjb2QiLCJwbCIsInBsT2Zmc2V0IiwiZ2V0Q2hhclJldHVybiIsImdldENoYXIiLCJnZXRDb2RlUmV0dXJuIiwiZ2V0Q29kZSIsInBvIiwicmxjIiwib3V0QnVmZmVyIiwib3V0QnVmZmVyT2Zmc2V0Iiwib3V0QnVmZmVyRW5kT2Zmc2V0IiwiY3MiLCJVaW50OEFycmF5IiwicyIsIlVJbnQxNiIsIkludDE2IiwicmVmIiwid2RlYzE0UmV0dXJuIiwiYSIsImIiLCJ3ZGVjMTQiLCJoIiwibHMiLCJocyIsImhpIiwiYWkiLCJhcyIsImJzIiwid2RlYzE2IiwibSIsImQiLCJiYiIsImFhIiwid2F2MkRlY29kZSIsImoiLCJueCIsIm94IiwibnkiLCJveSIsIm14IiwidzE0IiwicDIiLCJweSIsImV5Iiwib3kxIiwib3kyIiwib3gxIiwib3gyIiwiaTAwIiwiaTAxIiwiaTEwIiwiaTExIiwicHgiLCJleCIsInAwMSIsInAxMCIsInAxMSIsImh1ZkRlY29kZSIsImVuY29kaW5nVGFibGUiLCJkZWNvZGluZ1RhYmxlIiwibm8iLCJvdXRPZmZzZXQiLCJpbk9mZnNldEVuZCIsInRydW5jIiwiaW5kZXgiLCJodWZVbmNvbXByZXNzIiwibkNvbXByZXNzZWQiLCJuUmF3IiwiaW5pdGlhbEluT2Zmc2V0IiwicGFyc2VVaW50MzIiLCJmcmVxIiwiYXBwbHlMdXQiLCJkYXRhIiwibkRhdGEiLCJwcmVkaWN0b3IiLCJzb3VyY2UiLCJ0IiwibGVuZ3RoIiwiaW50ZXJsZWF2ZVNjYWxhciIsIm91dCIsInQxIiwidDIiLCJmbG9vciIsInN0b3AiLCJkZWNvZGVSdW5MZW5ndGgiLCJzaXplIiwiYnl0ZUxlbmd0aCIsInJlYWRlciIsIkRhdGFWaWV3IiwiZ2V0SW50OCIsImNvdW50IiwicHVzaCIsImdldFVpbnQ4IiwibG9zc3lEY3REZWNvZGUiLCJjc2NTZXQiLCJyb3dQdHJzIiwiY2hhbm5lbERhdGEiLCJhY0J1ZmZlciIsImRjQnVmZmVyIiwiZGF0YVZpZXciLCJ3aWR0aCIsImlkeCIsImhlaWdodCIsIm51bUNvbXAiLCJudW1GdWxsQmxvY2tzWCIsIm51bUJsb2Nrc1giLCJjZWlsIiwibnVtQmxvY2tzWSIsImxlZnRvdmVyWCIsImxlZnRvdmVyWSIsImN1cnJBY0NvbXAiLCJjdXJyRGNDb21wIiwiZGN0RGF0YSIsImhhbGZaaWdCbG9jayIsInJvd0Jsb2NrIiwicm93T2Zmc2V0cyIsImNvbXAiLCJGbG9hdDMyQXJyYXkiLCJVaW50MTZBcnJheSIsImJsb2NreSIsIm1heFkiLCJtYXhYIiwiYmxvY2t4IiwiZmlsbCIsInVuUmxlQUMiLCJ1blppZ1phZyIsImRjdEludmVyc2UiLCJjc2M3MDlJbnZlcnNlIiwiY29udmVydFRvSGFsZiIsIm9mZnNldCIsInkiLCJzcmMiLCJzZXRVaW50MTYiLCJ4IiwiaGFsZlJvdyIsImRlY29kZWQiLCJnZXRVaW50MTYiLCJzZXRGbG9hdDMyIiwiZGVjb2RlRmxvYXQxNiIsImFjVmFsdWUiLCJkY3RDb21wIiwiZHN0IiwiY29zIiwiZSIsImYiLCJnIiwiYWxwaGEiLCJiZXRhIiwidGhldGEiLCJnYW1tYSIsInJvdyIsInJvd1B0ciIsImNvbHVtbiIsImNiIiwiY3IiLCJEYXRhVXRpbHMiLCJ0b0hhbGZGbG9hdCIsInRvTGluZWFyIiwiZmxvYXQiLCJzaWduIiwiYWJzIiwidW5jb21wcmVzc1JBVyIsImluZm8iLCJhcnJheSIsInVuY29tcHJlc3NSTEUiLCJjb21wcmVzc2VkIiwidmlld2VyIiwic2xpY2UiLCJyYXdCdWZmZXIiLCJ0bXBCdWZmZXIiLCJ1bmNvbXByZXNzWklQIiwidW56bGliU3luYyIsInVuY29tcHJlc3NQSVoiLCJzY2FubGluZUJsb2NrU2l6ZSIsImNoYW5uZWxzIiwib3V0QnVmZmVyRW5kIiwicGl6Q2hhbm5lbERhdGEiLCJsaW5lcyIsIm1pbk5vblplcm8iLCJwYXJzZVVpbnQxNiIsIm1heE5vblplcm8iLCJwYXJzZVVpbnQ4IiwibWF4VmFsdWUiLCJjZCIsInN0YXJ0IiwidG1wT2Zmc2V0IiwiY3AiLCJlbmQiLCJzZXQiLCJ1bmNvbXByZXNzUFhSIiwic3oiLCJVaW50MzJBcnJheSIsInRtcEJ1ZmZlckVuZCIsIndyaXRlUHRyIiwicHRyIiwicGl4ZWwiLCJkaWZmIiwidW5jb21wcmVzc0RXQSIsImR3YUhlYWRlciIsInBhcnNlSW50NjQiLCJ1bmtub3duVW5jb21wcmVzc2VkU2l6ZSIsInVua25vd25Db21wcmVzc2VkU2l6ZSIsImFjQ29tcHJlc3NlZFNpemUiLCJkY0NvbXByZXNzZWRTaXplIiwicmxlQ29tcHJlc3NlZFNpemUiLCJybGVVbmNvbXByZXNzZWRTaXplIiwicmxlUmF3U2l6ZSIsInRvdGFsQWNVbmNvbXByZXNzZWRDb3VudCIsInRvdGFsRGNVbmNvbXByZXNzZWRDb3VudCIsImFjQ29tcHJlc3Npb24iLCJFWFJIZWFkZXIiLCJjb21wcmVzc2lvbiIsImNoYW5uZWxSdWxlcyIsInJ1bGVTaXplIiwibmFtZSIsInBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmciLCJjc2MiLCJJbnQ4QXJyYXkiLCJjaGFubmVsIiwicGl4ZWxUeXBlIiwicExpbmVhciIsInJ1bGUiLCJ6bGliSW5mbyIsInJsZUJ1ZmZlciIsImNoYW4iLCJybGVPZmZzZXQiLCJyb3dPZmZzZXRCeXRlcyIsImJ5dGUiLCJ1aW50QnVmZmVyIiwiZW5kT2Zmc2V0Iiwic3RyaW5nVmFsdWUiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsInBhcnNlRml4ZWRMZW5ndGhTdHJpbmciLCJwYXJzZVJhdGlvbmFsIiwicGFyc2VJbnQzMiIsInBhcnNlVGltZWNvZGUiLCJJbnQzMiIsImdldEludDMyIiwiVWludDMyIiwiZ2V0VWludDMyIiwiVWludDgiLCJpbnQiLCJwcm90b3R5cGUiLCJOdW1iZXIiLCJnZXRCaWdJbnQ2NCIsInBhcnNlRmxvYXQzMiIsImdldEZsb2F0MzIiLCJkZWNvZGVGbG9hdDMyIiwiYmluYXJ5IiwiZXhwb25lbnQiLCJmcmFjdGlvbiIsIk5hTiIsIkluZmluaXR5IiwiVWludDE2IiwicGFyc2VGbG9hdDE2IiwicGFyc2VDaGxpc3QiLCJzdGFydE9mZnNldCIsInhTYW1wbGluZyIsInlTYW1wbGluZyIsInBhcnNlQ2hyb21hdGljaXRpZXMiLCJyZWRYIiwicmVkWSIsImdyZWVuWCIsImdyZWVuWSIsImJsdWVYIiwiYmx1ZVkiLCJ3aGl0ZVgiLCJ3aGl0ZVkiLCJwYXJzZUNvbXByZXNzaW9uIiwiY29tcHJlc3Npb25Db2RlcyIsInBhcnNlQm94MmkiLCJ4TWluIiwieU1pbiIsInhNYXgiLCJ5TWF4IiwicGFyc2VMaW5lT3JkZXIiLCJsaW5lT3JkZXJzIiwibGluZU9yZGVyIiwicGFyc2VWMmYiLCJwYXJzZVYzZiIsInoiLCJwYXJzZVZhbHVlIiwicGFyc2VIZWFkZXIiLCJzcGVjIiwic2luZ2xlVGlsZSIsImxvbmdOYW1lIiwiZGVlcEZvcm1hdCIsIm11bHRpUGFydCIsImtlZXBSZWFkaW5nIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZVR5cGUiLCJhdHRyaWJ1dGVTaXplIiwiYXR0cmlidXRlVmFsdWUiLCJjb25zb2xlIiwid2FybiIsImVycm9yIiwic2V0dXBEZWNvZGVyIiwib3V0cHV0VHlwZSIsIkVYUkRlY29kZXIiLCJkYXRhV2luZG93IiwiYnl0ZXNQZXJMaW5lIiwiaW5wdXRTaXplIiwidW5jb21wcmVzcyIsImdldHRlciIsImZvcm1hdCIsIkZsb2F0VHlwZSIsImJsb2NrQ291bnQiLCJvdXRwdXRDaGFubmVscyIsImJ5dGVBcnJheSIsIlJHQkFGb3JtYXQiLCJSZWRGb3JtYXQiLCJjb2xvclNwYWNlIiwiZW5jb2RpbmciLCJidWZmZXJEYXRhVmlldyIsImNoYW5uZWxPZmZzZXRzIiwiUiIsIkciLCJCIiwiQSIsIlkiLCJzY2FubGluZUJsb2NrSWR4IiwibGluZSIsImlzQ29tcHJlc3NlZCIsImxpbmVfeSIsInRydWVfeSIsImNoYW5uZWxJRCIsImNPZmYiLCJvdXRJbmRleCIsImhlYWRlciIsInNldERhdGFUeXBlIiwibG9hZCIsInVybCIsIm9uTG9hZCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwib25Mb2FkQ2FsbGJhY2siLCJ0ZXh0dXJlIiwidGV4RGF0YSIsIm1pbkZpbHRlciIsIkxpbmVhckZpbHRlciIsIm1hZ0ZpbHRlciIsImdlbmVyYXRlTWlwbWFwcyIsImZsaXBZIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/EXRLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/RGBELoader.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/RGBELoader.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RGBELoader: () => (/* binding */ RGBELoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nclass RGBELoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n    }\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n    parse(buffer) {\n        const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n            switch(rgbe_error_code){\n                case rgbe_read_error:\n                    throw new Error(\"THREE.RGBELoader: Read Error: \" + (msg || \"\"));\n                case rgbe_write_error:\n                    throw new Error(\"THREE.RGBELoader: Write Error: \" + (msg || \"\"));\n                case rgbe_format_error:\n                    throw new Error(\"THREE.RGBELoader: Bad File Format: \" + (msg || \"\"));\n                default:\n                case rgbe_memory_error:\n                    throw new Error(\"THREE.RGBELoader: Memory Error: \" + (msg || \"\"));\n            }\n        }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer2, lineLimit, consume) {\n            const chunkSize = 128;\n            lineLimit = !lineLimit ? 1024 : lineLimit;\n            let p = buffer2.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength){\n                s += chunk;\n                len += chunk.length;\n                p += chunkSize;\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            }\n            if (-1 < i) {\n                if (false !== consume) buffer2.pos += len + i + 1;\n                return s + chunk.slice(0, i);\n            }\n            return false;\n        }, RGBE_ReadHeader = function(buffer2) {\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\n                valid: 0,\n                string: \"\",\n                comments: \"\",\n                programtype: \"RGBE\",\n                format: \"\",\n                gamma: 1,\n                exposure: 1,\n                width: 0,\n                height: 0\n            };\n            let line, match;\n            if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {\n                rgbe_error(rgbe_read_error, \"no header found\");\n            }\n            if (!(match = line.match(magic_token_re))) {\n                rgbe_error(rgbe_format_error, \"bad initial token\");\n            }\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\n            header.programtype = match[1];\n            header.string += line + \"\\n\";\n            while(true){\n                line = fgets(buffer2);\n                if (false === line) break;\n                header.string += line + \"\\n\";\n                if (\"#\" === line.charAt(0)) {\n                    header.comments += line + \"\\n\";\n                    continue;\n                }\n                if (match = line.match(gamma_re)) {\n                    header.gamma = parseFloat(match[1]);\n                }\n                if (match = line.match(exposure_re)) {\n                    header.exposure = parseFloat(match[1]);\n                }\n                if (match = line.match(format_re)) {\n                    header.valid |= RGBE_VALID_FORMAT;\n                    header.format = match[1];\n                }\n                if (match = line.match(dimensions_re)) {\n                    header.valid |= RGBE_VALID_DIMENSIONS;\n                    header.height = parseInt(match[1], 10);\n                    header.width = parseInt(match[2], 10);\n                }\n                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n            }\n            if (!(header.valid & RGBE_VALID_FORMAT)) {\n                rgbe_error(rgbe_format_error, \"missing format specifier\");\n            }\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n                rgbe_error(rgbe_format_error, \"missing image size specifier\");\n            }\n            return header;\n        }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {\n            const scanline_width = w2;\n            if (// run length encoding is not allowed so read flat\n            scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded\n            2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128) {\n                return new Uint8Array(buffer2);\n            }\n            if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {\n                rgbe_error(rgbe_format_error, \"wrong scanline width\");\n            }\n            const data_rgba = new Uint8Array(4 * w2 * h2);\n            if (!data_rgba.length) {\n                rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n            }\n            let offset = 0, pos = 0;\n            const ptr_end = 4 * scanline_width;\n            const rgbeStart = new Uint8Array(4);\n            const scanline_buffer = new Uint8Array(ptr_end);\n            let num_scanlines = h2;\n            while(num_scanlines > 0 && pos < buffer2.byteLength){\n                if (pos + 4 > buffer2.byteLength) {\n                    rgbe_error(rgbe_read_error);\n                }\n                rgbeStart[0] = buffer2[pos++];\n                rgbeStart[1] = buffer2[pos++];\n                rgbeStart[2] = buffer2[pos++];\n                rgbeStart[3] = buffer2[pos++];\n                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n                    rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n                }\n                let ptr = 0, count;\n                while(ptr < ptr_end && pos < buffer2.byteLength){\n                    count = buffer2[pos++];\n                    const isEncodedRun = count > 128;\n                    if (isEncodedRun) count -= 128;\n                    if (0 === count || ptr + count > ptr_end) {\n                        rgbe_error(rgbe_format_error, \"bad scanline data\");\n                    }\n                    if (isEncodedRun) {\n                        const byteValue = buffer2[pos++];\n                        for(let i = 0; i < count; i++){\n                            scanline_buffer[ptr++] = byteValue;\n                        }\n                    } else {\n                        scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);\n                        ptr += count;\n                        pos += count;\n                    }\n                }\n                const l = scanline_width;\n                for(let i = 0; i < l; i++){\n                    let off = 0;\n                    data_rgba[offset] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\n                    offset += 4;\n                }\n                num_scanlines--;\n            }\n            return data_rgba;\n        };\n        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            destArray[destOffset + 3] = 1;\n        };\n        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n            destArray[destOffset + 1] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n            destArray[destOffset + 2] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n            destArray[destOffset + 3] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(1);\n        };\n        const byteArray = new Uint8Array(buffer);\n        byteArray.pos = 0;\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\n        const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n        let data, type;\n        let numElements;\n        switch(this.type){\n            case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                numElements = image_rgba_data.length / 4;\n                const floatArray = new Float32Array(numElements * 4);\n                for(let j = 0; j < numElements; j++){\n                    RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n                }\n                data = floatArray;\n                type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                numElements = image_rgba_data.length / 4;\n                const halfArray = new Uint16Array(numElements * 4);\n                for(let j = 0; j < numElements; j++){\n                    RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n                }\n                data = halfArray;\n                type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n                break;\n            default:\n                throw new Error(\"THREE.RGBELoader: Unsupported type: \" + this.type);\n        }\n        return {\n            width: w,\n            height: h,\n            data,\n            header: rgbe_header_info.string,\n            gamma: rgbe_header_info.gamma,\n            exposure: rgbe_header_info.exposure,\n            type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            switch(texture.type){\n                case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    if (\"colorSpace\" in texture) texture.colorSpace = \"srgb-linear\";\n                    else texture.encoding = 3e3;\n                    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n            }\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=RGBELoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL1JHQkVMb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBS0EsTUFBTUEsbUJBQW1CQyxvREFBaUJBO0lBQ3hDQyxZQUFZQyxPQUFBLENBQVM7UUFDbkIsTUFBTUE7UUFFTixLQUFLQyxJQUFBLEdBQU9DLGdEQUFhQTtJQUMxQjtJQUFBO0lBSURDLE1BQU1DLE1BQUEsRUFBUTtRQUNaLE1BQ0VDLGtCQUFrQixHQUNsQkMsbUJBQW1CLEdBQ25CQyxvQkFBb0IsR0FDcEJDLG9CQUFvQixHQUNwQkMsYUFBYSxTQUFVQyxlQUFBLEVBQWlCQyxHQUFBO1lBQ3RDLE9BQVFEO2dCQUNOLEtBQUtMO29CQUNILE1BQU0sSUFBSU8sTUFBTSxtQ0FBb0NELENBQUFBLE9BQU87Z0JBQzdELEtBQUtMO29CQUNILE1BQU0sSUFBSU0sTUFBTSxvQ0FBcUNELENBQUFBLE9BQU87Z0JBQzlELEtBQUtKO29CQUNILE1BQU0sSUFBSUssTUFBTSx3Q0FBeUNELENBQUFBLE9BQU87Z0JBQ2xFO2dCQUNBLEtBQUtIO29CQUNILE1BQU0sSUFBSUksTUFBTSxxQ0FBc0NELENBQUFBLE9BQU87WUFDaEU7UUFDRixHQVVERSx5QkFBeUIsR0FDekJDLG9CQUFvQixHQUNwQkMsd0JBQXdCLEdBQ3hCQyxVQUFVLE1BQ1ZDLFFBQVEsU0FBVWIsT0FBQUEsRUFBUWMsU0FBQSxFQUFXQyxPQUFBO1lBQ25DLE1BQU1DLFlBQVk7WUFFbEJGLFlBQVksQ0FBQ0EsWUFBWSxPQUFPQTtZQUNoQyxJQUFJRyxJQUFJakIsUUFBT2tCLEdBQUEsRUFDYkMsSUFBSSxJQUNKQyxNQUFNLEdBQ05DLElBQUksSUFDSkMsUUFBUUMsT0FBT0MsWUFBQSxDQUFhQyxLQUFBLENBQU0sTUFBTSxJQUFJQyxZQUFZMUIsUUFBTzJCLFFBQUEsQ0FBU1YsR0FBR0EsSUFBSUQ7WUFFakYsTUFBTyxJQUFLRyxDQUFBQSxJQUFJRyxNQUFNTSxPQUFBLENBQVFoQixRQUFPLEtBQU1RLE1BQU1OLGFBQWFHLElBQUlqQixRQUFPNkIsVUFBQSxDQUFZO2dCQUNuRlIsS0FBS0M7Z0JBQ0xGLE9BQU9FLE1BQU1RLE1BQUE7Z0JBQ2JiLEtBQUtEO2dCQUNMTSxTQUFTQyxPQUFPQyxZQUFBLENBQWFDLEtBQUEsQ0FBTSxNQUFNLElBQUlDLFlBQVkxQixRQUFPMkIsUUFBQSxDQUFTVixHQUFHQSxJQUFJRDtZQUNqRjtZQUVELElBQUksS0FBS0csR0FBRztnQkFPVixJQUFJLFVBQVVKLFNBQVNmLFFBQU9rQixHQUFBLElBQU9FLE1BQU1ELElBQUk7Z0JBQy9DLE9BQU9FLElBQUlDLE1BQU1TLEtBQUEsQ0FBTSxHQUFHWjtZQUMzQjtZQUVELE9BQU87UUFDUixHQUVEYSxrQkFBa0IsU0FBVWhDLE9BQUFBO1lBRTFCLE1BQU1pQyxpQkFBaUIsYUFDckJDLFdBQVcscUNBQ1hDLGNBQWMsd0NBQ2RDLFlBQVksd0JBQ1pDLGdCQUFnQixxQ0FFaEJDLFNBQVM7Z0JBQ1BDLE9BQU87Z0JBRVBDLFFBQVE7Z0JBRVJDLFVBQVU7Z0JBRVZDLGFBQWE7Z0JBRWJDLFFBQVE7Z0JBRVJDLE9BQU87Z0JBRVBDLFVBQVU7Z0JBRVZDLE9BQU87Z0JBQ1BDLFFBQVE7WUFDVDtZQUVILElBQUlDLE1BQU1DO1lBRVYsSUFBSWpELFFBQU9rQixHQUFBLElBQU9sQixRQUFPNkIsVUFBQSxJQUFjLENBQUVtQixDQUFBQSxPQUFPbkMsTUFBTWIsUUFBTSxHQUFJO2dCQUM5REssV0FBV0osaUJBQWlCO1lBQzdCO1lBR0QsSUFBSSxDQUFFZ0QsQ0FBQUEsUUFBUUQsS0FBS0MsS0FBQSxDQUFNaEIsZUFBYyxHQUFJO2dCQUN6QzVCLFdBQVdGLG1CQUFtQjtZQUMvQjtZQUVEbUMsT0FBT0MsS0FBQSxJQUFTOUI7WUFDaEI2QixPQUFPSSxXQUFBLEdBQWNPLEtBQUEsQ0FBTSxFQUFDO1lBQzVCWCxPQUFPRSxNQUFBLElBQVVRLE9BQU87WUFFeEIsTUFBTyxLQUFNO2dCQUNYQSxPQUFPbkMsTUFBTWI7Z0JBQ2IsSUFBSSxVQUFVZ0QsTUFBTTtnQkFDcEJWLE9BQU9FLE1BQUEsSUFBVVEsT0FBTztnQkFFeEIsSUFBSSxRQUFRQSxLQUFLRSxNQUFBLENBQU8sSUFBSTtvQkFDMUJaLE9BQU9HLFFBQUEsSUFBWU8sT0FBTztvQkFDMUI7Z0JBQ0Q7Z0JBRUQsSUFBS0MsUUFBUUQsS0FBS0MsS0FBQSxDQUFNZixXQUFZO29CQUNsQ0ksT0FBT00sS0FBQSxHQUFRTyxXQUFXRixLQUFBLENBQU0sRUFBRTtnQkFDbkM7Z0JBRUQsSUFBS0EsUUFBUUQsS0FBS0MsS0FBQSxDQUFNZCxjQUFlO29CQUNyQ0csT0FBT08sUUFBQSxHQUFXTSxXQUFXRixLQUFBLENBQU0sRUFBRTtnQkFDdEM7Z0JBRUQsSUFBS0EsUUFBUUQsS0FBS0MsS0FBQSxDQUFNYixZQUFhO29CQUNuQ0UsT0FBT0MsS0FBQSxJQUFTN0I7b0JBQ2hCNEIsT0FBT0ssTUFBQSxHQUFTTSxLQUFBLENBQU0sRUFBQztnQkFDeEI7Z0JBRUQsSUFBS0EsUUFBUUQsS0FBS0MsS0FBQSxDQUFNWixnQkFBaUI7b0JBQ3ZDQyxPQUFPQyxLQUFBLElBQVM1QjtvQkFDaEIyQixPQUFPUyxNQUFBLEdBQVNLLFNBQVNILEtBQUEsQ0FBTSxFQUFDLEVBQUc7b0JBQ25DWCxPQUFPUSxLQUFBLEdBQVFNLFNBQVNILEtBQUEsQ0FBTSxFQUFDLEVBQUc7Z0JBQ25DO2dCQUVELElBQUlYLE9BQU9DLEtBQUEsR0FBUTdCLHFCQUFxQjRCLE9BQU9DLEtBQUEsR0FBUTVCLHVCQUF1QjtZQUMvRTtZQUVELElBQUksQ0FBRTJCLENBQUFBLE9BQU9DLEtBQUEsR0FBUTdCLGlCQUFBLEdBQW9CO2dCQUN2Q0wsV0FBV0YsbUJBQW1CO1lBQy9CO1lBRUQsSUFBSSxDQUFFbUMsQ0FBQUEsT0FBT0MsS0FBQSxHQUFRNUIscUJBQUEsR0FBd0I7Z0JBQzNDTixXQUFXRixtQkFBbUI7WUFDL0I7WUFFRCxPQUFPbUM7UUFDUixHQUNEZSxzQkFBc0IsU0FBVXJELE9BQUFBLEVBQVFzRCxFQUFBQSxFQUFHQyxFQUFBQTtZQUN6QyxNQUFNQyxpQkFBaUJGO1lBRXZCO1lBRUVFLGlCQUFpQixLQUNqQkEsaUJBQWlCO1lBRWpCLE1BQU14RCxPQUFBQSxDQUFPLEVBQUMsSUFDZCxNQUFNQSxPQUFBQSxDQUFPLEVBQUMsSUFDZEEsT0FBQUEsQ0FBTyxFQUFDLEdBQUksS0FDWjtnQkFFQSxPQUFPLElBQUl5RCxXQUFXekQ7WUFDdkI7WUFFRCxJQUFJd0QsbUJBQXFCeEQsQ0FBQUEsT0FBQUEsQ0FBTyxFQUFDLElBQUssSUFBS0EsT0FBQUEsQ0FBTyxFQUFDLEdBQUk7Z0JBQ3JESyxXQUFXRixtQkFBbUI7WUFDL0I7WUFFRCxNQUFNdUQsWUFBWSxJQUFJRCxXQUFXLElBQUlILEtBQUlDO1lBRXpDLElBQUksQ0FBQ0csVUFBVTVCLE1BQUEsRUFBUTtnQkFDckJ6QixXQUFXRCxtQkFBbUI7WUFDL0I7WUFFRCxJQUFJdUQsU0FBUyxHQUNYekMsTUFBTTtZQUVSLE1BQU0wQyxVQUFVLElBQUlKO1lBQ3BCLE1BQU1LLFlBQVksSUFBSUosV0FBVztZQUNqQyxNQUFNSyxrQkFBa0IsSUFBSUwsV0FBV0c7WUFDdkMsSUFBSUcsZ0JBQWdCUjtZQUdwQixNQUFPUSxnQkFBZ0IsS0FBSzdDLE1BQU1sQixRQUFPNkIsVUFBQSxDQUFZO2dCQUNuRCxJQUFJWCxNQUFNLElBQUlsQixRQUFPNkIsVUFBQSxFQUFZO29CQUMvQnhCLFdBQVdKO2dCQUNaO2dCQUVENEQsU0FBQSxDQUFVLEVBQUMsR0FBSTdELE9BQUFBLENBQU9rQixNQUFLO2dCQUMzQjJDLFNBQUEsQ0FBVSxFQUFDLEdBQUk3RCxPQUFBQSxDQUFPa0IsTUFBSztnQkFDM0IyQyxTQUFBLENBQVUsRUFBQyxHQUFJN0QsT0FBQUEsQ0FBT2tCLE1BQUs7Z0JBQzNCMkMsU0FBQSxDQUFVLEVBQUMsR0FBSTdELE9BQUFBLENBQU9rQixNQUFLO2dCQUUzQixJQUFJLEtBQUsyQyxTQUFBLENBQVUsRUFBQyxJQUFLLEtBQUtBLFNBQUEsQ0FBVSxFQUFDLEtBQU9BLFNBQUEsQ0FBVSxFQUFDLElBQUssSUFBS0EsU0FBQSxDQUFVLEVBQUMsS0FBTUwsZ0JBQWdCO29CQUNwR25ELFdBQVdGLG1CQUFtQjtnQkFDL0I7Z0JBSUQsSUFBSTZELE1BQU0sR0FDUkM7Z0JBRUYsTUFBT0QsTUFBTUosV0FBVzFDLE1BQU1sQixRQUFPNkIsVUFBQSxDQUFZO29CQUMvQ29DLFFBQVFqRSxPQUFBQSxDQUFPa0IsTUFBSztvQkFDcEIsTUFBTWdELGVBQWVELFFBQVE7b0JBQzdCLElBQUlDLGNBQWNELFNBQVM7b0JBRTNCLElBQUksTUFBTUEsU0FBU0QsTUFBTUMsUUFBUUwsU0FBUzt3QkFDeEN2RCxXQUFXRixtQkFBbUI7b0JBQy9CO29CQUVELElBQUkrRCxjQUFjO3dCQUVoQixNQUFNQyxZQUFZbkUsT0FBQUEsQ0FBT2tCLE1BQUs7d0JBQzlCLFFBQVNDLElBQUksR0FBR0EsSUFBSThDLE9BQU85QyxJQUFLOzRCQUM5QjJDLGVBQUEsQ0FBZ0JFLE1BQUssR0FBSUc7d0JBQzFCO29CQUVmLE9BQW1CO3dCQUVMTCxnQkFBZ0JNLEdBQUEsQ0FBSXBFLFFBQU8yQixRQUFBLENBQVNULEtBQUtBLE1BQU0rQyxRQUFRRDt3QkFDdkRBLE9BQU9DO3dCQUNQL0MsT0FBTytDO29CQUNSO2dCQUNGO2dCQUlELE1BQU1JLElBQUliO2dCQUNWLFFBQVNyQyxJQUFJLEdBQUdBLElBQUlrRCxHQUFHbEQsSUFBSztvQkFDMUIsSUFBSW1ELE1BQU07b0JBQ1ZaLFNBQUEsQ0FBVUMsT0FBTSxHQUFJRyxlQUFBLENBQWdCM0MsSUFBSW1ELElBQUc7b0JBQzNDQSxPQUFPZDtvQkFDUEUsU0FBQSxDQUFVQyxTQUFTLEVBQUMsR0FBSUcsZUFBQSxDQUFnQjNDLElBQUltRCxJQUFHO29CQUMvQ0EsT0FBT2Q7b0JBQ1BFLFNBQUEsQ0FBVUMsU0FBUyxFQUFDLEdBQUlHLGVBQUEsQ0FBZ0IzQyxJQUFJbUQsSUFBRztvQkFDL0NBLE9BQU9kO29CQUNQRSxTQUFBLENBQVVDLFNBQVMsRUFBQyxHQUFJRyxlQUFBLENBQWdCM0MsSUFBSW1ELElBQUc7b0JBQy9DWCxVQUFVO2dCQUNYO2dCQUVESTtZQUNEO1lBRUQsT0FBT0w7UUFDUjtRQUVILE1BQU1hLHFCQUFxQixTQUFVQyxXQUFBLEVBQWFDLFlBQUEsRUFBY0MsU0FBQSxFQUFXQyxVQUFBO1lBQ3pFLE1BQU1DLElBQUlKLFdBQUEsQ0FBWUMsZUFBZSxFQUFDO1lBQ3RDLE1BQU1JLFFBQVFDLEtBQUtDLEdBQUEsQ0FBSSxHQUFLSCxJQUFJLE9BQVM7WUFFekNGLFNBQUEsQ0FBVUMsYUFBYSxFQUFDLEdBQUlILFdBQUEsQ0FBWUMsZUFBZSxFQUFDLEdBQUlJO1lBQzVESCxTQUFBLENBQVVDLGFBQWEsRUFBQyxHQUFJSCxXQUFBLENBQVlDLGVBQWUsRUFBQyxHQUFJSTtZQUM1REgsU0FBQSxDQUFVQyxhQUFhLEVBQUMsR0FBSUgsV0FBQSxDQUFZQyxlQUFlLEVBQUMsR0FBSUk7WUFDNURILFNBQUEsQ0FBVUMsYUFBYSxFQUFDLEdBQUk7UUFDN0I7UUFFRCxNQUFNSyxvQkFBb0IsU0FBVVIsV0FBQSxFQUFhQyxZQUFBLEVBQWNDLFNBQUEsRUFBV0MsVUFBQTtZQUN4RSxNQUFNQyxJQUFJSixXQUFBLENBQVlDLGVBQWUsRUFBQztZQUN0QyxNQUFNSSxRQUFRQyxLQUFLQyxHQUFBLENBQUksR0FBS0gsSUFBSSxPQUFTO1lBR3pDRixTQUFBLENBQVVDLGFBQWEsRUFBQyxHQUFJTSw0Q0FBU0EsQ0FBQ0MsV0FBQSxDQUFZSixLQUFLSyxHQUFBLENBQUlYLFdBQUEsQ0FBWUMsZUFBZSxFQUFDLEdBQUlJLE9BQU87WUFDbEdILFNBQUEsQ0FBVUMsYUFBYSxFQUFDLEdBQUlNLDRDQUFTQSxDQUFDQyxXQUFBLENBQVlKLEtBQUtLLEdBQUEsQ0FBSVgsV0FBQSxDQUFZQyxlQUFlLEVBQUMsR0FBSUksT0FBTztZQUNsR0gsU0FBQSxDQUFVQyxhQUFhLEVBQUMsR0FBSU0sNENBQVNBLENBQUNDLFdBQUEsQ0FBWUosS0FBS0ssR0FBQSxDQUFJWCxXQUFBLENBQVlDLGVBQWUsRUFBQyxHQUFJSSxPQUFPO1lBQ2xHSCxTQUFBLENBQVVDLGFBQWEsRUFBQyxHQUFJTSw0Q0FBU0EsQ0FBQ0MsV0FBQSxDQUFZO1FBQ25EO1FBRUQsTUFBTUUsWUFBWSxJQUFJM0IsV0FBV3pEO1FBQ2pDb0YsVUFBVWxFLEdBQUEsR0FBTTtRQUNoQixNQUFNbUUsbUJBQW1CckQsZ0JBQWdCb0Q7UUFFekMsTUFBTTlCLElBQUkrQixpQkFBaUJ2QyxLQUFBLEVBQ3pCUyxJQUFJOEIsaUJBQWlCdEMsTUFBQSxFQUNyQnVDLGtCQUFrQmpDLG9CQUFvQitCLFVBQVV6RCxRQUFBLENBQVN5RCxVQUFVbEUsR0FBRyxHQUFHb0MsR0FBR0M7UUFFOUUsSUFBSWdDLE1BQU0xRjtRQUNWLElBQUkyRjtRQUVKLE9BQVEsS0FBSzNGLElBQUE7WUFDWCxLQUFLNEYsNENBQVNBO2dCQUNaRCxjQUFjRixnQkFBZ0J4RCxNQUFBLEdBQVM7Z0JBQ3ZDLE1BQU00RCxhQUFhLElBQUlDLGFBQWFILGNBQWM7Z0JBRWxELFFBQVNJLElBQUksR0FBR0EsSUFBSUosYUFBYUksSUFBSztvQkFDcENyQixtQkFBbUJlLGlCQUFpQk0sSUFBSSxHQUFHRixZQUFZRSxJQUFJO2dCQUM1RDtnQkFFREwsT0FBT0c7Z0JBQ1A3RixPQUFPNEYsNENBQVNBO2dCQUNoQjtZQUVGLEtBQUszRixnREFBYUE7Z0JBQ2hCMEYsY0FBY0YsZ0JBQWdCeEQsTUFBQSxHQUFTO2dCQUN2QyxNQUFNK0QsWUFBWSxJQUFJbkUsWUFBWThELGNBQWM7Z0JBRWhELFFBQVNJLElBQUksR0FBR0EsSUFBSUosYUFBYUksSUFBSztvQkFDcENaLGtCQUFrQk0saUJBQWlCTSxJQUFJLEdBQUdDLFdBQVdELElBQUk7Z0JBQzFEO2dCQUVETCxPQUFPTTtnQkFDUGhHLE9BQU9DLGdEQUFhQTtnQkFDcEI7WUFFRjtnQkFDRSxNQUFNLElBQUlVLE1BQU0seUNBQXlDLEtBQUtYLElBQUk7UUFFckU7UUFFRCxPQUFPO1lBQ0xpRCxPQUFPUTtZQUNQUCxRQUFRUTtZQUNSZ0M7WUFDQWpELFFBQVErQyxpQkFBaUI3QyxNQUFBO1lBQ3pCSSxPQUFPeUMsaUJBQWlCekMsS0FBQTtZQUN4QkMsVUFBVXdDLGlCQUFpQnhDLFFBQUE7WUFDM0JoRDtRQUNEO0lBQ0Y7SUFFRGlHLFlBQVlDLEtBQUEsRUFBTztRQUNqQixLQUFLbEcsSUFBQSxHQUFPa0c7UUFDWixPQUFPO0lBQ1I7SUFFREMsS0FBS0MsR0FBQSxFQUFLQyxNQUFBLEVBQVFDLFVBQUEsRUFBWUMsT0FBQSxFQUFTO1FBQ3JDLFNBQVNDLGVBQWVDLE9BQUEsRUFBU0MsT0FBQTtZQUMvQixPQUFRRCxRQUFRekcsSUFBQTtnQkFDZCxLQUFLNEYsNENBQVNBO2dCQUNkLEtBQUszRixnREFBYUE7b0JBQ2hCLElBQUksZ0JBQWdCd0csU0FBU0EsUUFBUUUsVUFBQSxHQUFhO3lCQUM3Q0YsUUFBUUcsUUFBQSxHQUFXO29CQUN4QkgsUUFBUUksU0FBQSxHQUFZQywrQ0FBWUE7b0JBQ2hDTCxRQUFRTSxTQUFBLEdBQVlELCtDQUFZQTtvQkFDaENMLFFBQVFPLGVBQUEsR0FBa0I7b0JBQzFCUCxRQUFRUSxLQUFBLEdBQVE7b0JBRWhCO1lBQ0g7WUFFRCxJQUFJWixRQUFRQSxPQUFPSSxTQUFTQztRQUM3QjtRQUVELE9BQU8sTUFBTVAsS0FBS0MsS0FBS0ksZ0JBQWdCRixZQUFZQztJQUNwRDtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm9ja2V0c2ltLy4uLy4uL3NyYy9sb2FkZXJzL1JHQkVMb2FkZXIuanM/NjQwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXRhVGV4dHVyZUxvYWRlciwgRGF0YVV0aWxzLCBGbG9hdFR5cGUsIEhhbGZGbG9hdFR5cGUsIExpbmVhckZpbHRlciB9IGZyb20gJ3RocmVlJ1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy81NTUyXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JHQkVfaW1hZ2VfZm9ybWF0XG5cbmNsYXNzIFJHQkVMb2FkZXIgZXh0ZW5kcyBEYXRhVGV4dHVyZUxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKVxuXG4gICAgdGhpcy50eXBlID0gSGFsZkZsb2F0VHlwZVxuICB9XG5cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cuZ3JhcGhpY3MuY29ybmVsbC5lZHUvfmJqdy9yZ2JlLmh0bWxcblxuICBwYXJzZShidWZmZXIpIHtcbiAgICBjb25zdCAvKiBkZWZhdWx0IGVycm9yIHJvdXRpbmUuICBjaGFuZ2UgdGhpcyB0byBjaGFuZ2UgZXJyb3IgaGFuZGxpbmcgKi9cbiAgICAgIHJnYmVfcmVhZF9lcnJvciA9IDEsXG4gICAgICByZ2JlX3dyaXRlX2Vycm9yID0gMixcbiAgICAgIHJnYmVfZm9ybWF0X2Vycm9yID0gMyxcbiAgICAgIHJnYmVfbWVtb3J5X2Vycm9yID0gNCxcbiAgICAgIHJnYmVfZXJyb3IgPSBmdW5jdGlvbiAocmdiZV9lcnJvcl9jb2RlLCBtc2cpIHtcbiAgICAgICAgc3dpdGNoIChyZ2JlX2Vycm9yX2NvZGUpIHtcbiAgICAgICAgICBjYXNlIHJnYmVfcmVhZF9lcnJvcjpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVEhSRUUuUkdCRUxvYWRlcjogUmVhZCBFcnJvcjogJyArIChtc2cgfHwgJycpKVxuICAgICAgICAgIGNhc2UgcmdiZV93cml0ZV9lcnJvcjpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVEhSRUUuUkdCRUxvYWRlcjogV3JpdGUgRXJyb3I6ICcgKyAobXNnIHx8ICcnKSlcbiAgICAgICAgICBjYXNlIHJnYmVfZm9ybWF0X2Vycm9yOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUSFJFRS5SR0JFTG9hZGVyOiBCYWQgRmlsZSBGb3JtYXQ6ICcgKyAobXNnIHx8ICcnKSlcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhc2UgcmdiZV9tZW1vcnlfZXJyb3I6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLlJHQkVMb2FkZXI6IE1lbW9yeSBFcnJvcjogJyArIChtc2cgfHwgJycpKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyogb2Zmc2V0cyB0byByZWQsIGdyZWVuLCBhbmQgYmx1ZSBjb21wb25lbnRzIGluIGEgZGF0YSAoZmxvYXQpIHBpeGVsICovXG4gICAgICAvL1JHQkVfREFUQV9SRUQgPSAwLFxuICAgICAgLy9SR0JFX0RBVEFfR1JFRU4gPSAxLFxuICAgICAgLy9SR0JFX0RBVEFfQkxVRSA9IDIsXG5cbiAgICAgIC8qIG51bWJlciBvZiBmbG9hdHMgcGVyIHBpeGVsLCB1c2UgNCBzaW5jZSBzdG9yZWQgaW4gcmdiYSBpbWFnZSBmb3JtYXQgKi9cbiAgICAgIC8vUkdCRV9EQVRBX1NJWkUgPSA0LFxuXG4gICAgICAvKiBmbGFncyBpbmRpY2F0aW5nIHdoaWNoIGZpZWxkcyBpbiBhbiByZ2JlX2hlYWRlcl9pbmZvIGFyZSB2YWxpZCAqL1xuICAgICAgUkdCRV9WQUxJRF9QUk9HUkFNVFlQRSA9IDEsXG4gICAgICBSR0JFX1ZBTElEX0ZPUk1BVCA9IDIsXG4gICAgICBSR0JFX1ZBTElEX0RJTUVOU0lPTlMgPSA0LFxuICAgICAgTkVXTElORSA9ICdcXG4nLFxuICAgICAgZmdldHMgPSBmdW5jdGlvbiAoYnVmZmVyLCBsaW5lTGltaXQsIGNvbnN1bWUpIHtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gMTI4XG5cbiAgICAgICAgbGluZUxpbWl0ID0gIWxpbmVMaW1pdCA/IDEwMjQgOiBsaW5lTGltaXRcbiAgICAgICAgbGV0IHAgPSBidWZmZXIucG9zLFxuICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICBsZW4gPSAwLFxuICAgICAgICAgIHMgPSAnJyxcbiAgICAgICAgICBjaHVuayA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ1ZmZlci5zdWJhcnJheShwLCBwICsgY2h1bmtTaXplKSkpXG5cbiAgICAgICAgd2hpbGUgKDAgPiAoaSA9IGNodW5rLmluZGV4T2YoTkVXTElORSkpICYmIGxlbiA8IGxpbmVMaW1pdCAmJiBwIDwgYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICBzICs9IGNodW5rXG4gICAgICAgICAgbGVuICs9IGNodW5rLmxlbmd0aFxuICAgICAgICAgIHAgKz0gY2h1bmtTaXplXG4gICAgICAgICAgY2h1bmsgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnN1YmFycmF5KHAsIHAgKyBjaHVua1NpemUpKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgtMSA8IGkpIHtcbiAgICAgICAgICAvKmZvciAoaT1sLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0XHRcdFx0Ynl0ZUNvZGUgPSBtLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRcdFx0XHRpZiAoYnl0ZUNvZGUgPiAweDdmICYmIGJ5dGVDb2RlIDw9IDB4N2ZmKSBieXRlTGVuKys7XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChieXRlQ29kZSA+IDB4N2ZmICYmIGJ5dGVDb2RlIDw9IDB4ZmZmZikgYnl0ZUxlbiArPSAyO1xuXHRcdFx0XHRcdFx0aWYgKGJ5dGVDb2RlID49IDB4REMwMCAmJiBieXRlQ29kZSA8PSAweERGRkYpIGktLTsgLy90cmFpbCBzdXJyb2dhdGVcblx0XHRcdFx0XHR9Ki9cbiAgICAgICAgICBpZiAoZmFsc2UgIT09IGNvbnN1bWUpIGJ1ZmZlci5wb3MgKz0gbGVuICsgaSArIDFcbiAgICAgICAgICByZXR1cm4gcyArIGNodW5rLnNsaWNlKDAsIGkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0sXG4gICAgICAvKiBtaW5pbWFsIGhlYWRlciByZWFkaW5nLiAgbW9kaWZ5IGlmIHlvdSB3YW50IHRvIHBhcnNlIG1vcmUgaW5mb3JtYXRpb24gKi9cbiAgICAgIFJHQkVfUmVhZEhlYWRlciA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgLy8gcmVnZXhlcyB0byBwYXJzZSBoZWFkZXIgaW5mbyBmaWVsZHNcbiAgICAgICAgY29uc3QgbWFnaWNfdG9rZW5fcmUgPSAvXiNcXD8oXFxTKykvLFxuICAgICAgICAgIGdhbW1hX3JlID0gL15cXHMqR0FNTUFcXHMqPVxccyooXFxkKyhcXC5cXGQrKT8pXFxzKiQvLFxuICAgICAgICAgIGV4cG9zdXJlX3JlID0gL15cXHMqRVhQT1NVUkVcXHMqPVxccyooXFxkKyhcXC5cXGQrKT8pXFxzKiQvLFxuICAgICAgICAgIGZvcm1hdF9yZSA9IC9eXFxzKkZPUk1BVD0oXFxTKylcXHMqJC8sXG4gICAgICAgICAgZGltZW5zaW9uc19yZSA9IC9eXFxzKlxcLVlcXHMrKFxcZCspXFxzK1xcK1hcXHMrKFxcZCspXFxzKiQvLFxuICAgICAgICAgIC8vIFJHQkUgZm9ybWF0IGhlYWRlciBzdHJ1Y3RcbiAgICAgICAgICBoZWFkZXIgPSB7XG4gICAgICAgICAgICB2YWxpZDogMCAvKiBpbmRpY2F0ZSB3aGljaCBmaWVsZHMgYXJlIHZhbGlkICovLFxuXG4gICAgICAgICAgICBzdHJpbmc6ICcnIC8qIHRoZSBhY3R1YWwgaGVhZGVyIHN0cmluZyAqLyxcblxuICAgICAgICAgICAgY29tbWVudHM6ICcnIC8qIGNvbW1lbnRzIGZvdW5kIGluIGhlYWRlciAqLyxcblxuICAgICAgICAgICAgcHJvZ3JhbXR5cGU6ICdSR0JFJyAvKiBsaXN0ZWQgYXQgYmVnaW5uaW5nIG9mIGZpbGUgdG8gaWRlbnRpZnkgaXQgYWZ0ZXIgXCIjP1wiLiBkZWZhdWx0cyB0byBcIlJHQkVcIiAqLyxcblxuICAgICAgICAgICAgZm9ybWF0OiAnJyAvKiBSR0JFIGZvcm1hdCwgZGVmYXVsdCAzMi1iaXRfcmxlX3JnYmUgKi8sXG5cbiAgICAgICAgICAgIGdhbW1hOiAxLjAgLyogaW1hZ2UgaGFzIGFscmVhZHkgYmVlbiBnYW1tYSBjb3JyZWN0ZWQgd2l0aCBnaXZlbiBnYW1tYS4gZGVmYXVsdHMgdG8gMS4wIChubyBjb3JyZWN0aW9uKSAqLyxcblxuICAgICAgICAgICAgZXhwb3N1cmU6IDEuMCAvKiBhIHZhbHVlIG9mIDEuMCBpbiBhbiBpbWFnZSBjb3JyZXNwb25kcyB0byA8ZXhwb3N1cmU+IHdhdHRzL3N0ZXJhZGlhbi9tXjIuIGRlZmF1bHRzIHRvIDEuMCAqLyxcblxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAgLyogaW1hZ2UgZGltZW5zaW9ucywgd2lkdGgvaGVpZ2h0ICovLFxuICAgICAgICAgIH1cblxuICAgICAgICBsZXQgbGluZSwgbWF0Y2hcblxuICAgICAgICBpZiAoYnVmZmVyLnBvcyA+PSBidWZmZXIuYnl0ZUxlbmd0aCB8fCAhKGxpbmUgPSBmZ2V0cyhidWZmZXIpKSkge1xuICAgICAgICAgIHJnYmVfZXJyb3IocmdiZV9yZWFkX2Vycm9yLCAnbm8gaGVhZGVyIGZvdW5kJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGlmIHlvdSB3YW50IHRvIHJlcXVpcmUgdGhlIG1hZ2ljIHRva2VuIHRoZW4gdW5jb21tZW50IHRoZSBuZXh0IGxpbmUgKi9cbiAgICAgICAgaWYgKCEobWF0Y2ggPSBsaW5lLm1hdGNoKG1hZ2ljX3Rva2VuX3JlKSkpIHtcbiAgICAgICAgICByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCAnYmFkIGluaXRpYWwgdG9rZW4nKVxuICAgICAgICB9XG5cbiAgICAgICAgaGVhZGVyLnZhbGlkIHw9IFJHQkVfVkFMSURfUFJPR1JBTVRZUEVcbiAgICAgICAgaGVhZGVyLnByb2dyYW10eXBlID0gbWF0Y2hbMV1cbiAgICAgICAgaGVhZGVyLnN0cmluZyArPSBsaW5lICsgJ1xcbidcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGxpbmUgPSBmZ2V0cyhidWZmZXIpXG4gICAgICAgICAgaWYgKGZhbHNlID09PSBsaW5lKSBicmVha1xuICAgICAgICAgIGhlYWRlci5zdHJpbmcgKz0gbGluZSArICdcXG4nXG5cbiAgICAgICAgICBpZiAoJyMnID09PSBsaW5lLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgaGVhZGVyLmNvbW1lbnRzICs9IGxpbmUgKyAnXFxuJ1xuICAgICAgICAgICAgY29udGludWUgLy8gY29tbWVudCBsaW5lXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKChtYXRjaCA9IGxpbmUubWF0Y2goZ2FtbWFfcmUpKSkge1xuICAgICAgICAgICAgaGVhZGVyLmdhbW1hID0gcGFyc2VGbG9hdChtYXRjaFsxXSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoKG1hdGNoID0gbGluZS5tYXRjaChleHBvc3VyZV9yZSkpKSB7XG4gICAgICAgICAgICBoZWFkZXIuZXhwb3N1cmUgPSBwYXJzZUZsb2F0KG1hdGNoWzFdKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgobWF0Y2ggPSBsaW5lLm1hdGNoKGZvcm1hdF9yZSkpKSB7XG4gICAgICAgICAgICBoZWFkZXIudmFsaWQgfD0gUkdCRV9WQUxJRF9GT1JNQVRcbiAgICAgICAgICAgIGhlYWRlci5mb3JtYXQgPSBtYXRjaFsxXSAvLyczMi1iaXRfcmxlX3JnYmUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgobWF0Y2ggPSBsaW5lLm1hdGNoKGRpbWVuc2lvbnNfcmUpKSkge1xuICAgICAgICAgICAgaGVhZGVyLnZhbGlkIHw9IFJHQkVfVkFMSURfRElNRU5TSU9OU1xuICAgICAgICAgICAgaGVhZGVyLmhlaWdodCA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMClcbiAgICAgICAgICAgIGhlYWRlci53aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9GT1JNQVQgJiYgaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9ESU1FTlNJT05TKSBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9GT1JNQVQpKSB7XG4gICAgICAgICAgcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgJ21pc3NpbmcgZm9ybWF0IHNwZWNpZmllcicpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShoZWFkZXIudmFsaWQgJiBSR0JFX1ZBTElEX0RJTUVOU0lPTlMpKSB7XG4gICAgICAgICAgcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgJ21pc3NpbmcgaW1hZ2Ugc2l6ZSBzcGVjaWZpZXInKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlYWRlclxuICAgICAgfSxcbiAgICAgIFJHQkVfUmVhZFBpeGVsc19STEUgPSBmdW5jdGlvbiAoYnVmZmVyLCB3LCBoKSB7XG4gICAgICAgIGNvbnN0IHNjYW5saW5lX3dpZHRoID0gd1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBydW4gbGVuZ3RoIGVuY29kaW5nIGlzIG5vdCBhbGxvd2VkIHNvIHJlYWQgZmxhdFxuICAgICAgICAgIHNjYW5saW5lX3dpZHRoIDwgOCB8fFxuICAgICAgICAgIHNjYW5saW5lX3dpZHRoID4gMHg3ZmZmIHx8XG4gICAgICAgICAgLy8gdGhpcyBmaWxlIGlzIG5vdCBydW4gbGVuZ3RoIGVuY29kZWRcbiAgICAgICAgICAyICE9PSBidWZmZXJbMF0gfHxcbiAgICAgICAgICAyICE9PSBidWZmZXJbMV0gfHxcbiAgICAgICAgICBidWZmZXJbMl0gJiAweDgwXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIHJldHVybiB0aGUgZmxhdCBidWZmZXJcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjYW5saW5lX3dpZHRoICE9PSAoKGJ1ZmZlclsyXSA8PCA4KSB8IGJ1ZmZlclszXSkpIHtcbiAgICAgICAgICByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCAnd3Jvbmcgc2NhbmxpbmUgd2lkdGgnKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YV9yZ2JhID0gbmV3IFVpbnQ4QXJyYXkoNCAqIHcgKiBoKVxuXG4gICAgICAgIGlmICghZGF0YV9yZ2JhLmxlbmd0aCkge1xuICAgICAgICAgIHJnYmVfZXJyb3IocmdiZV9tZW1vcnlfZXJyb3IsICd1bmFibGUgdG8gYWxsb2NhdGUgYnVmZmVyIHNwYWNlJylcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvZmZzZXQgPSAwLFxuICAgICAgICAgIHBvcyA9IDBcblxuICAgICAgICBjb25zdCBwdHJfZW5kID0gNCAqIHNjYW5saW5lX3dpZHRoXG4gICAgICAgIGNvbnN0IHJnYmVTdGFydCA9IG5ldyBVaW50OEFycmF5KDQpXG4gICAgICAgIGNvbnN0IHNjYW5saW5lX2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KHB0cl9lbmQpXG4gICAgICAgIGxldCBudW1fc2NhbmxpbmVzID0gaFxuXG4gICAgICAgIC8vIHJlYWQgaW4gZWFjaCBzdWNjZXNzaXZlIHNjYW5saW5lXG4gICAgICAgIHdoaWxlIChudW1fc2NhbmxpbmVzID4gMCAmJiBwb3MgPCBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIGlmIChwb3MgKyA0ID4gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHJnYmVfZXJyb3IocmdiZV9yZWFkX2Vycm9yKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJnYmVTdGFydFswXSA9IGJ1ZmZlcltwb3MrK11cbiAgICAgICAgICByZ2JlU3RhcnRbMV0gPSBidWZmZXJbcG9zKytdXG4gICAgICAgICAgcmdiZVN0YXJ0WzJdID0gYnVmZmVyW3BvcysrXVxuICAgICAgICAgIHJnYmVTdGFydFszXSA9IGJ1ZmZlcltwb3MrK11cblxuICAgICAgICAgIGlmICgyICE9IHJnYmVTdGFydFswXSB8fCAyICE9IHJnYmVTdGFydFsxXSB8fCAoKHJnYmVTdGFydFsyXSA8PCA4KSB8IHJnYmVTdGFydFszXSkgIT0gc2NhbmxpbmVfd2lkdGgpIHtcbiAgICAgICAgICAgIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsICdiYWQgcmdiZSBzY2FubGluZSBmb3JtYXQnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlYWQgZWFjaCBvZiB0aGUgZm91ciBjaGFubmVscyBmb3IgdGhlIHNjYW5saW5lIGludG8gdGhlIGJ1ZmZlclxuICAgICAgICAgIC8vIGZpcnN0IHJlZCwgdGhlbiBncmVlbiwgdGhlbiBibHVlLCB0aGVuIGV4cG9uZW50XG4gICAgICAgICAgbGV0IHB0ciA9IDAsXG4gICAgICAgICAgICBjb3VudFxuXG4gICAgICAgICAgd2hpbGUgKHB0ciA8IHB0cl9lbmQgJiYgcG9zIDwgYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvdW50ID0gYnVmZmVyW3BvcysrXVxuICAgICAgICAgICAgY29uc3QgaXNFbmNvZGVkUnVuID0gY291bnQgPiAxMjhcbiAgICAgICAgICAgIGlmIChpc0VuY29kZWRSdW4pIGNvdW50IC09IDEyOFxuXG4gICAgICAgICAgICBpZiAoMCA9PT0gY291bnQgfHwgcHRyICsgY291bnQgPiBwdHJfZW5kKSB7XG4gICAgICAgICAgICAgIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsICdiYWQgc2NhbmxpbmUgZGF0YScpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0VuY29kZWRSdW4pIHtcbiAgICAgICAgICAgICAgLy8gYSAoZW5jb2RlZCkgcnVuIG9mIHRoZSBzYW1lIHZhbHVlXG4gICAgICAgICAgICAgIGNvbnN0IGJ5dGVWYWx1ZSA9IGJ1ZmZlcltwb3MrK11cbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2NhbmxpbmVfYnVmZmVyW3B0cisrXSA9IGJ5dGVWYWx1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vcHRyICs9IGNvdW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYSBsaXRlcmFsLXJ1blxuICAgICAgICAgICAgICBzY2FubGluZV9idWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheShwb3MsIHBvcyArIGNvdW50KSwgcHRyKVxuICAgICAgICAgICAgICBwdHIgKz0gY291bnRcbiAgICAgICAgICAgICAgcG9zICs9IGNvdW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbm93IGNvbnZlcnQgZGF0YSBmcm9tIGJ1ZmZlciBpbnRvIHJnYmFcbiAgICAgICAgICAvLyBmaXJzdCByZWQsIHRoZW4gZ3JlZW4sIHRoZW4gYmx1ZSwgdGhlbiBleHBvbmVudCAoYWxwaGEpXG4gICAgICAgICAgY29uc3QgbCA9IHNjYW5saW5lX3dpZHRoIC8vc2NhbmxpbmVfYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBvZmYgPSAwXG4gICAgICAgICAgICBkYXRhX3JnYmFbb2Zmc2V0XSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXVxuICAgICAgICAgICAgb2ZmICs9IHNjYW5saW5lX3dpZHRoIC8vMTtcbiAgICAgICAgICAgIGRhdGFfcmdiYVtvZmZzZXQgKyAxXSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXVxuICAgICAgICAgICAgb2ZmICs9IHNjYW5saW5lX3dpZHRoIC8vMTtcbiAgICAgICAgICAgIGRhdGFfcmdiYVtvZmZzZXQgKyAyXSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXVxuICAgICAgICAgICAgb2ZmICs9IHNjYW5saW5lX3dpZHRoIC8vMTtcbiAgICAgICAgICAgIGRhdGFfcmdiYVtvZmZzZXQgKyAzXSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXVxuICAgICAgICAgICAgb2Zmc2V0ICs9IDRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBudW1fc2NhbmxpbmVzLS1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhX3JnYmFcbiAgICAgIH1cblxuICAgIGNvbnN0IFJHQkVCeXRlVG9SR0JGbG9hdCA9IGZ1bmN0aW9uIChzb3VyY2VBcnJheSwgc291cmNlT2Zmc2V0LCBkZXN0QXJyYXksIGRlc3RPZmZzZXQpIHtcbiAgICAgIGNvbnN0IGUgPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAzXVxuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLjAsIGUgLSAxMjguMCkgLyAyNTUuMFxuXG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDBdID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMF0gKiBzY2FsZVxuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAxXSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDFdICogc2NhbGVcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMl0gPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAyXSAqIHNjYWxlXG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDNdID0gMVxuICAgIH1cblxuICAgIGNvbnN0IFJHQkVCeXRlVG9SR0JIYWxmID0gZnVuY3Rpb24gKHNvdXJjZUFycmF5LCBzb3VyY2VPZmZzZXQsIGRlc3RBcnJheSwgZGVzdE9mZnNldCkge1xuICAgICAgY29uc3QgZSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDNdXG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIuMCwgZSAtIDEyOC4wKSAvIDI1NS4wXG5cbiAgICAgIC8vIGNsYW1waW5nIHRvIDY1NTA0LCB0aGUgbWF4aW11bSByZXByZXNlbnRhYmxlIHZhbHVlIGluIGZsb2F0MTZcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMF0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoTWF0aC5taW4oc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMF0gKiBzY2FsZSwgNjU1MDQpKVxuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAxXSA9IERhdGFVdGlscy50b0hhbGZGbG9hdChNYXRoLm1pbihzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAxXSAqIHNjYWxlLCA2NTUwNCkpXG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDJdID0gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KE1hdGgubWluKHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDJdICogc2NhbGUsIDY1NTA0KSlcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgM10gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoMSlcbiAgICB9XG5cbiAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpXG4gICAgYnl0ZUFycmF5LnBvcyA9IDBcbiAgICBjb25zdCByZ2JlX2hlYWRlcl9pbmZvID0gUkdCRV9SZWFkSGVhZGVyKGJ5dGVBcnJheSlcblxuICAgIGNvbnN0IHcgPSByZ2JlX2hlYWRlcl9pbmZvLndpZHRoLFxuICAgICAgaCA9IHJnYmVfaGVhZGVyX2luZm8uaGVpZ2h0LFxuICAgICAgaW1hZ2VfcmdiYV9kYXRhID0gUkdCRV9SZWFkUGl4ZWxzX1JMRShieXRlQXJyYXkuc3ViYXJyYXkoYnl0ZUFycmF5LnBvcyksIHcsIGgpXG5cbiAgICBsZXQgZGF0YSwgdHlwZVxuICAgIGxldCBudW1FbGVtZW50c1xuXG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICBudW1FbGVtZW50cyA9IGltYWdlX3JnYmFfZGF0YS5sZW5ndGggLyA0XG4gICAgICAgIGNvbnN0IGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KG51bUVsZW1lbnRzICogNClcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUVsZW1lbnRzOyBqKyspIHtcbiAgICAgICAgICBSR0JFQnl0ZVRvUkdCRmxvYXQoaW1hZ2VfcmdiYV9kYXRhLCBqICogNCwgZmxvYXRBcnJheSwgaiAqIDQpXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0gZmxvYXRBcnJheVxuICAgICAgICB0eXBlID0gRmxvYXRUeXBlXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgbnVtRWxlbWVudHMgPSBpbWFnZV9yZ2JhX2RhdGEubGVuZ3RoIC8gNFxuICAgICAgICBjb25zdCBoYWxmQXJyYXkgPSBuZXcgVWludDE2QXJyYXkobnVtRWxlbWVudHMgKiA0KVxuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtRWxlbWVudHM7IGorKykge1xuICAgICAgICAgIFJHQkVCeXRlVG9SR0JIYWxmKGltYWdlX3JnYmFfZGF0YSwgaiAqIDQsIGhhbGZBcnJheSwgaiAqIDQpXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0gaGFsZkFycmF5XG4gICAgICAgIHR5cGUgPSBIYWxmRmxvYXRUeXBlXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVEhSRUUuUkdCRUxvYWRlcjogVW5zdXBwb3J0ZWQgdHlwZTogJyArIHRoaXMudHlwZSlcbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHcsXG4gICAgICBoZWlnaHQ6IGgsXG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgaGVhZGVyOiByZ2JlX2hlYWRlcl9pbmZvLnN0cmluZyxcbiAgICAgIGdhbW1hOiByZ2JlX2hlYWRlcl9pbmZvLmdhbW1hLFxuICAgICAgZXhwb3N1cmU6IHJnYmVfaGVhZGVyX2luZm8uZXhwb3N1cmUsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgIH1cbiAgfVxuXG4gIHNldERhdGFUeXBlKHZhbHVlKSB7XG4gICAgdGhpcy50eXBlID0gdmFsdWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGZ1bmN0aW9uIG9uTG9hZENhbGxiYWNrKHRleHR1cmUsIHRleERhdGEpIHtcbiAgICAgIHN3aXRjaCAodGV4dHVyZS50eXBlKSB7XG4gICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgaWYgKCdjb2xvclNwYWNlJyBpbiB0ZXh0dXJlKSB0ZXh0dXJlLmNvbG9yU3BhY2UgPSAnc3JnYi1saW5lYXInXG4gICAgICAgICAgZWxzZSB0ZXh0dXJlLmVuY29kaW5nID0gMzAwMCAvLyBMaW5lYXJFbmNvZGluZ1xuICAgICAgICAgIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyXG4gICAgICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXJcbiAgICAgICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlXG4gICAgICAgICAgdGV4dHVyZS5mbGlwWSA9IHRydWVcblxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkxvYWQpIG9uTG9hZCh0ZXh0dXJlLCB0ZXhEYXRhKVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5sb2FkKHVybCwgb25Mb2FkQ2FsbGJhY2ssIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpXG4gIH1cbn1cblxuZXhwb3J0IHsgUkdCRUxvYWRlciB9XG4iXSwibmFtZXMiOlsiUkdCRUxvYWRlciIsIkRhdGFUZXh0dXJlTG9hZGVyIiwiY29uc3RydWN0b3IiLCJtYW5hZ2VyIiwidHlwZSIsIkhhbGZGbG9hdFR5cGUiLCJwYXJzZSIsImJ1ZmZlciIsInJnYmVfcmVhZF9lcnJvciIsInJnYmVfd3JpdGVfZXJyb3IiLCJyZ2JlX2Zvcm1hdF9lcnJvciIsInJnYmVfbWVtb3J5X2Vycm9yIiwicmdiZV9lcnJvciIsInJnYmVfZXJyb3JfY29kZSIsIm1zZyIsIkVycm9yIiwiUkdCRV9WQUxJRF9QUk9HUkFNVFlQRSIsIlJHQkVfVkFMSURfRk9STUFUIiwiUkdCRV9WQUxJRF9ESU1FTlNJT05TIiwiTkVXTElORSIsImZnZXRzIiwibGluZUxpbWl0IiwiY29uc3VtZSIsImNodW5rU2l6ZSIsInAiLCJwb3MiLCJpIiwibGVuIiwicyIsImNodW5rIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJVaW50MTZBcnJheSIsInN1YmFycmF5IiwiaW5kZXhPZiIsImJ5dGVMZW5ndGgiLCJsZW5ndGgiLCJzbGljZSIsIlJHQkVfUmVhZEhlYWRlciIsIm1hZ2ljX3Rva2VuX3JlIiwiZ2FtbWFfcmUiLCJleHBvc3VyZV9yZSIsImZvcm1hdF9yZSIsImRpbWVuc2lvbnNfcmUiLCJoZWFkZXIiLCJ2YWxpZCIsInN0cmluZyIsImNvbW1lbnRzIiwicHJvZ3JhbXR5cGUiLCJmb3JtYXQiLCJnYW1tYSIsImV4cG9zdXJlIiwid2lkdGgiLCJoZWlnaHQiLCJsaW5lIiwibWF0Y2giLCJjaGFyQXQiLCJwYXJzZUZsb2F0IiwicGFyc2VJbnQiLCJSR0JFX1JlYWRQaXhlbHNfUkxFIiwidyIsImgiLCJzY2FubGluZV93aWR0aCIsIlVpbnQ4QXJyYXkiLCJkYXRhX3JnYmEiLCJvZmZzZXQiLCJwdHJfZW5kIiwicmdiZVN0YXJ0Iiwic2NhbmxpbmVfYnVmZmVyIiwibnVtX3NjYW5saW5lcyIsInB0ciIsImNvdW50IiwiaXNFbmNvZGVkUnVuIiwiYnl0ZVZhbHVlIiwic2V0IiwibCIsIm9mZiIsIlJHQkVCeXRlVG9SR0JGbG9hdCIsInNvdXJjZUFycmF5Iiwic291cmNlT2Zmc2V0IiwiZGVzdEFycmF5IiwiZGVzdE9mZnNldCIsImUiLCJzY2FsZSIsIk1hdGgiLCJwb3ciLCJSR0JFQnl0ZVRvUkdCSGFsZiIsIkRhdGFVdGlscyIsInRvSGFsZkZsb2F0IiwibWluIiwiYnl0ZUFycmF5IiwicmdiZV9oZWFkZXJfaW5mbyIsImltYWdlX3JnYmFfZGF0YSIsImRhdGEiLCJudW1FbGVtZW50cyIsIkZsb2F0VHlwZSIsImZsb2F0QXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJqIiwiaGFsZkFycmF5Iiwic2V0RGF0YVR5cGUiLCJ2YWx1ZSIsImxvYWQiLCJ1cmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsIm9uTG9hZENhbGxiYWNrIiwidGV4dHVyZSIsInRleERhdGEiLCJjb2xvclNwYWNlIiwiZW5jb2RpbmciLCJtaW5GaWx0ZXIiLCJMaW5lYXJGaWx0ZXIiLCJtYWdGaWx0ZXIiLCJnZW5lcmF0ZU1pcG1hcHMiLCJmbGlwWSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/RGBELoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/objects/GroundProjectedEnv.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/objects/GroundProjectedEnv.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroundProjectedEnv: () => (/* binding */ GroundProjectedEnv)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/_polyfill/constants.js\");\n\n\nconst isCubeTexture = (def)=>def && def.isCubeTexture;\nclass GroundProjectedEnv extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n    constructor(texture, options){\n        var _a, _b;\n        const isCubeMap = isCubeTexture(texture);\n        const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n        const cubeSize = w / 4;\n        const _lodMax = Math.floor(Math.log2(cubeSize));\n        const _cubeSize = Math.pow(2, _lodMax);\n        const width = 3 * Math.max(_cubeSize, 16 * 7);\n        const height = 4 * _cubeSize;\n        const defines = [\n            isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n            `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,\n            `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,\n            `#define CUBEUV_MAX_MIP ${_lodMax}.0`\n        ];\n        const vertexShader = /* glsl */ `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `;\n        const fragmentShader = defines.join(\"\\n\") + /* glsl */ `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${_polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__.version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n        }\n        `;\n        const uniforms = {\n            map: {\n                value: texture\n            },\n            height: {\n                value: (options == null ? void 0 : options.height) || 15\n            },\n            radius: {\n                value: (options == null ? void 0 : options.radius) || 100\n            }\n        };\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.IcosahedronGeometry(1, 16);\n        const material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n            uniforms,\n            fragmentShader,\n            vertexShader,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n        });\n        super(geometry, material);\n    }\n    set radius(radius) {\n        this.material.uniforms.radius.value = radius;\n    }\n    get radius() {\n        return this.material.uniforms.radius.value;\n    }\n    set height(height) {\n        this.material.uniforms.height.value = height;\n    }\n    get height() {\n        return this.material.uniforms.height.value;\n    }\n}\n //# sourceMappingURL=GroundProjectedEnv.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9vYmplY3RzL0dyb3VuZFByb2plY3RlZEVudi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQVFBLE1BQU1BLGdCQUFnQixDQUFDQyxNQUFtREEsT0FBUUEsSUFBb0JELGFBQUE7QUFFL0YsTUFBTUUsMkJBQTJCQyx1Q0FBSUE7SUFDMUNDLFlBQVlDLE9BQUEsRUFBZ0NDLE9BQUEsQ0FBd0M7O1FBQzVFLE1BQUFDLFlBQVlQLGNBQWNLO1FBQzFCLE1BQUFHLElBQUEsQ0FBS0MsS0FBQUYsWUFBQSxDQUFZRyxLQUFBTCxRQUFRTSxLQUFBLENBQU0sRUFBQyxLQUFmLGdCQUFBRCxHQUFrQkUsS0FBQSxHQUFRUCxRQUFRTSxLQUFBLENBQU1DLEtBQUEsS0FBcEQsT0FBQUgsS0FBOEQ7UUFDekUsTUFBTUksV0FBV0wsSUFBSTtRQUNyQixNQUFNTSxVQUFVQyxLQUFLQyxLQUFBLENBQU1ELEtBQUtFLElBQUEsQ0FBS0o7UUFDckMsTUFBTUssWUFBWUgsS0FBS0ksR0FBQSxDQUFJLEdBQUdMO1FBQzlCLE1BQU1GLFFBQVEsSUFBSUcsS0FBS0ssR0FBQSxDQUFJRixXQUFXLEtBQUs7UUFDM0MsTUFBTUcsU0FBUyxJQUFJSDtRQUVuQixNQUFNSSxVQUFVO1lBQ2RmLFlBQVksNkJBQTZCO1lBQ3pDLDhCQUE4QixJQUFNSyxNQUFBO1lBQ3BDLCtCQUErQixJQUFNUyxPQUFBO1lBQ3JDLDBCQUEwQlAsUUFBQTtTQUFBO1FBR3RCLE1BQUFTLGVBQUEsV0FBMEI7Ozs7Ozs7OztRQUFBO1FBVTFCLE1BQUFDLGlCQUNKRixRQUFRRyxJQUFBLENBQUssUUFBSSxXQUNOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBQUEsRUFxRU9DLDJEQUFPQSxJQUFJLE1BQU0sd0JBQXdCOztRQUFBO1FBSTdELE1BQU1DLFdBQVc7WUFDZkMsS0FBSztnQkFBRUMsT0FBT3hCO1lBQVE7WUFDdEJnQixRQUFRO2dCQUFFUSxPQUFBLENBQU92QixXQUFBLGdCQUFBQSxRQUFTZSxNQUFBLEtBQVU7WUFBRztZQUN2Q1MsUUFBUTtnQkFBRUQsT0FBQSxDQUFPdkIsV0FBQSxnQkFBQUEsUUFBU3dCLE1BQUEsS0FBVTtZQUFJO1FBQUE7UUFHMUMsTUFBTUMsV0FBVyxJQUFJQyxzREFBbUJBLENBQUMsR0FBRztRQUN0QyxNQUFBQyxXQUFXLElBQUlDLGlEQUFjQSxDQUFDO1lBQ2xDUDtZQUNBSDtZQUNBRDtZQUNBWSxNQUFNQyw2Q0FBVUE7UUFBVjtRQUdSLE1BQU1MLFVBQVVFO0lBQ2xCO0lBRUEsSUFBSUgsT0FBT0EsTUFBQSxFQUFnQjtRQUNwQixLQUFBRyxRQUFBLENBQVNOLFFBQUEsQ0FBU0csTUFBQSxDQUFPRCxLQUFBLEdBQVFDO0lBQ3hDO0lBRUEsSUFBSUEsU0FBaUI7UUFDWixZQUFLRyxRQUFBLENBQVNOLFFBQUEsQ0FBU0csTUFBQSxDQUFPRCxLQUFBO0lBQ3ZDO0lBRUEsSUFBSVIsT0FBT0EsTUFBQSxFQUFnQjtRQUNwQixLQUFBWSxRQUFBLENBQVNOLFFBQUEsQ0FBU04sTUFBQSxDQUFPUSxLQUFBLEdBQVFSO0lBQ3hDO0lBRUEsSUFBSUEsU0FBaUI7UUFDWixZQUFLWSxRQUFBLENBQVNOLFFBQUEsQ0FBU04sTUFBQSxDQUFPUSxLQUFBO0lBQ3ZDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yb2NrZXRzaW0vLi4vLi4vc3JjL29iamVjdHMvR3JvdW5kUHJvamVjdGVkRW52LnRzPzU1YjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVzaCwgSWNvc2FoZWRyb25HZW9tZXRyeSwgU2hhZGVyTWF0ZXJpYWwsIERvdWJsZVNpZGUsIFRleHR1cmUsIEN1YmVUZXh0dXJlLCBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJ3RocmVlJ1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4uL19wb2x5ZmlsbC9jb25zdGFudHMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdW5kUHJvamVjdGVkRW52UGFyYW1ldGVycyB7XG4gIGhlaWdodD86IG51bWJlclxuICByYWRpdXM/OiBudW1iZXJcbn1cblxuY29uc3QgaXNDdWJlVGV4dHVyZSA9IChkZWY6IEN1YmVUZXh0dXJlIHwgVGV4dHVyZSk6IGRlZiBpcyBDdWJlVGV4dHVyZSA9PiBkZWYgJiYgKGRlZiBhcyBDdWJlVGV4dHVyZSkuaXNDdWJlVGV4dHVyZVxuXG5leHBvcnQgY2xhc3MgR3JvdW5kUHJvamVjdGVkRW52IGV4dGVuZHMgTWVzaDxCdWZmZXJHZW9tZXRyeSwgU2hhZGVyTWF0ZXJpYWw+IHtcbiAgY29uc3RydWN0b3IodGV4dHVyZTogQ3ViZVRleHR1cmUgfCBUZXh0dXJlLCBvcHRpb25zPzogR3JvdW5kUHJvamVjdGVkRW52UGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzQ3ViZU1hcCA9IGlzQ3ViZVRleHR1cmUodGV4dHVyZSlcbiAgICBjb25zdCB3ID0gKGlzQ3ViZU1hcCA/IHRleHR1cmUuaW1hZ2VbMF0/LndpZHRoIDogdGV4dHVyZS5pbWFnZS53aWR0aCkgPz8gMTAyNFxuICAgIGNvbnN0IGN1YmVTaXplID0gdyAvIDRcbiAgICBjb25zdCBfbG9kTWF4ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIoY3ViZVNpemUpKVxuICAgIGNvbnN0IF9jdWJlU2l6ZSA9IE1hdGgucG93KDIsIF9sb2RNYXgpXG4gICAgY29uc3Qgd2lkdGggPSAzICogTWF0aC5tYXgoX2N1YmVTaXplLCAxNiAqIDcpXG4gICAgY29uc3QgaGVpZ2h0ID0gNCAqIF9jdWJlU2l6ZVxuXG4gICAgY29uc3QgZGVmaW5lcyA9IFtcbiAgICAgIGlzQ3ViZU1hcCA/ICcjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkUnIDogJycsXG4gICAgICBgI2RlZmluZSBDVUJFVVZfVEVYRUxfV0lEVEggJHsxLjAgLyB3aWR0aH1gLFxuICAgICAgYCNkZWZpbmUgQ1VCRVVWX1RFWEVMX0hFSUdIVCAkezEuMCAvIGhlaWdodH1gLFxuICAgICAgYCNkZWZpbmUgQ1VCRVVWX01BWF9NSVAgJHtfbG9kTWF4fS4wYCxcbiAgICBdXG5cbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSAvKiBnbHNsICovIGBcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xuICAgICAgICB2b2lkIG1haW4oKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjNCB3b3JsZFBvc2l0aW9uID0gKCBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKSApO1xuICAgICAgICAgICAgdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xuICAgICAgICB9XG4gICAgICAgIGBcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9XG4gICAgICBkZWZpbmVzLmpvaW4oJ1xcbicpICtcbiAgICAgIC8qIGdsc2wgKi8gYFxuICAgICAgICAjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVfVVZcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBoZWlnaHQ7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgYW5nbGU7XG4gICAgICAgICNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXJDdWJlIG1hcDtcbiAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcbiAgICAgICAgI2VuZGlmXG4gICAgICAgIC8vIEZyb206IGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80dHNCRDdcbiAgICAgICAgZmxvYXQgZGlza0ludGVyc2VjdFdpdGhCYWNrRmFjZUN1bGxpbmcoIHZlYzMgcm8sIHZlYzMgcmQsIHZlYzMgYywgdmVjMyBuLCBmbG9hdCByICkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZsb2F0IGQgPSBkb3QgKCByZCwgbiApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggZCA+IDAuMCApIHsgcmV0dXJuIDFlNjsgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2ZWMzICBvID0gcm8gLSBjO1xuICAgICAgICAgICAgZmxvYXQgdCA9IC0gZG90KCBuLCBvICkgLyBkO1xuICAgICAgICAgICAgdmVjMyAgcSA9IG8gKyByZCAqIHQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiAoIGRvdCggcSwgcSApIDwgciAqIHIgKSA/IHQgOiAxZTY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRnJvbTogaHR0cHM6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL2ludGVyc2VjdG9ycy9pbnRlcnNlY3RvcnMuaHRtXG4gICAgICAgIGZsb2F0IHNwaGVyZUludGVyc2VjdCggdmVjMyBybywgdmVjMyByZCwgdmVjMyBjZSwgZmxvYXQgcmEgKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjMyBvYyA9IHJvIC0gY2U7XG4gICAgICAgICAgICBmbG9hdCBiID0gZG90KCBvYywgcmQgKTtcbiAgICAgICAgICAgIGZsb2F0IGMgPSBkb3QoIG9jLCBvYyApIC0gcmEgKiByYTtcbiAgICAgICAgICAgIGZsb2F0IGggPSBiICogYiAtIGM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBoIDwgMC4wICkgeyByZXR1cm4gLTEuMDsgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBoID0gc3FydCggaCApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gLSBiICsgaDtcbiAgICAgICAgfVxuICAgICAgICB2ZWMzIHByb2plY3QoKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjMyBwID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1xuICAgICAgICAgICAgdmVjMyBjYW1Qb3MgPSBjYW1lcmFQb3NpdGlvbjtcbiAgICAgICAgICAgIGNhbVBvcy55IC09IGhlaWdodDtcbiAgICAgICAgICAgIGZsb2F0IGludGVyc2VjdGlvbiA9IHNwaGVyZUludGVyc2VjdCggY2FtUG9zLCBwLCB2ZWMzKCAwLjAgKSwgcmFkaXVzICk7XG4gICAgICAgICAgICBpZiggaW50ZXJzZWN0aW9uID4gMC4wICkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZlYzMgaCA9IHZlYzMoIDAuMCwgLSBoZWlnaHQsIDAuMCApO1xuICAgICAgICAgICAgICAgIGZsb2F0IGludGVyc2VjdGlvbjIgPSBkaXNrSW50ZXJzZWN0V2l0aEJhY2tGYWNlQ3VsbGluZyggY2FtUG9zLCBwLCBoLCB2ZWMzKCAwLjAsIDEuMCwgMC4wICksIHJhZGl1cyApO1xuICAgICAgICAgICAgICAgIHAgPSAoIGNhbVBvcyArIG1pbiggaW50ZXJzZWN0aW9uLCBpbnRlcnNlY3Rpb24yICkgKiBwICkgLyByYWRpdXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSB2ZWMzKCAwLjAsIDEuMCwgMC4wICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgICAgICAjaW5jbHVkZSA8Y29tbW9uPlxuICAgICAgICAjaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxuICAgICAgICB2b2lkIG1haW4oKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjMyBwcm9qZWN0ZWRXb3JsZFBvc2l0aW9uID0gcHJvamVjdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxuICAgICAgICAgICAgICAgIHZlYzMgb3V0Y29sb3IgPSB0ZXh0dXJlQ3ViZSggbWFwLCBwcm9qZWN0ZWRXb3JsZFBvc2l0aW9uICkucmdiO1xuICAgICAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgICAgICB2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggcHJvamVjdGVkV29ybGRQb3NpdGlvbiApO1xuICAgICAgICAgICAgICAgIHZlYzIgdXYgPSBlcXVpcmVjdFV2KCBkaXJlY3Rpb24gKTtcbiAgICAgICAgICAgICAgICB2ZWMzIG91dGNvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHV2ICkucmdiO1xuICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRjb2xvciwgMS4wICk7XG4gICAgICAgICAgICAjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XG4gICAgICAgICAgICAjaW5jbHVkZSA8JHt2ZXJzaW9uID49IDE1NCA/ICdjb2xvcnNwYWNlX2ZyYWdtZW50JyA6ICdlbmNvZGluZ3NfZnJhZ21lbnQnfT5cbiAgICAgICAgfVxuICAgICAgICBgXG5cbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIG1hcDogeyB2YWx1ZTogdGV4dHVyZSB9LFxuICAgICAgaGVpZ2h0OiB7IHZhbHVlOiBvcHRpb25zPy5oZWlnaHQgfHwgMTUgfSxcbiAgICAgIHJhZGl1czogeyB2YWx1ZTogb3B0aW9ucz8ucmFkaXVzIHx8IDEwMCB9LFxuICAgIH1cblxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEljb3NhaGVkcm9uR2VvbWV0cnkoMSwgMTYpXG4gICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXMsXG4gICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgIHZlcnRleFNoYWRlcixcbiAgICAgIHNpZGU6IERvdWJsZVNpZGUsXG4gICAgfSlcblxuICAgIHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbClcbiAgfVxuXG4gIHNldCByYWRpdXMocmFkaXVzOiBudW1iZXIpIHtcbiAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHJhZGl1c1xuICB9XG5cbiAgZ2V0IHJhZGl1cygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnJhZGl1cy52YWx1ZVxuICB9XG5cbiAgc2V0IGhlaWdodChoZWlnaHQ6IG51bWJlcikge1xuICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMuaGVpZ2h0LnZhbHVlID0gaGVpZ2h0XG4gIH1cblxuICBnZXQgaGVpZ2h0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMuaGVpZ2h0LnZhbHVlXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpc0N1YmVUZXh0dXJlIiwiZGVmIiwiR3JvdW5kUHJvamVjdGVkRW52IiwiTWVzaCIsImNvbnN0cnVjdG9yIiwidGV4dHVyZSIsIm9wdGlvbnMiLCJpc0N1YmVNYXAiLCJ3IiwiX2IiLCJfYSIsImltYWdlIiwid2lkdGgiLCJjdWJlU2l6ZSIsIl9sb2RNYXgiLCJNYXRoIiwiZmxvb3IiLCJsb2cyIiwiX2N1YmVTaXplIiwicG93IiwibWF4IiwiaGVpZ2h0IiwiZGVmaW5lcyIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIiwiam9pbiIsInZlcnNpb24iLCJ1bmlmb3JtcyIsIm1hcCIsInZhbHVlIiwicmFkaXVzIiwiZ2VvbWV0cnkiLCJJY29zYWhlZHJvbkdlb21ldHJ5IiwibWF0ZXJpYWwiLCJTaGFkZXJNYXRlcmlhbCIsInNpZGUiLCJEb3VibGVTaWRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/objects/GroundProjectedEnv.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/shaders/HorizontalBlurShader.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/shaders/HorizontalBlurShader.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HorizontalBlurShader: () => (/* binding */ HorizontalBlurShader)\n/* harmony export */ });\nconst HorizontalBlurShader = {\n    uniforms: {\n        tDiffuse: {\n            value: null\n        },\n        h: {\n            value: 1 / 512\n        }\n    },\n    vertexShader: /* glsl */ `\n      varying vec2 vUv;\n\n      void main() {\n\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n      }\n  `,\n    fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform float h;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `\n};\n //# sourceMappingURL=HorizontalBlurShader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9zaGFkZXJzL0hvcml6b250YWxCbHVyU2hhZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFvQk8sTUFBTUEsdUJBQThDO0lBQ3pEQyxVQUFVO1FBQ1JDLFVBQVU7WUFBRUMsT0FBTztRQUFLO1FBQ3hCQyxHQUFHO1lBQUVELE9BQU8sSUFBTTtRQUFNO0lBQzFCO0lBQ0FFLGNBQUEsV0FBeUI7Ozs7Ozs7OztFQUFBO0lBVXpCQyxnQkFBQSxXQUEyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFBQTtBQXdCN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yb2NrZXRzaW0vLi4vLi4vc3JjL3NoYWRlcnMvSG9yaXpvbnRhbEJsdXJTaGFkZXIudHM/OTk1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFR3byBwYXNzIEdhdXNzaWFuIGJsdXIgZmlsdGVyIChob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBibHVyIHNoYWRlcnMpXG4gKiAtIGRlc2NyaWJlZCBpbiBodHRwOi8vd3d3LmdhbWVyZW5kZXJpbmcuY29tLzIwMDgvMTAvMTEvZ2F1c3NpYW4tYmx1ci1maWx0ZXItc2hhZGVyL1xuICogICBhbmQgdXNlZCBpbiBodHRwOi8vd3d3LmNha2UyMy5kZS90cmF2ZWxpbmctd2F2ZWZyb250cy1saXQtdXAuaHRtbFxuICpcbiAqIC0gOSBzYW1wbGVzIHBlciBwYXNzXG4gKiAtIHN0YW5kYXJkIGRldmlhdGlvbiAyLjdcbiAqIC0gXCJoXCIgYW5kIFwidlwiIHBhcmFtZXRlcnMgc2hvdWxkIGJlIHNldCB0byBcIjEgLyB3aWR0aFwiIGFuZCBcIjEgLyBoZWlnaHRcIlxuICovXG5cbmltcG9ydCB0eXBlIHsgSVVuaWZvcm0sIFRleHR1cmUgfSBmcm9tICd0aHJlZSdcbmltcG9ydCB0eXBlIHsgSVNoYWRlciB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCB0eXBlIEhvcml6b250YWxCbHVyU2hhZGVyVW5pZm9ybXMgPSB7XG4gIHREaWZmdXNlOiBJVW5pZm9ybTxUZXh0dXJlIHwgbnVsbD5cbiAgaDogSVVuaWZvcm08bnVtYmVyPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElIb3Jpem9udGFsQmx1clNoYWRlciBleHRlbmRzIElTaGFkZXI8SG9yaXpvbnRhbEJsdXJTaGFkZXJVbmlmb3Jtcz4ge31cblxuZXhwb3J0IGNvbnN0IEhvcml6b250YWxCbHVyU2hhZGVyOiBJSG9yaXpvbnRhbEJsdXJTaGFkZXIgPSB7XG4gIHVuaWZvcm1zOiB7XG4gICAgdERpZmZ1c2U6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBoOiB7IHZhbHVlOiAxLjAgLyA1MTIuMCB9LFxuICB9LFxuICB2ZXJ0ZXhTaGFkZXI6IC8qIGdsc2wgKi8gYFxuICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcblxuICAgICAgdm9pZCBtYWluKCkge1xuXG4gICAgICAgIHZVdiA9IHV2O1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG5cbiAgICAgIH1cbiAgYCxcbiAgZnJhZ21lbnRTaGFkZXI6IC8qIGdsc2wgKi8gYFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xuICAgIHVuaWZvcm0gZmxvYXQgaDtcblxuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG5cbiAgICB2b2lkIG1haW4oKSB7XG5cbiAgICBcdHZlYzQgc3VtID0gdmVjNCggMC4wICk7XG5cbiAgICBcdHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCAtIDQuMCAqIGgsIHZVdi55ICkgKSAqIDAuMDUxO1xuICAgIFx0c3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54IC0gMy4wICogaCwgdlV2LnkgKSApICogMC4wOTE4O1xuICAgIFx0c3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54IC0gMi4wICogaCwgdlV2LnkgKSApICogMC4xMjI0NTtcbiAgICBcdHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCAtIDEuMCAqIGgsIHZVdi55ICkgKSAqIDAuMTUzMTtcbiAgICBcdHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgKSApICogMC4xNjMzO1xuICAgIFx0c3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54ICsgMS4wICogaCwgdlV2LnkgKSApICogMC4xNTMxO1xuICAgIFx0c3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54ICsgMi4wICogaCwgdlV2LnkgKSApICogMC4xMjI0NTtcbiAgICBcdHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCArIDMuMCAqIGgsIHZVdi55ICkgKSAqIDAuMDkxODtcbiAgICBcdHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCArIDQuMCAqIGgsIHZVdi55ICkgKSAqIDAuMDUxO1xuXG4gICAgXHRnbF9GcmFnQ29sb3IgPSBzdW07XG5cbiAgICB9XG4gIGAsXG59XG4iXSwibmFtZXMiOlsiSG9yaXpvbnRhbEJsdXJTaGFkZXIiLCJ1bmlmb3JtcyIsInREaWZmdXNlIiwidmFsdWUiLCJoIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/shaders/HorizontalBlurShader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/shaders/VerticalBlurShader.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/shaders/VerticalBlurShader.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VerticalBlurShader: () => (/* binding */ VerticalBlurShader)\n/* harmony export */ });\nconst VerticalBlurShader = {\n    uniforms: {\n        tDiffuse: {\n            value: null\n        },\n        v: {\n            value: 1 / 512\n        }\n    },\n    vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n    fragmentShader: /* glsl */ `\n\n  uniform sampler2D tDiffuse;\n  uniform float v;\n\n  varying vec2 vUv;\n\n  void main() {\n\n    vec4 sum = vec4( 0.0 );\n\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n    gl_FragColor = sum;\n\n  }\n  `\n};\n //# sourceMappingURL=VerticalBlurShader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9zaGFkZXJzL1ZlcnRpY2FsQmx1clNoYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBb0JPLE1BQU1BLHFCQUEwQztJQUNyREMsVUFBVTtRQUNSQyxVQUFVO1lBQUVDLE9BQU87UUFBSztRQUN4QkMsR0FBRztZQUFFRCxPQUFPLElBQU07UUFBTTtJQUMxQjtJQUNBRSxjQUFBLFdBQXlCOzs7Ozs7Ozs7RUFBQTtJQVV6QkMsZ0JBQUEsV0FBMkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQUFBO0FBeUI3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JvY2tldHNpbS8uLi8uLi9zcmMvc2hhZGVycy9WZXJ0aWNhbEJsdXJTaGFkZXIudHM/MjM1OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFR3byBwYXNzIEdhdXNzaWFuIGJsdXIgZmlsdGVyIChob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBibHVyIHNoYWRlcnMpXG4gKiAtIGRlc2NyaWJlZCBpbiBodHRwOi8vd3d3LmdhbWVyZW5kZXJpbmcuY29tLzIwMDgvMTAvMTEvZ2F1c3NpYW4tYmx1ci1maWx0ZXItc2hhZGVyL1xuICogICBhbmQgdXNlZCBpbiBodHRwOi8vd3d3LmNha2UyMy5kZS90cmF2ZWxpbmctd2F2ZWZyb250cy1saXQtdXAuaHRtbFxuICpcbiAqIC0gOSBzYW1wbGVzIHBlciBwYXNzXG4gKiAtIHN0YW5kYXJkIGRldmlhdGlvbiAyLjdcbiAqIC0gXCJoXCIgYW5kIFwidlwiIHBhcmFtZXRlcnMgc2hvdWxkIGJlIHNldCB0byBcIjEgLyB3aWR0aFwiIGFuZCBcIjEgLyBoZWlnaHRcIlxuICovXG5cbmltcG9ydCB0eXBlIHsgSVVuaWZvcm0sIFRleHR1cmUgfSBmcm9tICd0aHJlZSdcbmltcG9ydCB0eXBlIHsgSVNoYWRlciB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCB0eXBlIFZlcnRpY2FsQmx1clNoYWRlclVuaWZvcm1zID0ge1xuICB0RGlmZnVzZTogSVVuaWZvcm08VGV4dHVyZSB8IG51bGw+XG4gIHY6IElVbmlmb3JtPG51bWJlcj5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVmVydGljYWxCbHVyU2hhZGVyIGV4dGVuZHMgSVNoYWRlcjxWZXJ0aWNhbEJsdXJTaGFkZXJVbmlmb3Jtcz4ge31cblxuZXhwb3J0IGNvbnN0IFZlcnRpY2FsQmx1clNoYWRlcjogSVZlcnRpY2FsQmx1clNoYWRlciA9IHtcbiAgdW5pZm9ybXM6IHtcbiAgICB0RGlmZnVzZTogeyB2YWx1ZTogbnVsbCB9LFxuICAgIHY6IHsgdmFsdWU6IDEuMCAvIDUxMi4wIH0sXG4gIH0sXG4gIHZlcnRleFNoYWRlcjogLyogZ2xzbCAqLyBgXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcblxuICAgIHZvaWQgbWFpbigpIHtcblxuICAgICAgdlV2ID0gdXY7XG4gICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG5cbiAgICB9XG4gIGAsXG4gIGZyYWdtZW50U2hhZGVyOiAvKiBnbHNsICovIGBcblxuICB1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcbiAgdW5pZm9ybSBmbG9hdCB2O1xuXG4gIHZhcnlpbmcgdmVjMiB2VXY7XG5cbiAgdm9pZCBtYWluKCkge1xuXG4gICAgdmVjNCBzdW0gPSB2ZWM0KCAwLjAgKTtcblxuICAgIHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgLSA0LjAgKiB2ICkgKSAqIDAuMDUxO1xuICAgIHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgLSAzLjAgKiB2ICkgKSAqIDAuMDkxODtcbiAgICBzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55IC0gMi4wICogdiApICkgKiAwLjEyMjQ1O1xuICAgIHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgLSAxLjAgKiB2ICkgKSAqIDAuMTUzMTtcbiAgICBzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55ICkgKSAqIDAuMTYzMztcbiAgICBzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55ICsgMS4wICogdiApICkgKiAwLjE1MzE7XG4gICAgc3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSArIDIuMCAqIHYgKSApICogMC4xMjI0NTtcbiAgICBzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55ICsgMy4wICogdiApICkgKiAwLjA5MTg7XG4gICAgc3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSArIDQuMCAqIHYgKSApICogMC4wNTE7XG5cbiAgICBnbF9GcmFnQ29sb3IgPSBzdW07XG5cbiAgfVxuICBgLFxufVxuIl0sIm5hbWVzIjpbIlZlcnRpY2FsQmx1clNoYWRlciIsInVuaWZvcm1zIiwidERpZmZ1c2UiLCJ2YWx1ZSIsInYiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/shaders/VerticalBlurShader.js\n");

/***/ })

};
;